<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/Xh2yCr81kktx7JqZfzYQnG?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
-->
<!DOCTYPE html>
<html>
<head>
  <title>07PLSQL</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 

<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>PLSQL</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a class="red" href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
        <li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <aside class="note">
      <section>
	<p>PL/SQL is an abbreviation of Programming Language/SQL. PL/SQL is a procedural extension of SQL. It means that it is quite typical procedural programming like C, C++, Java, Python, etc with additional syntactical construction that allow fro processing of SQL statements.</p>
	<br/>
	<p>So, in brief we can say that  PL/SQL = procedural Programming Language + SQL</p>
	<br/>
	<p>SQL itself is a declarative programming language and it is not computationally complete and it cannot be used for ordinary procedural programming. It  is why we need PL/SQL to bridge a gap between a high level declarative query language and a procedural programming language.</p>
	<br/>
	<p>PL/SQL is a subset of a programming language Ada formulated and implemented in mid 1980s of the previous century for the Department of Defence in USA.</p>
	<br/>
	<p>PL/SQL  can be "described" by the following "equation":</p>
	<br/>
	<p>PL/SQL = Data Manipulation statements of SQL + SELECT statement + variables + assignment statement + conditional control statements + repetition statement + exception handling + procedure and function statements + packages</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">PL/SQL ? What is it ? Why do we need it ?</h2>
    </hgroup>
    <article>
      <ul class="build"> 
        <li><a href="https://protect-au.mimecast.com/s/3aifCvl122HvqV98CzZRUL?domain=docs.oracle.com">PL/SQL</a> is a procedural extension of <strong class="blue">SQL</strong></li>
	<li><strong class="red">PL/SQL</strong> = procedural <strong class="red">P</strong>rogramming <strong class="red">L</strong>anguage +
	  <strong class="blue">SQL</strong></li>
	<li>We need <strong class="red">PL/SQL</strong> to bridge a gap between a <strong class="blue">high level declarative query languag</strong>e and a <strong class="blue">procedural programming language</strong></li>
	<li><strong class="red">PL/SQL</strong> is a subset of a programming language <a href="https://protect-au.mimecast.com/s/2MPpCwV1ppHokrjxcKUzNP?domain=en.wikipedia.org">Ada</a>
</li>
        <li><strong class="red">PL/SQL</strong> =
          <ul class="build">
	    <li>Data Manipulation statements of SQL +</li>
	    <li><strong class="blue prettyprint">SELECT</strong> statement +</li>
	    <li>variables +</li>
	    <li>assignment statement +</li>
	    <li>conditional control statements +</li>
	    <li>repetition statement +</li>
	    <li>exception handling +</li>
	    <li>procedure and function statements + packages</li>
          </ul>
        </li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 04 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a class="red" href="#5">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 05 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>PL/SQL like many other procedural programming languages is a block-structured language. It means that its basic units such as anonymous blocks, procedures, and functions are the logical blocks in a program. The blocks can be nested in each other and it can perform its own declaration of variables valid only in a scope of a given block.</p>
	<br/>
	<p>Anonymous block is persistent for only a single processing, it is not stored in a data dictionary, and when its processing is completed it is removed from a transient memory.</p>
	<br/>
	<p>A named block (either procedure or function) is persistent for a number of processing, it can be stored in a data dictionary and after its processing is completed it still occupies persistent storage in a data dictionary. Persistence of the named blocks is one of the main difference between PL/SQL and ther typical procedural programming languages. From such perspective PL/SQL is similar to a persistent programming language.</p>
	<br/>
	<p>Logical blocks can be nested to any level.</p>
	<br/>
	<p>Logical blocks may consist of declarative, executable, and exception components.</p>
	<br/>
	<p>A declarative component consists of declarations of constants, variables, types, methods, cursors, etc, and it is optional.</p>
	<br/>
	<p>An executable component consists of executable code and must have at least one statement. If you would like to create a block that does nothing then a statement NULL would be a perfect contents of such block.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Program structure</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">PL/SQL</strong> is a <strong class="red">block-structured language</strong></li>
	<li>It means that its basic units such as <strong class="red">anonymous blocks</strong>, <strong class="red">procedures</strong>, and <strong class="red">functions</strong> are the <strong class="red">logical blocks</strong></li>
	<li><strong class="red">Anonymous block</strong> is persistent for only  a single processing, i.e. it is <strong class="red">not stored</strong> in a <strong class="blue">data dictionary</strong></li>
	<li>A <strong class="red">named block</strong> (either <strong class="red">procedure</strong> or <strong class="red">function</strong>) is persistent for many processings, i.e. it can be <strong class="red">stored</strong> in a <strong class="blue">data dictionary</strong></li> 
	<li><strong class="red">Logical blocks</strong> can be nested to any level</li>
	<li><strong class="red">Logical blocks</strong> consist of <strong class="red">declarative</strong>, <strong class="red">executable</strong>, and <strong class="red">exception</strong> components</li>
	<li>A <strong class="red">declarative component</strong> consists of declarations of constants, variables, types, methods, cursors, etc, and it is optional</li>
	<li>An <strong class="red">executable component</strong> consists of executable code and must have at least one statement</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 06 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>An exception component consists of executable code handling exceptions and it is optional. We provide the skeletons of logical blocks below.
</p>
	<br/>
	<p>A sample anonymous block consists of DECLARE keyword and a sequence declarations.  Then, a keyword BEGIN that starts executable component. And finally an optional keyword EXCEPTION that starts exception component. A sample structure of anonymous block is given below</p>
	<br/>
	<p>-- A sample single line comment</p>
	<br/>
	<p>DECLARE -- A keyword, beginning of declarative component </p>
	<br/>
	<p>/*  Declarative</p>
	<br/>
	<p>component  A sample multiline comment  */ </p>
	<br/>
	<p>BEGIN   -- A keyword, the beginning of executable component </p>
	<br/>
	<p>/*  Executable component  */</p>
	<br/>
	<p>NULL;   -- it must include at least one statement,</p>
	<br/>
	<p>-- NULL; is an optional empty statement</p>
	<br/>
	<p>EXCEPTION -- A keyword, the beginning of exception component</p>
	<br/>
	<p>/* Exception component */</p>
	<br/>
	<p>END;-- A keyword, the end of anonymous block</p>
	<br/>
	<p>/ -- A forward slash line means: execute this block</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Program structure</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>An <strong class="red">exception component</strong> consists of executable code handling exceptions and it is optional</li>	
        <li>A sample <strong class="red">anonymous block</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">

-- A sample single line comment
DECLARE                 -- A keyword, beginning of declarative component 
/*     Declarative
        component          A sample multiline comment                        */ </pre>
	    <pre class="prettyprint" data-lang="PL/SQL">

BEGIN                   -- A keyword, the beginning of executable component 
/*     Executable component                                                  */
NULL;                   -- it must include at least one statement,
                        -- NULL; is an optional empty statement</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">

EXCEPTION               -- A keyword, the beginning of exception component
/*     Exception component                                                   */
END;                    -- A keyword, the end of anonymous block              
/                       -- A forwad slash line means: execute this block</pre>
	  </ul>
	</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 07 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a class="red" href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 08 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Declarative components in PL/SQL block contain declarations of variables, constants, cursors, procedures, and functions.</p>
	<br/>
	<p>Declarations start from a keyword DECLARE
	<br/><br/>
	DECLARE</p><br/>
	<p>A declaration of a variable start from a name of a variable followed by type of a variable. A line below is a declaration of a variable stock_num of type NUMBER(5). A system of elementary types is directly taken from SQL. It store  the types like DATE, NUMBER, VARCHAR.
	<br/></br>
	stock_num NUMBER(5);
	<br/>
	stock_name VARCHAR(30);
	<br/>
	stock_date DATE;</p>
	<br/>
	<p>A line below declares a variable stock_required of type NUMBER(5) and initialises the variable with a value 30. An assignment in Pl/SQL is denoted by a sequence of two characters ':='.
	<br/><br/>
	stock_required NUMBER(5) := 30;</p>
	<br/>
	A line below is a declaration of a constant limi of type NUMBER(11,2) and initialised with 2.45.
	<br/><br/>
	limit CONSTANT NUMBER(11,2) := 2.45;</p>
	<br/>
	<p>A line below is a declaration of a variable stock_value of the same type as a type of a column value in a relational table STOCK. In PL/SQL it is a recommended way of declaration of variables that store data retrieved from the relational tables. Then, a change of type of a column value does not need a change of type of variables in all PL/SQL blocks that store data retrieved from a column value in a relational table STOCK.
	<br/><br/>
	stock_value STOCK.value%TYPE</p>
	<br/>
	<p>A line below is a declaration of a variable stock_row of the same type as a row in a relational table STOCK. A variable stock_row can be considered as a flat record declaration in the other procedural languages. In PL/SQL it is a recommnded way of declaration of variable of type row in a given relational table.
	<br/><br/>
	<p>stock_row STOCK%ROWTYPE</p>
	<br/>
	<p>A line below is a declaration of a cursor. A cursor is a syntactical structure that allows for processing the results of SELECT statement in row by row mode. Or in the other words, iterate over the results from processing of SELECT statement. We shall return to cursor later on in this presentation.
	<br/><br/>
	CURSOR Q IS
	<br/>
	&emsp;SELECT snum
	<br/>
	&emsp;FROM STUDENT
	<br/>
	&emsp;WHERE name ='Jo';</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Declarative components</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Declarative components contain declarations of variables, constants, cursors, procedures, and functions
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">DECLARE</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_num NUMBER(5);</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_name VARCHAR(30);</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_date DATE;</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_required NUMBER(5) := 30;</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  limit CONSTANT NUMBER(11,2) := 2.45;</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_value STOCK.value%TYPE</pre>
		<pre class="prettyprint" data-lang="PL/SQL">  stock_row STOCK%ROWTYPE</pre>				
		<pre class="prettyprint" data-lang="PL/SQL">  CURSOR Q IS
    SELECT snum
    FROM STUDENT
    WHERE name ='Jo';</pre>
	  </ul>
	</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 09 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Executable components in PL/SQL block include assignment statements, conditional control statements, iterative statements, procedure and function calls, SQL statements
</p>
	<br/>
	<p>A line below is an assignment statement where a number 910000 becomes a value of a variable student_num.
	<br/>
	student_num := 910000;</p>
	<br/>
	<p>A sequence of lines below is an assignment statement where a result from processing of SELECT statement becomes a value of a variable student_name. Note that when SELECT statement returns no values or when SELECT statement returns more than one value then processing of the statement fails and exception is generated.
	<br/>
	SELECT name
	<br/>
	INTO student_name
	<br/>
	FROM STUDENT
	<br/>
	WHERE s# = student_num;</p>
	<br/>
	<p>A sequence of lines below is a conditional IF statement well known from the other procedural programming languages. It has the same semantics as in the other procedural programming languages. Note a keyword ELSIF that means "else if" and note a blank between END and IF in a keyword 'END IF'.
	<br/>
	IF (a > b) THEN
	<br/>
	&emsp;a := a + 1;
	<br/>
	&emsp;c := c + 2;
	<br/>
	ELSIF (a < b) THEN
	<br/>
	&emsp;c := c - 2;
	<br/>
	ELSE
	<br/>
	&emsp;b:= b + 1;
	<br/>
	END IF;</p>
	<br/>
	<p>A sequence of lines below is an iterative FOR statement well known from the other procedural programming languages. It has the same semantics as in the other procedural programming languages. Note a blank between END and LOOP in a keyword 'END LOOP'.</p>
	<br/>
	FOR i IN 1..100 LOOP
	<br/>
	&emsp;b := b - i;
	<br/>
	END LOOP;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Executable components</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Executable components include assignment statements, conditional control statements, iterative statements, procedure and function calls, SQL statements
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">student_num := 910000;</pre>
            <pre class="prettyprint" data-lang="PL/SQL">
SELECT name
INTO student_name
FROM STUDENT
WHERE s# = student_num;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
IF (a > b) THEN
  a := a + 1;
  c := c + 2;
ELSIF (a < b) THEN
  c := c - 2;	   
ELSE
  b:= b + 1;
END IF;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
FOR i IN 1..100 LOOP
  b := b - i;
END LOOP;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 10 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Exception component of PL/SQL block consists of executable statements that service the exceptional situations during execution.</p>
	<br/>
	<p>A sequence of lines given below handles an exception NO_DATA_FOUND. Such exception happens when SELECT statement with INTO clause (see the previous slide) returns now data and no value can be assigned to PL/SQL variable. Because it would leave PL/SQL variable with undefined value such  error is caught by an exception handler given below. Exception handler inserts into a table AUDIT_TABLE the current date and time and a value of PL/SQL variable snum.</p>
	<br/>
	<p>The second handler handles any other exception that may happen during the processing of PL/SQL block.
	<br/><br/>
	EXCEPTION
	<br/>
	WHEN NO_DATA_FOUND THEN
	<br/>
	&emsp;INSERT INTO AUDIT_TABLE VALUES( SYSDATE, snum )
	<br/>
	WHEN OTHERS
	<br/>
	&emsp;&emsp;i: = i + 1
	<br/>
	&emsp;UPDATE DEPARTMENT
	<br/>
	&emsp;SET budget = i * budget;
	<br/>
	END;</p>
	<br/>
	<p>A sequence of lines given below declares a user defined exception "too_large" and shows a handler for a user defined exception "too_large".
	<br/><br/>
	DECLARE
	<br/>
	&emsp;too_large EXCEPTION; 
	<br/>
	BEGIN 
	<br/>
	&emsp;IF a > 100000 THEN<br/>
	&emsp;&emsp;RAISE too_large;
	<br/>
	&emsp;END IF;
	<br/>
	EXCEPTION 
	<br/>
	WHEN too_large THEN
	<br/>
	&emsp;DBMS_OUTPUT.PUT_LINE ('Too large ! ');
	<br/>
	END;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Exception components</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Exception component consists of executable statements that service the exceptional situations during execution 
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
EXCEPTION
WHEN NO_DATA_FOUND THEN
 INSERT INTO AUDIT_TABLE VALUES( SYSDATE, snum )
WHEN OTHERS
  i: = i + 1
  UPDATE DEPARTMENT
  SET budget = i * budget;
END;</pre>
            <pre class="prettyprint" data-lang="PL/SQL">
DECLARE 
  too_large EXCEPTION; 
BEGIN 
  IF a > 100000 THEN 
     RAISE too_large; 
  END IF; 
EXCEPTION 
  WHEN too_large THEN 
    DBMS_OUTPUT.PUT_LINE ('Too large ! ');
END;</pre>	    
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 11 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a class="red" href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 12 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of an anonymous block is the following</p>
	<br/>
	<p>DECLARE</p>
	<br/>
	<p>-- optional declarations</p>
	<br/>
	<p>BEGIN</p>
	<br/>
	<p>-- executable statements, at least one statement is required</p>
	<br/>
	<p>EXCEPTION</p>
	<br/>
	<p>-- optional exception handlers</p>
	<br/>
	<p>END;</p>
	<br/>
	<p>/ -- processing command</p>
	<br/>
	<p>Below we list a sample Hello world ! anonymous block. A line SET SERVEROUTPUT ON is needed to display the results produced by  DBMS_OUTPUT.PUT_LINE('Hello world !');</p>
	<br/>
	<p>A function PUT_LINE included in a package DBMS_OUTPUT inserts a string 'Hello world !' into an output buffer and displays the contents of an output buffer on a screen.  All messages are displayed  on the screen AFTER processing of entire block is completed. A forward slash character in the last line starts processing of an anonymous PL/SQL block.
	<br/><br/>
	SET SERVEROUTPUT ON
	<br/>
	BEGIN
	<br/>
	DBMS_OUTPUT.PUT_LINE('Hello world !'); 
	<br/>
	END; 
	<br/>
	/</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Structure of anonymous block</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>A <i>birds-eye view</i> of an anonymous block is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">DECLARE</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional declarations</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- executable statements, at least one statement is required</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">EXCEPTION</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional exception handlers</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">END;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">/ -- processing command</pre>
	  </ul>
	</li>
	<li>A sample <strong class="blue prettyprint">Hello world !</strong> <strong class="red">anonymous block</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="SQL*Plus">
SET SERVEROUTPUT ON</pre>	    
	    <pre class="prettyprint" data-lang="PL/SQL">
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello world !'); 
END; 
/</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 13 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The lines below show a sample anonymous PL/SQL block.</p>
	<br/>
	<p>It contains a declaration of a variable average of type NUMBER(8,2) (do you remember what does 8,2 mean ?)
	<br/><br/>
	DECLARE
	<br/>
	average NUMBER(8,2);</p>
	<br/>
	<p>Then, SELECT statement find an average of all values in a column budget in a relational table DEPARTMENT. Such SELECT statement returns at most one value and because of that it can be assigned to a variable average. In a very special case when a column budget is full of NULLs SELECT statement return nothing and NO_DATA_FOUND exception is triggered. If an exception is not handled then processing of the block is terminated with an error.
	<br/><br/>
	BEGIN
	<br/>
	SELECT avg(budget)
	<br/>
	INTO average
	<br/>
	FROM DEPARTMENT;</p>
	<br/>
	<p>Next, if average is less than 3000 UPDATE statement is processed to increase all budget by 100.
	<br/><br/>
	IF average < 3000 THEN
	<br/>
	UPDATE DEPARTMENT
	<br/>
	SET budget = budget+100;
	<br/>
	END IF;</p>
	<br/>
	<p>Finally END ends anonymous block and / triggers its processing.
	<br/>
	END;
	<br/>
	/</p>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">A sample anonymous block</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Processing SQL statements in a sample <strong class="red">anonymous block</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">DECLARE</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  average NUMBER(8,2);</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  SELECT avg(budget)</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  INTO average</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  FROM DEPARTMENT;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  IF average < 3000 THEN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">    UPDATE DEPARTMENT</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">    SET budget = budget+100;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  END IF;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">END;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">/</pre>				    
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 14 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of a procedure is the following.</p>
	<br/>
	<p>PROCEDURE procedure_name ( parameters ) IS</p>
	<br/>
	<p>-- optional declarations</p>
	<br/>
	<p>BEGIN</p>
	<br/>
	<p>-- executable statements, at least one statements is required</p>
	<br/>
	<p>EXCEPTION</p>
	<br/>
	<p>-- optional exception handlers</p>
	<br/>
	<p>END procedure_name;</p>
	<br/>
	<p>Below we list a sample Hello world ! program implemented as PL/SQL procedure. The procedure has a name hello_world and two input and one output parameters.</p>
	<br/>
	<p>A keyword IN following a name of a parameter hello and a name of parameter world means that both parameters are input parameters.</p>
	<br/>
	<p>A keyword OUT following a name of hello-world parameter denotes an output parameter.</p>
	<br/>
	<p>A type of each parameter is VARCHAR.</p>
	<br/>
	<p>The procedure concatenates (|| is a symbol of string concatenation operation) a value passed through the first parameter hello with a single blank (' ') and with a value passed through the second input parameter world and with a string ' !'.</p>
	<br/>
	<p>The result of concatenation becomes a value of an output parameter hello_world and it is passed out of the procedure.
	<br/>
	PROCEDURE hello_world ( 
	<br/>
	&emsp;hello IN  VARCHAR2,
	<br/>
	&emsp;world IN  VARCHAR2,
	<br/>
	&emsp;hello_world OUT VARCHAR2 ) IS
	<br/>
	BEGIN
	<br/>
	&emsp;hello_world := hello || ' ' || world || ' !';
	<br/>
	END hello_world;</p>
	<br/>
	<p>Note, a name of a procedure following the final END in the last line.</p>
	<br/>
	<p>There is no need for / because we do not plan to process the procedure. In the future we shall store the procedures win a data dictionary and we shall use EXECUTE statement to process stored procedures.</p>
	<br/>
	<p></p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Structure of procedure</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>A <i>birds-eye view</i> of a <strong class="red">procedure</strong> is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">PROCEDURE procedure_name ( parameters ) IS</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional declarations</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- executable statements, at least one statements is required</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">EXCEPTION</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional exception handlers</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">END procedure_name;</pre>
	  </ul>
	</li>
	<li>A sample <strong class="blue prettyprint">hello world</strong> <strong class="red">procedure</strong>
	  <ul class="build">	
<pre class="prettyprint" data-lang="PL/SQL">PROCEDURE hello_world ( hello IN  VARCHAR,
                        world IN  VARCHAR,
                        hello_world OUT VARCHAR ) IS
BEGIN
  hello_world := hello || ' ' || world || ' !';
END hello_world;</pre>
	  </ul>
	</li>    
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 15 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The lines below show a sample PL/SQL procedure "raise_budget".</p>
	<br/>
	<p>The procedure raise_budget has two input parameters: "department_name" of type VARCHAR and "budget_limit" of type NUMBER.
	<br/><br/>
	PROCEDURE raise_budget(
	<br/>
	&emsp;department_name IN VARCHAR,
	<br/>
	&emsp;budget_limit IN NUMBER ) IS</p>
	<br/>
	<p>The procedure declares one local variable "current_budget" of the same type as a column budget in a relational table DEPARTMENT.</p>
	<br/><br/>
	&emsp;current_budget DEPARTMENT.budget%TYPE;</p>
	<br/>
	<p>The procedure finds a budget of a department that has a name passed through an input parameter "department_name". An atribute "name" is a primary key in a relational table DEPARTMENT and because of that at most one value of budget can be found. If a value of input parameter "department_name" is different from any name of department in a column "name" then SELECT statement returns nothing, NO_DATA_FOUND exception is rasied and if it is not handled by a procedure "raise_budget" the execution ends with an error. If SELECT statement returns one value of budget then such value is assigned as a value of variable "current_budget", please see INTO clause in SELECT statement.
	<br/><br>
	BEGIN
	<br/>
	&emsp;SELECT budget INTO current_budget  FROM DEPARTMENT  WHERE name = department_name;</p>
	<br/>
	<p>If a value assigned to a variable "curent_budget" is less that a value passed through an input parameter "budget_limit" then a budget of department that has a name the same as a value of input parameter "department_name" is set by UPDATE statement to a value passed through an input parameter "budget_limit".
	<br/><br/>
	&emsp;IF current_budget < budget_limit THEN
	<br/>
	&emsp;&emsp;UPDATE DEPARTMENT SET budget := budget_limit WHERE name = department_name;</p>
	<br/>
	<p>If a value assigned to a variable "curent_budget" is greater or equal to a value passed through an input parameter "budget_limit" then a message informing about correctness of a budget is inserted into AUDIT relational table.
	<br/><br/>
	&emsp;ELSE
	<br/>
	&emsp;&emsp;INSERT INTO AUDIT VALUES( 'Math budget OK', current_budget);
	<br/>
	&emsp;END IF;</p>
	<br/>
	<p>Then, processing of COMMIT statement makes all modifications performed by the function permanent in a database.
	<br/><br/>
	&emsp;COMMIT;</p>
	<br/>
	<p>Processing of COMMIT statement ends processing of the procedure.
	<br/>
	END raise_budget;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">A sample procedure</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Processing SQL statements in a sample <strong class="red">procedure</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">PROCEDURE raise_budget(</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">                        department_name IN VARCHAR,</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">                        budget_ limit IN NUMBER ) IS</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  current_budget DEPARTMENT.budget%TYPE;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">

  SELECT budget INTO current_budget  FROM DEPARTMENT  WHERE name = department_name;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  IF current_budget < budget_limit THEN</pre>
            <pre class="prettyprint" data-lang="PL/SQL">    UPDATE DEPARTMENT SET budget := budget_limit WHERE name = department_name;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  ELSE</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">    INSERT INTO AUDIT VALUES( 'Math budget OK', current_budget);</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  END IF;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  COMMIT;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">END raise_budget;</pre>	
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 16 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of a function is the following</p>
	<br/>
	<p>FUNCTION function_name ( parameters )</p>
	<br/>
	<p>RETURN type-specification IS</p>
	<br/>
	<p>-- optional declarations</p>
	<br/>
	<p>BEGIN</p>
	<br/>
	<p>-- executable statements, at least one statements is required</p>
	<br/>
	<p>EXCEPTION</p>
	<br/>
	<p>-- optional exception handlers</p>
	<br/>
	<p>END function_name;</p>
	<br/>
	<p>Below we list a sample Hello world ! program implemented as PL/SQL function. The function has a name "hello_world" and two input parameters.</p>
	<br/>
	<p>A keyword IN following a name of a parameter "hello" and a name of parameter "world "means that both parameters are input parameters.</p>
	<br/>
	<p>A type of each parameter is VARCHAR.</p>
	<br/>
	<p>A statement RETURN VARCHAR means that the function returns a string of characters.</p>
	<br/>
	<p>The fucntion concatenates (|| is a symbol of string concatenation operation) a value passed through the first parameter "hello" with a single blank (' ') and with a value passed through the second input parameter "world": and with a string ' !'.</p>
	<br/>
	The result of concatenation becomes a value returned by the function.</p>
	<br/>
	FUNCTION hello_world ( hello IN  VARCHAR,
	<br/>
	&emsp;world IN  VARCHAR2 ) IS
	<br/>
	RETURN VARCHAR2 IS
	<br/>
	BEGIN
	<br/>
	&emsp;RETURN hello || ' ' || world || ' !';
	<br/>
	END hello_world;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Structure of function</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>A <i>birds-eye view</i> of a <strong class="red">function</strong> is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">FUNCTION function_name ( parameters )</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">RETURN type-specification IS</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional declarations</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- executable statements, at least one statements is required</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">EXCEPTION</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  -- optional exception handlers</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">END function_name;</pre>
	  </ul>
	</li>
	<li>A sample <strong class="blue prettyprint">hello world</strong> <strong class="red">function</strong>
	  <ul class="build">	
	    <pre class="prettyprint" data-lang="PL/SQL">FUNCTION hello_world ( hello IN  VARCHAR2,
                       world IN  VARCHAR2 ) IS
RETURN VARCHAR2 IS
BEGIN
  RETURN hello || ' ' || world || ' !';
END hello_world;</pre>
	  </ul>
	</li>    	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 17 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The lines below show a sample PL/SQL function "raise_budget".</p>
	<br/>
	<p>The function "raise_budget" has two input parameters: "department_name" of type VARCHAR and "budget_limit" of type NUMBER.
	<br/><br/>
	FUNCTION raise_budget(
	<br/>
	&emsp;department_name IN VARCHAR,
	<br/>
	&emsp;budget_ limit IN NUMBER ) </p>
	<br/>
	<p>The function returns a value of type NUMBER.</p>
	<br/>
	<p>&emsp;RETURN NUMBER IS</p>
	<br/>
	<p>The function declares one local variable "current_budget" of the same type as a type of column buget in a relational table DEPARTMENT.</p>
	<br/>
	<p>&emsp;current_budget DEPARTMENT.budget%TYPE;</p>
	<br/>
	<p>The function finds a budget of a department that has a name passed through an input parameter "department_name". An atribute "name" is a primary key in a relational table DEPARTMENT and because of that at most one value of budget can be found. If a value of input parameter "department_name" is different from any name of department in a column "name" then SELECT statement returns nothing, NO_DATA_FOUND exception is rasied and if it is not handled by a procedure "raise_budget" the execution ends with an error. If SELECT statement returns one value of budget then such value is assigned as a value of variable "current_budget", please see INTO clause in SELECT statement.
	<br/>
	&emsp;BEGIN
	<br/>
	&emsp;&emsp;SELECT budget INTO current_budget FROM DEPARTMENT WHERE name = department_name;</p>
	<br/>
	<p>If a value assigned to a variable "curent_budget" is less that a value passed through an input parameter "budget_limit" then a budget of department that has a name the same as a value of input parameter "department_name" is set by UPDATE statement to a value passed through an input parameter "budget_limit".
	<br/>
	&emsp;IF current_budget < budget_limit THEN
	<br/>
	&emsp;&emsp;UPDATE DEPARTMENT SET budget = budget_limit WHERE name = department_name;</p>
	<br/>
	<p>The function returns a value assigned to the second input parameter "budget_limit".
	<br/>
	&emsp;RETURN budget_limit;</p>
	<br/>
	<p>If a value assigned to a variable "curent_budget" is greater or equal to a value passed through an input parameter "budget_limit" then a message informing about correctness of a budget is inserted into AUDIT relational table and ...
	<br/>
	&emsp;ELSE
	<br/>
	&emsp;&emsp;INSERT INTO AUDIT VALUES( 'Math budget OK', current_budget);
	<br/>
	... the function returns a value assigned to the second input parameter "budget_limit".
	<br/>
	&emsp;&emsp;RETURN current_budget;
	<br/>
	&emsp;END IF;
	<br/>
	Then, processing of COMMIT statement makes all modifications performed by the function permanent in a database.
	<br/>
	&emsp;COMMIT;</p>
	<br/>
	<p>Processing of COMMIT statement ends processing of the function.
	<br/>
	END raise_budget;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Structure of function</h2>
    </hgroup>
    <article class="smallest">
      <ul class="build">
       <li>Processing SQL statements in a sample <strong class="red">function</strong>
	 <ul class="build">
	   <pre class="prettyprint" data-lang="PL/SQL">FUNCTION raise_budget(</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">                       department_name IN VARCHAR,</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">                       budget_ limit IN NUMBER ) </pre>
	   <pre class="prettyprint" data-lang="PL/SQL">RETURN NUMBER IS</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">  current_budget DEPARTMENT.budget%TYPE;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">BEGIN</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">
  SELECT budget INTO current_budget FROM DEPARTMENT WHERE name = department_name;</pre>
           <pre class="prettyprint" data-lang="PL/SQL">  IF current_budget < budget_limit THEN</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">    UPDATE DEPARTMENT SET budget = budget_limit WHERE name = department_name;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">    RETURN budget_limit;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">  ELSE</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">    INSERT INTO AUDIT VALUES( 'Math budget OK', current_budget);</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">      RETURN current_budget;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">  END IF;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">  COMMIT;</pre>
	   <pre class="prettyprint" data-lang="PL/SQL">END raise_budget;</pre>
	 </ul>
       </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 18 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a class="red" href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 19 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>This slide lists some of the predefined data types in PL/SQL: INTEGER, DECIMAL, NUMBER, CHAR, DATE, VARCHAR, VARCHAR2, LONG, BOOLEAN, ROWID, EXCEPTION.</p>
	<br/>
	<p>A type VARCHAR2 is the same as a type VARCHAR. If we create any data object of type VARCHAR then such type is automatically converted to VARCHAR2.
</p>
	<br/>
	<p>A type ROWID means "row identifier". A value assigned to a variable of tytpe ROWID must have an internal structure consistent with an internal structure of a ow identifier (file number, block, number, offset with a block).
</p>
	<br/>
	<p>A very useful mechanism in PL/SQL is an implicit type declaration. Implicit type declaration means that a type of variable is not explicitly given after a name of a variable but it is provided as a reference to a type of another data object.
</p>
	<br/>
	<p>For example, a variable "student_no" has the same type  as a column snum in a relational table STUDENT.  A variable "student_name" has the same type  as a column name in a relational table STUDENT.
	<br/><br/>
	student_no  STUDENT.snum%TYPE;
	<br/>
	student_name STUDENT.name%TYPE;</p>
	<br/>
	<p>A variable "student-row" is of a type "row from a relational table STUDENT".  A "dot notation" can be used to access individual values in a row variable. For example, an assignment statement student_row.snum := 1234567; assigns a value 1234567 to a column snum in a row "student_row".</p>
	<br/>
	<p>student_row STUDENT%ROWTYPE;</p>
	<br/>
	<p>In the first fragment of code a block starts from assignment statement that assigns a value 1234567 to a variable "student_no.".
	<br/><br/>
	BEGIN
	<br/>
	student_no := 1234567;</p>
	<br/>
	<p>In this fragment of code SELECT statement finds a name of a student who has a student number equal to a value assigned to a variable "student_no". A column "snum" is a primary key in a relational table STUDENT and because of that SELECT statement cannot retrieve more than one row. When no rows are retrieved the an exception NO_DATA_FOUND is raised and if a block does not have an appropriate exception handler the processing ends with an error.</p>
	<br/>
	<p>SELECT name FROM STUDENT INTO student_name WHERE snum = student_no;</p>
	<br/>
	<p>In the next fragment of code the values are assigned to the columns "snum" and "name" and "dob" in a row variable "student_row". Then the columns are used in INSERT statement. Please note that it is not allowed to use a row variable without columns names in INSERT statement.
	<br/><br>
	student_row.snum := 1234567;
	<br/>
	student_row.name := 'James';
	<br/>
	student_rec.dob := TO_DATE('01-DEC-1994', 'DD-MON-YYYY');	
	<br/>
	INSERT INTO STUDENT VALUES(student_row.snum, student_row.name, student_row.dob);</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Data types</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Some of the predefined <strong class="red">data types</strong> in PL/SQL
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">INTEGER, DECIMAL, NUMBER, CHAR, DATE, VARCHAR, VARCHAR2, LONG,
BOOLEAN, ROWID, EXCEPTION</pre>
	  </ul>
	</li>
       <li>Sample <strong class="red">implicit type declarations</strong>
	 <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">DECLARE
  student_no  STUDENT.snum%TYPE;
  student_name STUDENT.name%TYPE;</pre>
 <pre class="prettyprint" data-lang="PL/SQL">  student_row STUDENT%ROWTYPE;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">BEGIN
  student_no := 1234567;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">  SELECT name FROM STUDENT INTO student_name WHERE snum = student_no;</pre>
 <pre class="prettyprint" data-lang="PL/SQL">  student_row.snum := 1234567;
  student_row.name := 'James';
  student_rec.dob := TO_DATE('01-DEC-1994', 'DD-MON-YYYY');	    
  INSERT INTO STUDENT VALUES(student_row.snum, student_row.name, student_row.dob);</pre>
          </ul>
        </li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 20 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a class="red" href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 21 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>PL/SQL has the follwoing operators.</p>
	<br/>
	<p>Arithmetic operators:</p>
	<br/>
	<p>+, -, *, /, **</p>
	<br/>
	<p>An operator ** means "to power" for example 2 to power 3 is denoted as 2**3.</p>
	<br/>
	<p>Relational operators:</p>
	<br/>
	<p><, >, >=, <=, =, !=, <>, ~=</p>
	<br/>
	<p>The operators !=, <>, ~= mean the same "not equal" operator.</p>
	<br/>
	<p>Comparison operators:</p>
	<br/>
	<p>LIKE, BETWEEN, IN, IS NULL, =, !=, <>, ~=</p>
	<br/>
	<p>Comparison operators are the same as in SQL.</p>
	<br/>
	<p>Boolean operators:</p>
	<br/>
	<p>AND, OR, NOT</p>
	<br/>
	<p>Boolean operators are the same as in SQL</p>
	<br/>
	<p>String operator</p>
	<br/>
	<p>||</p>
	<br/>
	<p>A symbol || (double vertical bar) means concatenation of strings (the same as in SQL).</p>
	<br/>
	<p>Operator precedence</p>
	<br/>
	<p>(**),(unary +,-),(*,/),(+,-,||),(comparison),(NOT),(AND),(OR)</p>
	<br/>
	<p>Operator precedence in all cases where the round brackets do not uniquely determine an order of the computations is given above. Still is is recommended to always use round bracket to determine an order of the computations.</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Operators</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Arithmetic operators
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">+, -, *, /, **</pre>
	  </ul>
	</li>
	<li>Relational operators
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL"><, >, >=, <=, =, !=, <>, ~=</pre>
	  </ul>
       </li>
	<li>Comparison operators
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">LIKE, BETWEEN, IN, IS NULL, =, !=, <>, ~=</pre>
	  </ul>
       </li>       
        <li>Boolean operators
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">AND, OR, NOT</pre>
	  </ul>
	</li>
        <li>String operator
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">||</pre>
	  </ul>
	</li>	
        <li>Operator precedence
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">(**),(unary +,-),(*,/),(+,-,||),(comparison),(NOT),(AND),(OR)</pre>
	  </ul>
	</li>       	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 22 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a class="red" href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 23 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of conditional control statements is the following.</p>
	<br/>
	<p>IF-THEN-ELSE-END IF statement has the same semantics as the same statement in all procedural programming languages. Please note a blank between END and IF components of of END IF keyword.
	<br/><br/>
	IF condition THEN
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	ELSE
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END IF;</p>
	<br/>
	<p>IF-THEN-ELSIF-...-THEN statement has the same semantics as the same statement in all procedural programming languages. Please note a blank between END and IF components in END IF keyword and missing 'E' in ELSIF keyword.
	<br/><br/>
	<p>IF condition THEN
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	ELSIF condition THEN
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	ELSIF condition THEN
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	ELSE
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END IF;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Conditional control statements</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>A <i>birds-eye view</i> of <strong class="red">conditional control statements</strong> is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
IF condition THEN
  statement;
  ...
ELSE
  statement;
  ...
END IF;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
IF condition THEN
statement;
...
ELSIF condition THEN
  statement;
  ...
ELSIF condition THEN
  statement;
  ...
ELSE
  statement;
...
END IF;</pre>
	  </ul>
	</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 24 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of iterative control statements is the following.</p>
	<br/>
	<p>LOOP-END LOOP statement allows for implementation of a theoretically infinite iteration. A condition  IF condition THEN EXIT; inside LOOP-END LOOP statement breaks an iteration and it moves control to the first statement after LOOP-END LOOP statement. Note a blank between END and LOOP symbols in a keyword END LOOP.
	<br/><br/>
	LOOP
	<br/>
	&emsp;statement;
	<br/>
	&emsp; ...
	<br/>
	IF condition THEN EXIT;
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	&emsp;END IF;
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END LOOP;</p>
	<br/>
	<p>FOR-IN statement together with LOOP-END LOOP statement allows for implementation of a limited iteration. An iteration stops after all values in "scope"  are used. Iteration starts from the first value in a "scope" and continues until the last value is used.
	<br/><br/>
	FOR variable IN scope
	<br/>
	LOOP
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END LOOP;</p>
	<br/>
	<p>FOR-IN-REVERSE statement together with LOOP-END LOOP statement allows for implementation of a limited iteration. An iteration stops after all values in "scope"  are used. Iteration starts from the last value in a "scope" and continues until the first value is used.
	<br/><br/>
	FOR variable IN REVERSE scope
	<br/>
	LOOP
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END LOOP;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Iterative control statements</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>A <i>birds-eye view</i> of <strong class="red">iterative control statements</strong> is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
LOOP
  statement;
  ...
  IF condition THEN EXIT;
    statement;
    ...
  END IF;
  statement;
  ...
END LOOP;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
 FOR variable IN scope
LOOP
  statement;
  ...
END LOOP;
FOR variable IN REVERSE scope
LOOP
  statement;
  ...
END LOOP;</pre>	    
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 25 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A birds-eye view of iterative control statements is the following</p>
	<br/>
	<p>WHILE statement together with LOOP-END LOOP statement  allows for implementation of "iteration" where an exit condition is always tested at the beginning of an iteration.
	<br/><br/>
	WHILE (condition)
	<br/>
	LOOP
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END LOOP;</p>
	<br/>
	<p>LOOP-END LOOP statement allows for implementation of a theoretically infinite iteration.</p>
	<p>A condition  IF condition THEN EXIT; inside LOOP-END LOOP statement break an iteration and it moves control to the first statement after LOOP-END LOOP statement. 
	<br/><br/>
	LOOP
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	EXIT WHEN condition;
	<br/>
	&emsp;statement;
	<br/>
	&emsp;...
	<br/>
	END LOOP;</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Iterative control statements</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>A <i>birds-eye view</i> of <strong class="red">iterative control statements</strong> is the following
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
WHILE (condition)
LOOP
  statement;	      
  ...
END LOOP;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
LOOP
  statement;	      
  ...
   EXIT WHEN condition;
  statement;	      
  ...
END LOOP;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 26 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a class="red" href="#26">Cursors</a></li>
	<li><a href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 27 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now we returns to an interesting problem "what happens when SELECT statement with INTO clause returns more than one row ?".</p>
	<br/>
	<p>For example in a small piece of PL/SQL code below we attempt to process SELECT statement with WHERE condition selecting all rows in a relational table STUDENT where a value in a column name is equal to Pam. If a relational table STUDENT contains more than one student who has a name Pam then SELECT statement returns more than one row. Then, saving many rows as a value of a variable "student_no" is impossible, processing generates an exception and if it is not handled the processing end s with an error ORA-06503 like in the case below.
	<br/><br>
	DECLARE
	<br/>
	&emsp;student_no STUDENT.snum%TYPE;
	<br/>
	BEGIN
	<br/>
	&emsp;SELECT snum
	<br/>
	&emsp;INTO student_no
	<br/>
	&emsp;FROM STUDENT
	<br/>
	&emsp;WHERE name = 'Pam';
	<br/>
	&emsp;...
	<br/>
	ERROR at line 1:
	<br/>
	ORA-06503: PL/SQL: error 0 - Unhandled exception ORA-01427: single-row subquery
	<br/>
	returns more than one row which was raised in a statement ending at line 6</p>
	<br/>
	<p>We got an error because a variable "student_no" cannot be used to store several rows retrieved from a relational table. A solution is to process the rows in a row by row mode. A cursor is a syntactical structure that allows for processing the rows retrieved from the relational tables in a row by row mode</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Cursors</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>What happens when <strong class="blue prettyprint">SELECT</strong> statement returns more than one row ?
	<ul class="build">
	  <pre class="prettyprint" data-lang="PL/SQL">
DECLARE
  student_no STUDENT.snum%TYPE;
BEGIN
  SELECT snum
  INTO student_no
  FROM STUDENT
  WHERE name = 'Pam';
   ...</pre>
<pre class="prettyprint" data-lang="PL/SQL">
ERROR at line 1:
ORA-06503: PL/SQL: error 0 - Unhandled exception ORA-01427: single-row subquery
returns more than one row which was raised in a statement ending at line 6</pre>
	  </ul>
	</li>
	<li>A variable <strong class="blue prettyprint">student_no</strong> cannot be used to store several rows retrieved from a relational table</li>
	<li>A solution is to process the rows in a <i class="blue">row by row </i> mode</li>
	<li>A <strong class="red">cursor</strong> is a construction that allows for processing the rows retrieved from the relational tables in a <i class="blue">row by row</i> mode</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 28 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>There are two way how cursors can be created and used to process a relational table in row-by-row mode. In the first one a cursor is declared and processed  explicitly. We start from explicit declaration and processing of a cursor. </p>
	<br/>
	<p>We plan to read the result of SELECT statement in row-by-row mode. It means that when we read a single row it must be stored in PL/SQL variable. In our case we plan to read student numbers, so a variable of the same type as a column "snum" in a relational table "STUDENT" will do.</p>
	<p>DECLARE</p>
	<p>student_no STUDENT.snum%TYPE;</p>
        <br/>
	<p>Declaration of a cursor binds a name of a cursor "Q" with SELECT statement.</p>
	<p>CURSOR Q IS</p>
	<p>SELECT snum</p>
	<p>FROM STUDENT</p>
	<p>WHERE name = 'Pam';</p>
	<br/>
	<p>Processing of a cursor in explicit way is performed in the same was as processing of a file of records. A cursor is opened with OPEN Q; SELECT statement associated with a cursor is processed when a cursor is opened and the results from SELECT are saved in so called cursor area or cursor buffer.</p>
	<p>BEGIN</p>
	<p>OPEN Q;</p>
	<br/>
	<p>Then, we iterate over the rows saved in a cursor area. LOOP-END LOOP statement is a convenient way to implement an iteration. In each iteration we fetch a row from a cursor area with FETCH statement and we save the fetched result into PL/SQL variable "student_no" declared earlier.</p>
	<p>LOOP</p>
	<p>FETCH Q INTO student_no;</p>
	<br/>
	<p>It may happen that we reached the end of cursor area and FETCH returned nothing. We detect such case by testing a cursor attribute NOTFOUND in IF statement below. If the next row cannot be read from a cursor are then NOTFOUND attribute of a cursor Q is set to true and EXIT statement takes us out of LOOP statement.</p>
	<p>IF Q%NOTFOUND THEN</p>
	<p>EXIT;</p>
	<p>END IF;</p>
	<br/>
	<p>Otherwise, we insert a student number taken from a cursor area into a relational table PAM.</p>
	<p>INSERT INTO PAM VALUES(student_no)</p>
	<br/>
	<p>And we return to the beginning of LOOP statements fetching the next row from a cursor ares.</p>
	<p>END LOOP;</p>
	<br/>
	<p>When processing of a cursor is completed, a cursor is closed with CLOSE statement.</p>
	<p>CLOSE Q;</p>
	<p>COMMIT;</p>
	<p>END;</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Cursors</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Explicit</strong> declaration and processing of a <strong class="red">cursor</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
DECLARE
  student_no STUDENT.snum%TYPE;</pre>
<pre class="prettyprint" data-lang="PL/SQL">
  CURSOR Q IS
    SELECT snum
    FROM STUDENT
    WHERE name = 'Pam';</pre>
<pre class="prettyprint" data-lang="PL/SQL">
BEGIN
  OPEN Q;
  LOOP
    FETCH Q INTO student_no;
    IF Q%NOTFOUND THEN
      EXIT;
    END IF;
    INSERT INTO PAM VALUES(student_no)
  END LOOP;
  CLOSE Q;
  COMMIT;
END;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 29 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Implicit cursor processing is much easier. An example below implements the same functionality as an example listed on the previous slide.</p>
	<br/>
	<p>Implicitly declaration and processing of a cursor is a lot easier than explicit  processing, please see a fragment of PL/SQL code below.</p>
	<br/>
	<p>Note that in the example below:</p>
	<p>- a cursor is implicitly declared</p>
	<p>- a cursor is implicitly opened</p>
	<br/>
	<p>BEGIN</p>
	<p>- a row is implicitly fetched</p>
	<br/>
	<p>FOR Q_row IN (SELECT snum FROM STUDENT WHERE name = 'Pam')</p>
	<p>LOOP</p>
	<br/>
	<p>- end of cursor area condition is implicitly checked</p>
	<br/>
	<p>INSERT INTO PAM VALUES(Q_row.snum);</p>
	<p>END LOOP;</p>
	<br/>
	<p>- a cursor is implicitly closed</p>
	<br/>
	<p>COMMIT;</p>
	<br/>
	<p>END;</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Implicit cursor processing</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Implicitly</strong> declaration and processing of a <strong class="red">cursor</strong>
	  <ul>
	    <pre class="prettyprint" data-lang="PL/SQL">
BEGIN
  FOR Q_row IN (SELECT snum
               FROM STUDENT
               WHERE name = 'Pam')
  LOOP
    INSERT INTO PAM VALUES(Q_row.snum);
  END LOOP;
  COMMIT;
END;</pre>
	 </ul>
	</li>
	<li>A <strong class="red">cursor</strong> is <strong class="red">implicitly</strong> declared</li>
	<li>A <strong class="red">cursor</strong> is <strong class="red">implicitly</strong> opened</li>
	<li>A row is <strong class="red">implicitly</strong> fetched</li>
	<li>End of table condition is <strong class="red">implicitly</strong> checked</li>
	<li>A <strong class="red">cursor</strong> is <strong class="red">implicitly</strong> closed</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 30 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A state of a cursor during processing is determined by the cursor attributes.</p>
	<br/>
	<p>A cursor attribute %NOTFOUND evaluates to true if the last FETCH failed because no more rows were available</p>
	<br/>
	<p>A cursor attribute %FOUND evaluates to true if the last FETCH succeeded</p>
	<br/>
	<p>A cursor attribute %ROWCOUNT evaluates to the total number of rows FETCHed so far</p>
	<br/>
	<p>A cursor attribute %ISOPEN evaluates to true if a cursor is opened</p>
	<br/>
	<p>You can find more information about cursor attributes in PL/SQL User's Guide and Reference (a link is given in the slide)</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Cursor attributes</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">cursor attribute</strong> determines a state of a <strong class="red">cursor</strong></li>
        <li>A </strong>cursor attribute</strong> <strong class="blue prettyprint">%NOTFOUND</strong> evaluates to true if the last <strong class="blue prettyprint">FETCH</strong> failed because no more rows were available</li>
        <li>A <strong class="red">cursor attribute</strong> <strong class="blue prettyprint">%FOUND</strong> evaluates to true if the last <strong class="blue prettyprint">FETCH</strong> succeeded</li>
        <li>A </strong>cursor attribute</strong> <strong class="blue prettyprint">%ROWCOUNT</strong> evaluates to the total number of rows <strong class="blue prettyprint">FETCH</strong>ed so far</li>
        <li>A <strong class="red">cursor attribute</strong> <strong class="blue prettyprint">%ISOPEN</strong> evaluates to true if a <strong class="red">cursor</strong> is opened</li>
	<li>You can find more information about <strong class="red">cursor attributes</strong> <a href="https://protect-au.mimecast.com/s/eJ6DCxngkkSZDNlvCR5RXx?domain=docs.oracle.com">here</a> </li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 31 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A sample testing of cursor attributes. The same example of explicit cursor processing is used to demonstrate application of cursor attributes.</p>
	<br/>
	<p>DECLARE</p>
	<p>&emsp;student_no STUDENT.snum%TYPE;</p>
	<p>&emsp;CURSOR Q IS</p>
	<p>&emsp;&emsp;SELECT snum FROM STUDENT WHERE name = ‚ÄôPam‚Äô;</p>
	<p>BEGIN</p>
	<p>&emsp;OPEN Q;</p>
	<p>&emsp;LOOP</p>
	<p>&emsp;&emsp;FETCH Q INTO student_no;</p>
	<br/>
	<p>First, after fetch NOTFOUND attribute is tested to check if fetch got a new row from a cursor area.</p>
	<br/>
	<p>&emsp;&emsp;IF Q%NOTFOUND THEN</p>
	<p>&emsp;&emsp;EXIT</p>
	<p>&emsp;END IF;</p>
	<p>&emsp;INSERT INTO PAM VALUES(student_no);</p>
	<p>END LOOP;</p>
	<br/>
	<p>When cursor processing is completed an attribute ROWCOUNT is tested if more then one rows was processed. If SELECT statement associated with a cursor returns no rows then the first fetch fails and processing of cursor area is completed with a value of an  attribute ROWCOUNT equal to zero. Testing of an attribute ROWCOUNT detects a case when SELECT statements returns no rows.</p>
	<br/>
	<p>&emsp;IF Q%ROWCOUNT = 0 THEN</p>
	<p>&emsp;&emsp;INSERT INTO MESSAGES VALUES (‚ÄôNO ROWS PROCESSED‚Äô);</p>
	<p>&emsp;END IF;</p>
	<p>&emsp;CLOSE Q;</p>
	<p>&emsp;COMMIT;</p>
	<p>END;</p>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Cursor attributes</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>A sample testing of <strong class="red">cursor attributes</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
DECLARE
  student_no STUDENT.snum%TYPE;
  CURSOR Q IS
    SELECT snum FROM STUDENT WHERE name = ‚ÄôPam‚Äô;
BEGIN
  OPEN Q;
  LOOP
    FETCH Q INTO student_no;
    IF Q%NOTFOUND THEN
      EXIT
    END IF;
    INSERT INTO PAM VALUES(student_no);
  END LOOP;</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
  IF Q%ROWCOUNT = 0 THEN
    INSERT INTO MESSAGES VALUES (‚ÄôNO ROWS PROCESSED‚Äô);
  END IF;
  CLOSE Q;
  COMMIT;
END;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 32 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">PL/SQL</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">PL/SQL ? What is it ? Why do we need it ?</a></strong></li>
        <li><a href="#4">Program structure</a></strong></li>
	<li><a href="#7">Declarative, Executable, Exception components</a></li>	
	<li><a href="#11">Structures of anonymous blocks, procedures, and functions</a></li>
	<li><a href="#18">Data types, implicit type declarations</a></li>
	<li><a href="#20">Operators</a></li>
	<li><a href="#22">Control statements</a></li>
	<li><a href="#26">Cursors</a></li>
	<li><a class="red" href="#32">Exceptions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 33 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>An exception is an internally defined or user defined error condition, e.g. divide by zero, no rows selected by SELECT statement with INTO clause, failure of FETCH statement, use of a cursor which has not been opened yet, etc.</p>
	<br/>
	<p>DECLARE</p>
	<p>&emsp;error_number NUMBER(5);</p>
	<p>&emsp;error_message VARCHAR(200);</p>
	<br/>
	<p>A typical and pretty minimalistic exception handler allows to catch any error condition and to display and record in ERRORS relational table error code (SQLCODE variable) and error message (SQLERRM variable).</p>
	<br/>
	<p>EXCEPTION</p>
	<p>WHEN OTHERS THEN</p>
	<p>&emsp;error_number := SQLCODE;</p>
	<p>&emsp;error_message := SQLERRM;</p>
	<p>&emsp;DBMS_OUTPUT.PUT_LINE(error_number ||'-'|| error_message);</p>
	<p>&emsp;INSERT INTO ERRORS( error_number, error_message);</p>
	<p>&emsp;COMMIT;</p>
	<p>END;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Exceptions</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>An <strong class="red">exception</strong> is an internally defined or user defined error condition, e.g. divide by zero, no rows selected by <strong class="blue prettyprint">SELECT</strong> statement with <strong class="blue prettyprint">INTO</strong> clause, failure of <strong class="blue prettyprint">FETCH</strong> statement, use of a cursor which has not been opened yet, etc.</li>
        <li>A typical <strong class="red">exception</strong> handling
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
DECLARE
  error_number NUMBER(5);
  error_message VARCHAR(200);
  ...
EXCEPTION
  WHEN OTHERS THEN
    error_number := SQLCODE;
    error_message := SQLERRM;
    DBMS_OUTPUT.PUT_LINE(error_number ||'-'|| error_message);
    INSERT INTO ERRORS( error_number, error_message);
    COMMIT;
END;</pre>
	  </ul>
	</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 34 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The present slide shows a typical way of handling empty an answer from SELECT statement.</p>
	<br/>
	<p>Like in one of the earlier examples we would like to find a name of a student whose number is 1234567. It is possible that there is no student with such number. Then INTO clause cannot assign a value to a variable "student_name" and further processing cannot continue.</p>
	<br/>
	<p>DECLARE</p>
	<p>&emsp;student_name STUDENT.name%TYPE;</p>
	<p>BEGIN</p>
	<p>&emsp;SELECT name</p>
	<p>&emsp;INTO student_name</p>
	<p>&emsp;FROM STUDENT</p>
	<p>&emsp;WHERE snum = 1234567;</p>
	<br/>
	<p>If SELECT statement returns no rows then an exception NO_DATA_FOUND is raised and its handle insert a message into a relational table MESSAGES</p>
	<br/>
	<p>EXCEPTION</p>
	<p>WHEN NO_DATA_FOUND THEN</p>
	<p>&emsp;INSERT INTO MESSAGES VALUES( 'Student not found');</p>
	<p>&emsp;COMMIT;</p>
	<p>END;</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Exceptions</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Handling empty an answer from <strong class="blue prettyprint">SELECT</strong> statement
	  <ul class="build">
	    <pre class="prettyprint" data-lang="PL/SQL">
DECLARE
  student_name STUDENT.name%TYPE;
BEGIN
  SELECT name
  INTO student_name
  FROM STUDENT
  WHERE snum = 1234567;
  ...</pre>
	    <pre class="prettyprint" data-lang="PL/SQL">
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    INSERT INTO MESSAGES VALUES( 'Student not found');
    COMMIT;
END;</pre>
	  </ul>
       </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 35 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A list of useful exceptions includes the following cases.</p>
	<br/>
	<p>An exception NO_DATA_FOUND is raised when SELECT statement returns no rows.</p>
	<br/>
	<p>An exception TOO_MANY_ROWS is raised when SELECT statement returns more than one row.</p>
	<br/>
	<p>An exception INVALID_CURSOR is raised when PL/SQL call specifies an invalid cursor,e.g. closing an unopened cursor.</p>
	<br/>
	<p>An exception OTHERS is raised when any other exception, not explicitly named happens.</p>
	<br/>
	<p>You can find a complete list of PL/SQL exceptions in PL/SQL User's Guide and Reference, chapter 7 Handling PL/SQL Errors.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Exceptions</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>An <strong class="red">exception</strong> <strong class="blue prettyprint">NO_DATA_FOUND</strong> is raised when <strong class="blue prettyprint">SELECT</strong> statement returns no rows</li>
	<li>An <strong class="red">exception</strong> <strong class="blue prettyprint">TOO_MANY_ROWS</strong> is raised when <strong class="blue prettyprint">SELECT</strong> statement returns more than one row</li>
	<li>An <strong class="red">exception</strong> <strong class="blue prettyprint">INVALID_CURSOR</strong> is raised when PL/SQL call specifies an invalid cursor,e.g. closing an unopened cursor</li>
	<li>An <strong class="red">exception</strong> <strong class="blue prettyprint">OTHERS</strong> is raised when any other exception, not explicitly named
	  happens</li>
	<li>You can find a complete list of PL/SQL <strong class="red">exception</strong>s <a href="https://protect-au.mimecast.com/s/Y-1wCyojPPiYKV1ohAhAQm?domain=docs.oracle.com">here</a></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 36 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><a href="https://protect-au.mimecast.com/s/3aifCvl122HvqV98CzZRUL?domain=docs.oracle.com">Database PL/SQL Language Reference</a></li>
        <li>T. Connoly, C. Begg, Database Systems, A Practical Approach to Design, Implementation, and Management, Chapter 8 Advanced SQL, Pearson Education Ltd, 2015</li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/W-mJCzvkppUKEV1qcBMbnq?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>

