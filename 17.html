<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/kAAdCZY166hnJ82vSj8Iwp?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
-->
<!DOCTYPE html>
<html>
<head>
  <title>17NoSQL Database Systems</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">
    
<!--
  <slide class="logoslide nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/ISIT311.png"></span>
    </article>
  </slide>
-->
<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>NoSQL Database Systems</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a class="red" href="#3">NoSQL database system ? What is it ?</a></li>
	<li><a href="#5">What is in the name "NoSQL" ?</a></li>
	<li><a href="#7">Why NoSQL database systems ?</a></li>
	<li><a href="#14">Properties of NoSQL database systems</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <aside class="note">
      <section>
    <p>What is No SQL Database System ?</p>
    <br/>
	<p>The main property of NoSQL  database system is a logical view  provided to its users being different from the traditional relational view.</p>
	<br/>
	<p>The first NoSQL database systems were developed in early 2000s in a response to the demands for processing of vast amounts of data produced by increasing Internet usage and mobile geo-location technologies.</p>
	<br/>
	<p>The traditional solutions based on relational database systems were either too expensive, not scalable, or required too much time to process data. In fact it was not the first time when the applications of traditional relational systems for more hierarchically-oriented and graph-oriented domains created significant performance problems. Normalization of the relational tables contributed to fragmentation of complex data structures and in a consequence to large number of joins required when searching and manipulating such structures. In mid 1980s the nested relational model based on a logical view of relational table being in 0NF (not in 1NF) where the values in the rows of relational tables could be another relational tables proved correctness of an idea when applied to Computer Aided Design systems. Application of  the relational data model to a strongly hierarchical domain results with each level of a hierarchy implemented as a separate relational table. Then vertical traversal of hierarchical structures requires joins of many relational tables. On the other hand implementation of the instances of hierarchical structures each one completely kept in contiguous persistent storage eliminates then needs for joins.</p>
	<br/>
	<p>Another database domain where the relational data model contributes to the performance problems is graph oriented domain where the data nodes are linked with directed/undirected edges/limks also described by the values of attributes. Representation of graph data structures as a relational table that describes data nodes and a relational table that describes edges/links contributes to multiply joins of relational tables with themselves when traversing a data graph. Navigation through graph structures is much faster when the edges/links  are implemented as physical addresses in a persistent storage.</p>
    <br/>
	<p>Modern NoSQL database systems "borrowed" some of the solutions from the earlier pre-relational systems and made significant advances in scalability and efficient processing of diverse types of data such as text audio, video, image, and geo-location.</p>
	<br/>
	<p>NoSQL database systems include the following types of database systems categorized by a logical view of data provided: key-value stores, document stores, graph stores, column stores etc.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">NoSQL database system ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">NoSQL database systems</strong> were developed in early 2000s in a response to the demands for processing of vast amounts of data produced by increasing Internet usage and mobile geo-location technologies</li>
	<li>Traditional solutions were either too expensive, not scalable, or required too much time to process data</li>
	<li>Modern <strong class="red">NoSQL database systems</strong> "borrowed" some of the solutions from the earlier systems and made significant advances in scalability and efficient processing of diverse types of data such as text audio, video, image, and geo-location</li>
	<li><strong class="red">NoSQL database systems</strong> include the following types of database systems categorized by a logical view of data provided: <strong class="blue">key-value stores</strong>, <strong class="blue">document stores</strong>, <strong class="blue">graph stores</strong>, <strong class="blue">column stores</strong>, etc</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 04 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#3">NoSQL database system ? What is it ?</a></li>
	<li><a class="red" href="#5">What is in the name "NoSQL" ?</a></li>
	<li><a href="#7">Why NoSQL database systems ?</a></li>
	<li><a href="#14">Properties of NoSQL database systems</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 05 ================================================================================= -->
  <slide>
   <aside class="note">
      <section>
    <p>Why a class of database systems different from the systems based on the relational model of data is called as "NoSQL"?</p>
    <br/>
	<p>A term "NoSQL" has been used for the first time in late 1990 by C. Strozzi as a name of open-source relational database system that did not use SQL as a query language.</p>
	<br/>
	<p>The usage of a name "NoSQL" as it is recognized today has been used by J. Oskarsson in 2009 for the projects experimenting with alternate data storage, like BigTable (Google) and Dynamo (Amazon).</p>
	<br/>
	<p>"NoSQL" database systems do not use SQL (however, sometimes these systems use a query language similar to SQL), run on the clusters of computers and provide different options for consistency and distribution.</p>
	<br/>
	<p>Despite its confrontational nature some people say that "NoSQL" means "Not Only SQL", but ... then it should be written as "NOSQL" and it is not. So maybe C.Strozzi did not like programming in SQL or ... he had a bad database lecturer.</p>
    <br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">What is in the name "NoSQL"?</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>A term <strong class="red">"NoSQL"</strong> has been used for the first time in late 1990 by C. Strozzi as a name of open-source relational database system that did not use SQL as a query language</li>
	<li>The usage of <strong class="red">"NoSQL"</strong> as it is recognized today has been used by J. Oskarsson in 2009 for the projects experimenting with alternate data storage, like BigTable (Google) and Dynamo (Amazon)</li>
	<li><strong class="red">"NoSQL"</strong> database systems do not use SQL, run on the clusters of computers and provide different options for consistency and distribution</li>
	<li>Despite its confrontational nature some people say that  <strong class="red">"NoSQL" means "Not Only SQL"</strong>, but ... then it should be written as <strong class="red">"NOSQL"</strong> and it is not </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 06 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#3">NoSQL database system ? What is it ?</a></li>
	<li><a href="#5">What is in the name "NoSQL" ?</a></li>
	<li><a class="red" href="#7">Why NoSQL database systems ?</a></li>
	<li><a href="#14">Properties of NoSQL database systems</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 07 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>There was a number of reasons for development of the new types of database systems. The relational data model was not "one size that fits all".</p>
    <br/>
	<p>The first reason was a data model. As we explained before, a tabular view of data was not convenient for hierarchical and network database domains.</p>
	<br/>
	<p>The second problem was so called "impedance mismatch".  A tabular view of persistent data was not consistent with a transient view of data in object-oriented programming languages. It was quite inconvenient to incorporate a concept of a relational table and a language like SQL into object-oriented programming languages.</p>
	<br/>
	<p>The third problem was application and integration of database systems. A structure that integrates many applications is more complex than single application requires, for example an index required by one application may cause performance problems for another application. </p>
	<br/>
	<p>The fourth problem was related to hardware. Availability of clusters of small computers could be used to speed up data processing through parallelization. Classical architecture of relational database system was not consistent with the architectures of computer clusters. Relational databases that operate on the shared persistent storage subsystems are not designed to work well on the clusters of small computers.</p>
    <br/>
	<p>The fifth problem was distribution and consistency: ACID based transaction protocols are too strict for distributed transaction (see previous presentation).</p>
	<br/>
	<p>We discuss the details of the problems listed above in the next few slides. </p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Data model</strong>: A <strong class="blue">tabular view</strong> of data is not convenient for <strong class="blue">hierarchical</strong> and <strong class="blue">network</strong> database domains</li> 
        <li><strong class="red">Impedance mismatch problem</strong>: A <strong class="blue">tabular view</strong> of persistent data is not consistent with a transient view of data in <strong class="blue">object-oriented programming languages</strong></li>
        <li><strong class="red">Application and integration of database systems</strong>: A structure that integrates many applications is more complex than single application requires, for example an index required by one application may cause performance problems for another application</li>
        <li><strong class="red">Clusters of small computers</strong>: Relational databases that operate on the shared persistent storage subsystems are not designed to work well on the clusters of small computers</li> 
         <li><strong class="red">Distribution and consistency</strong>:<strong class="blue"> ACID</strong> based transaction protocols are too strict for distributed transaction (see previous presentation)</li> 
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 08 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>A problem related to relational data model. A tabular view of data is not convenient for hierarchical and network database domains.</p>
    <br/>
	<p>Consider a conceptual schema of a sample database domain where customers submit orders and orders consist of lines.  A logical design, i.e. a transformation of a conceptual schema into the relational schemas provides three relational tables: CUSTOMER, ORDERS, and LINE.</p>
	<br/>
	<p>Now, consider a query where we would like to find total amount of money spent by each customer. Such requires join of all three relational tables because an attribute "cnumber" from CUSTOMER table must be used for grouping and the attributes "price" and "total" must be used for aggregation of money spent. Join of there relational tables when implemented with a hash join algorithm requires two reads and one write of each table from various locations in a persistent storage. And then one more read is required to process an aggregation. If data is stored in a hierarchical structure, some sort of n-ary tree then  all information about a customer, all its orders and the lines in each order would be stored in one contiguous piece of persistent storage. It eliminates the needs for two joins of three relational tables.</p>
	<br/>
	<p>In very hierarchical database domains a logical design due to normalization of relational tables contribute to fragmentation of persistent storage. Then such fragmentation must be "reversed" when processing join operations.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Data model</strong>: A <strong class="blue">tabular view</strong> of data is not convenient for <strong class="blue">hierarchical</strong> and <strong class="blue">network</strong> database domains</li> 
        <p style="text-align:center;"><img src="images/slide-08-1.png" width="650" alt="Association class" title="Multivalued attribute"></p>	 
	<li>Logical design provides the following relational schemas:
	  <ul class="build">
<pre class="prettyprint" data-lang="Relational schemas">
CUSTOMER(cnumber, first-name, last-name) 
PRIMARY KEY = (cnumber)

ORDERS(onumber, odate, cnumber) PRIMARY KEY = (onumber)
FOREIGN KEY = (cnumber) REFERENCES CUSTOMER(cnumber)

LINE(onumber, lnumber, item, price, total)
PRIMARY KEY = (onumber, lnumber)
FOREIGN KEY = (onumber) REFERENCES ORDERS(onumber)</pre>
          </ul>
	</li>
	<li><strong class="red">A query, that finds total amount of money spent by each customer requires join of three relational tables</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 09================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>A problem related to "impedance mismatch". A tabular view of data is not consistent with a view of data in object-oriented programming languages.</p>
    <br/>
	<p>In this case, consider the relational tables</p>
	<p>DOCUMENT(title, class, edate)</p>
	<p>and</p>
	<p>ACCESS(user, class).</p>
	<p>A relational table DOCUMENT contains titles (title), edition dates (edate) and clearance classes (class) of certain documents. A relational table ACCESS contains information about users (user) and their access classes (class). To be able to access a document an access class of a user must be equal to a clearance class of a document.</p>
	<br/>
	<p>Now, consider a query: find all documents (titles) available to a given user (user). Such query  can be implemented as the following SELECT statement.</p>
	<p>SELECT title</p>
	<p>FROM DOCUMENT JOIN ACCESS</p>
	<p>ON DOCUMENT.class = ACCESS.class</p>
	<p>WHERE user = ... ;</p>
	<br/>
	<p>In such a case SQL query optimizer is able to pick an appropriate algorithm for implementation of join operation.  Assume, that a query optimizer pick a hash join algorithm.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Impedance mismatch problem</strong>: A <strong class="blue">tabular view</strong> of persistent data is not consistent with a transient view of data in <strong class="blue">object-oriented programming languages</strong></li>
	<li>Consider the relational tables
	  <ul class="build">
	    <pre class="prettyprint" data-lang="DOCUMENT schema of relational table">

DOCUMENT(title, class, edate)</pre>
	    <pre class="prettyprint" data-lang="ACCESS schema of relational table">

ACCESS(user,class)</pre>
	  </ul>
	</li>
	<li>A query <strong class="blue">Find all documents available to a given user</strong> is implemented as the following <strong class="blue prettyprint28">SELECT</strong> statement
	  <ul class="build">
	    <pre class="greeen prettyprint" data-lang="SELECT statement">
SELECT title
FROM DOCUMENT JOIN ACCESS
              ON DOCUMENT.class = ACCESS.class
WHERE user = ...;</pre>
	  </ul>
	</li>
	<li>SQL query optimizer is able to pick an appropriate algorithm for implementation of <strong class="indianred prettyprint28">join</strong> operation</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 10 ================================================================================= -->
    <slide>
	 <aside class="note">
      <section>
    <p>Now, assume that the same application must be implemented in object-oriented programming languages. Object-oriented programming language forces encapsulation of object classes and accessing instances of objects one at a time. So, instead of the relational tables DOCUMENT and ACCESS an object-oriented programmer can see the following classes of objects.</p>
    <br/>
	<p>class Document{ String title; String className; Date edate )</p>
	<p>and</p>
	<p>class Access( String user, String className)</p>
	<br/>
	<p>Then, a query "find all documents available to a given user" is implemented as</p>
    <br/>
	<p>Encapsulation of objects classes forces one object at a time technique of object processing</p>
	<p>for(a in Access)</p>
	<p>for( d in Document)</p>
	<p>if a.user = ... and d.className = a.className then</p>
	<p>out(d.title);</p>
	<br/>
	<p>It is because encapsulation of objects classes forces one object at a time technique of object processing.</p>
	<br/>
	<p>Now, mapping of the implementation give above into a host language of a database system and SQL creates two nested loops using cursors to access the relational tables. Hence, processing is performed by reading a relational table DOCUMENT as many time as many rows are included in ACCESS table. It will take much more time that processing hash based join.</p>
	<br/>
      </section>
    </aside>        
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>    
    <article>
      <ul class="build">
	<li><strong class="blue">Object-oriented programming</strong> forces <strong class="red">encapsulation of object classes</strong></li>
	<li><strong class="red">Encapsulation of objects classes</strong> forces <strong class="blue">one object at a time </strong> technique of object processing
	<ul class="build">
	  <pre class="prettyprint" data-lang="Document class">

class Document{ String title;
                String className;
                Date edate )</pre>
	  <pre class="prettyprint" data-lang="Access class">	  
class Access( String user,
              String className)</pre>
	</ul>
</li>
	      <li>A query <strong class="indianred prettyprint28">find all documents available to a user</strong> is implemented as
		<ul class="build">
		  <pre class="prettyprint" data-lang="Object oriented implementation of a query">

for(a in Access)
      for( d in Document)
             if a.user = ... and d.className = a.className then
                 out(d.title);</pre>
		</ul>
		</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 11 ================================================================================= -->
  <slide>
   <aside class="note">
      <section>
    <p>A source of performance problems is such that in object-oriented view, join is performed by an application and not by a database server. A join algorithm typically used by an object-oriented programmer is a simple naive nested loop join. It is the worst implementation of join operation when the relational tables are large.</p>
    <br/>
	<p>In this case, one object at a time technique of object processing forces nested loop implementation of join operation.</p>
	<br/>
	<p>Additionally, when object-oriented application is processed remotely from a database systems the relational tables must be transmitted to a remote site over a network. it contributes to additional data transmission related delays.</p>
	<br/>
	<p>To implement such application efficiently, database application programmers should directly access a bulk object (e.g. a collection of the documents) instead of forming the member objects individually and grouping them into a bulk object inside an application code. Additionally, a query must be stored at and it must be processed by a database server to reduce data transmission costs.</p>
	<br/>
      </section>
    </aside>        
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>    
    <article>
      <ul class="build">
	<li>In <strong class="blue">object-oriented view</strong>, <strong class="indianred prettyprint28">join</strong> is performed by an application and not by a database server</li>
        <li><strong class="blue">One object at a time</strong> technique of object processing forces <strong class="red">nested loop</strong> implementation of <strong class="indianred prettyprint28">join</strong> operation</li>
	<li>When <strong class="blue">object-oriented application</strong> is processed remotely from a database systems the relational tables must be <strong class="red">transmitted to a remote site</strong></li>
	<li>Database application programmers should directly access a bulk object (e.g. a collection of the documents) instead of forming the member objects individually and grouping them into a bulk object inside an application code</li>
	<li>A query must be <strong class="red">stored at</strong> and it must be <strong class="red">processed by</strong> a <strong class="blue">database server</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 12 ================================================================================= -->
 <slide>
  <aside class="note">
      <section>
    <p>The next problem is related to availability of cheap clusters of small computers and very fast growing amounts of data.</p>
    <br/>
	<p>Consider a situation where certain amount of data can be efficiently processed by a computer located close to a centre of coordinates in a picture given on the present slide. Now, assume that the amounts of data significantly increased and the the system available just now is not able to process all data in a reasonable period of time. Then two options are possible.</p>
	<br/>
	<p>We can buy a bigger and faster computer. A bigger an faster computer is visualized on the present slide at the end of a vertical coordinate. Such solution will work for some time. But if the amounts of collected data are still growing then it may happen that our new computer is not good enough again. Additionally there is a problem what to do with the old computer ? So a strategy of buying a new computer does not scale-up well when the amounts of data continuously increase.</p>
	<br/>
	<p>The second option is such that we buy a cluster of smaller inexpensive computers. These are pretty simply systems connected with a very fast local network into something what is commonly called as a "cluster". A cluster of computers provides improvements in performance of data processing through parallelization of data processing operations. The large data containers a re partitioned into the smaller ones and each one of the smaller data containers is located at a single system in a cluster. Then an application that processes a large a data container is distributed to each system in a cluster and simultaneously (in parallel) process smaller data containers. Then the results from individual systems in a cluster are integrated into the final answer. It is so called "map-reduce" strategy fro parallelization of data processing. The other method is parallelization is pipelining. Pipelining is still possible on a cluster of computers. We shall return to this idea later on.</p>
	<br/>
	<p>A strategy of using a computer cluster scales up very well. If a cluster is not bale to process the given amounts of data fast enaough then we buy and we append more systems to a cluster. Additionally there is no problem what to do with the old computers.</p>
    <br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Why NoSQL database systems ?</h2>
    </hgroup>    
    <article>
      <ul class="build">
        <li><strong class="red">Clusters of small computers</strong>: Relational databases that operate on the shared persistent storage subsystems are not designed to work well on the clusters of small computers</li>
		<ul class="build">
		<p style="text-align:center;"><img src="images/slide-12.png" width="800" alt="ORM" title="ORM"></p>
		</ul>
		</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
    </article>
  </slide>
<!-- slide 13 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#3">NoSQL database system ? What is it ?</a></li>
	<li><a href="#5">What is in the name "NoSQL" ?</a></li>
	<li><a href="#7">Why NoSQL database systems ?</a></li>
	<li><a class="red" href="#14">Properties of NoSQL database systems</a>
	  <ul>
            <li><strong class="red">Semistructured, unstructured data, and schemaless data model</strong></li>
            <li>Specialized distribution models</li>
			<li>Weak consistency</li>
            <li>Relaxing durability</li>
			<li>Versioning</li>
          </ul>
        </li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 14 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>What are the properties characterizing a class of NoSQL database systems ?</p>
    <br/>
	<p>A NoSQL system must:</p>
	<p>- provide a logical view of semistructured, unstructured data, and schemaless data model,</p>
	<p>- provide specialized distribution models,</p>
	<p>- must implement weak consistency of replicated data</p>
	<p>- must to some extent relax a principle of durability</p>
	<p>- must incorporate versioning to data modeling.</p>
	<br/>
	<p>What is a semistructured data ?</p>
	<p>Semistructured data is a form of structured data that does not conform to the formal structure of data models associated with relational databases or other forms of data tables, Semistructured data contains tags or other markers to separate semantic elements and enforce hierarchies of records and fields within the data.</p>
    <br/>
	<p>What is a schema less data model ?</p>
	<p>Schemaless data model means that no particular data structure is used to store data in a database. Schemaless database does not require consistency with a rigid schema, e.g. database schema, relational schema, data type, table, etc. Schemaless database does not enforce data type limitations on individual values Schemaless database can store structured and semistructured data</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Semistructured, schemaless data model</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Semistructured data</strong> is a form of structured data that does not conform to the formal structure of data models associated with relational databases or other forms of data tables</li>
	<li><strong class="red">Semistructured data</strong> contains tags or other markers to separate semantic elements and enforce hierarchies of records and fields within the data</li>
        <li><strong class="red">Schemaless data model</strong> means that no particular data structure is used to store data in a database</li>
	<li><strong class="red">Schemaless database</strong> does not require consistency with a rigid schema, e.g. database schema, relational schema, data type, table, etc.</li>
	<li><strong class="red">Schemaless database</strong> does not enforce data type limitations on individual values</li>
	<li><strong class="red">Schemaless database</strong> can <strong class="blue">store structured</strong> and <strong class="red">semistructured data</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 15 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
	  <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li>NoSQL database system ? What is it ?</li>
        <li>What is in the name ?</li>
		<li>Why No SQL database systems ?</li>
        <li><strong class="red">Properties of NoSQL database systems</strong>
          <ul>
            <li>Semistructured, unstructured data, and schemaless data model</li>
            <li><strong class="red">Specialized distribution models</strong></li>
			<li>Weak consistency</li>
            <li>Relaxing durability</li>
			<li>Versioning</li>
          </ul>
        </li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 16 ================================================================================= -->
 <slide>
  <aside class="note">
      <section>
    <p>What are the specialized distribution models ?</p>
    <br/>
	<p>In a traditional approach when a database system consists of a single server located on a single computer there no distribution at all.</p>
	<br/>
	<p>A process of partitioning of large data sets and distributing partitions over the system in a cluster of computers is called "sharding" (SHARed nothING).</p>
	<p>Sharding is used to support horizontal scalability. in sharding we put different parts of data onto different servers (shards). To enforce a higher level of reliability different parts of data must be replicated on different servers.</p>
	<br/>
	<p>Data distribution leads to two data replication modes: master-slave replication, peer-to-peer replication.</p>
    <br/>
	<p>In master-slave replication data is replicated across multiple nodes (computers) in a cluster and one node is designated as master node. The others nodes are designated as slaves. In master-slave replication all updates are made to the master node and later on propagated to slave nodes.</p>
	<br/>
	<p>In peer-to-peer replication data is replicated across multiple nodes.  All replicas on all nodes have the same weight. There is no master mode. The nodes communicate their writes to other nodes. All nodes are allowed to read and write all data.</p>
	<br/>
	<p>Combined sharding and replication leads to using both master-slave replication and sharding.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Specialized distribution models</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Single server:</strong> means no distribution at all</li>
        <li><strong class="red">Sharding:</strong> to support horizontal scalability we put different parts of data onto different servers (<strong class="red">shards</strong>)</li>
        <li><strong class="red">Data distribution</strong> leads to two <strong class="red">data replication modes</strong>:
	  <ul class="build">
            <li><strong class="red">Master-slave replication:</strong> data is replicated across multiple nodes and one node is designated as master node, the others are slaves; all updates are made to the master and later on propagated to slaves</li>
            <li><strong class="red">Peer-to-peer replication:</strong> data is replicated across multiple nodes; all replicas have the same weight, no master mode; nodes communicate their writes; all nodes read and write all data</li>
          </ul>
	</li>
	<li><strong class="red">Combining sharding and replication:</strong> use both master-slave replication and sharding</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 17 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
	  <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li>NoSQL database system ? What is it ?</li>
        <li>What is in the name ?</li>
		<li>Why No SQL database systems ?</li>
        <li><strong class="red">Properties of NoSQL database systems</strong>
          <ul>
            <li>Semistructured, unstructured data, and schemaless data model</li>            
	    <li>Specialized distribution models</li>
            <li><strong class="red">Weak consistency</strong></li>
			<li>Relaxing durability</li>
			<li>Versioning</li>
          </ul>
        </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 18 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>What does it mean "weak consistency" ?</p>
    <br/>
	<p>A typical read consistency principle where update is performed over two or more data items blocks access to all data items affected by the update, for example in 2PL protocol.</p>
	<br/>
	<p>Weak consistency means that NoSQL database systems relax the strict transactional consistency to some extent.</p>
	<br/>
	<p>In a new model of consistency, data items can be left inconsistent over certain period of time called as "inconsistency window".</p>
	<br/>
	<p>A concept of "eventual consistency" is used to enforce replication consistency over distributed and replicated data items.</p>
    <br/>
	<p>"Eventual consistency" means that the copies of data items can be inconsistent in inconsistency window and all copies will have the same value later on.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Weak consistency</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>A typical <strong class="red">read consistency </strong>principle where update is performed over two or more data items blocks access to all data items affected by the update, for example in <strong class="blue">2PL</strong> protocol</li>
        <li>NoSQL database systems relax the <strong class="red">strict transactional consistency</strong> to some extent</li>
	<li>In a new model of consistency, data items can be left inconsistent over certain period of time called as <strong class="red">inconsistency window</strong></li>
        <li>A concept of <strong class="red">eventual consistency</strong> is used to enforce <strong class="red">replication consistency</strong> over distributed and replicated data items</li>
        <li><strong class="red">Eventual consistency </strong>means that the copies of data items can be inconsistent in <strong class="red">inconsistency window</strong> and all copies will have the same value later on</li>
        </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 19 ================================================================================= -->
 <slide>
  <aside class="note">
      <section>
    <p>Different database domains have different tolerances for inconsistencies and we have to take this tolerance into account as make our decisions. For example banking domains do not tolerate any inconsistencies. A domain where statistical values play the most important role some inconsistencies are acceptable. Business domain, can compensate inconsistencies with selling policies. For example, inconsistency of selling one item to two customers can be compensated with attractive sale offerings to a customer who missed an item.</p>
    <br/>
	<p>Even in traditional relational database systems it is possible to relax consistency from the highest isolation level (serializable) to the lowest levels (read-committed) to get better performance.</p>
	<br/>
	<p>However, Consistency, Availability and Partition theorem (CAP theorem) limits of co-occurrence of consistency, availability and partition to two at a time.</p>
	<p>CAP theorem says that out of three properties of Consistency, Availability, and Partition tolerance you can get only two.</p>
	<br/>
	<p>Consistency means that a state of a database satisfies the given consistency constraints at any moment in time.</p>
    <br/>
	<p>Availability means that if you can talk to a node in a cluster (you have a network connection) then it can read and write data.</p>
	<br/>
	<p>Partition means that a cluster can survive communication breakages that separate the cluster into multiple partitions unable to communicate with each other (split brain).</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Weak consistency</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Different domains have different <strong class="red">tolerances for inconsistencies</strong> and we have to take this tolerance into account as make our decisions</li>
	<li>Even in traditional relational database systems it is possible to relax consistency from the highest isolation level (<strong class="blue">serializable</strong>) to the lowest levels (<strong class="blue">read-committed</strong>) to get better performance</li>
        <li><strong class="red">CAP theorem</strong>: Out of three properties of <strong class="red">Consistency</strong>,
<strong class="red">Availability</strong>, and <strong class="red">Partition tolerance</strong> you can get only two</li>
        <li><strong class="red">Consistency</strong>: A state of a database satisfies the given consistency constraints at any moment in time</li>
        <li><strong class="red">Availability</strong>: If you can talk to a node in a cluster then it can read and write data</li>
	<li><strong class="red">Partition</strong>: Cluster can survive communication breakages that separate the cluster into multiple partitions unable to communicate with each other (<strong class="blue">split brain</strong>)</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 20 ================================================================================= -->
 <slide>
  <aside class="note">
      <section>
    <p>A single server system is CA because it has Consistency and Availability and not Partition tolerance. It has no Partition tolerance because it is a single server and not a cluster of computers.
  </p>
    <br/>
	<p>If a cluster must be tolerant of network partitions, then we have to trade consistency for availability. It means that if we would like to eliminate problems with disconnections of the systems in a cluster then we have to increase availability through higher replication and it would decrease consistency level because the larger number of replicas of data. On the other hand if we would like to still preserve consistency then availability must drop due the longer protocols keep data consistent.</p>
	<p>If we would like to preserve a high level consistency and availability then we have to give up a high level of partition. It means that we enforce a low level of data replication and a high level access .</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Weak consistency</h2>
    </hgroup>
    <article>
      <ul class="build">

        <li>A single server system is <strong class="red">CA</strong> because it has <strong class="red">Consistency</strong> and <strong class="red">Availability</strong> and not <strong class="red">Partition</strong> tolerance</li>
        <li>If a cluster must be tolerant of network partitions, then we have to trade consistency for availability</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
 </slide>
<!-- slide 21 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
	  <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li>NoSQL database system ? What is it ?</li>
        <li>What is in the name ?</li>
	<li>Why No SQL database systems ?</li>
        <li><strong class="red">Properties of NoSQL database systems</strong>
          <ul>
            <li>Semistructured, unstructured data, and schemaless data model</li>
            <li>Specialized distribution models</li>
	    <li>Weak consistency</li>
            <li><strong class="red">Relaxing durability</strong></li>
	    <li>Versioning</li>
          </ul>
        </li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 22 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>Durability means that if a transaction is committed that all results if its processing that change a state of a database must be permanently recorded in a database. The results of committed transactions cannot be lost.</p>
    <br/>
	<p>If the traditional SQL systems follow ACID properties then NoSQL systems follow BASE properties: Basically Available, Soft state, Eventually consistent.</p>
	<br/>
	<p>Relaxing durability means that we trade of durability for higher performance, for example, apply updates to in-memory representation of a database and periodically flush changes to disk. It means that we create a situation where the results of committed transactions may disappear due to unsafe procedures that favour the performance indicators.</p>
	<br/>
	<p>Another class of durability tradeoffs comes with replicated data, for example, when a node processes and update but fails before that updates is replicated to other nodes.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Relaxing durability</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>If SQL systems follow <strong class="blue">ACID</strong> properties then NoSQL systems follow <strong class="red">BASE</strong> properties: <strong class="red">Basically Available, Soft </strong>state, <strong class="red">Eventually</strong> consistent</li>
        <li><strong class="red">Relaxing durability</strong> means that we trade of durability for higher performance, for example, apply updates to <strong class="blue">in-memory representation of a database</strong> and periodically flush changes to disk</li>
	<li>Another class of <strong class="red">durability tradeoffs</strong> comes with replicated data, for example, when a node processes and update but fails before that updates is replicated to other nodes</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 23 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">NoSQL Database Systems</h2>
	  <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li>NoSQL database system ? What is it ?</li>
        <li>What is in the name ?</li>
		<li>Why No SQL database systems ?</li>
        <li><strong class="red">Properties of NoSQL database systems</strong>
          <ul>
            <li>Semistructured, unstructured data, and schemaless data model</li>
            <li>Specialized distribution models</li>
	    <li>Weak consistency</li>
            <li>Relaxing durability</li>
	    <li><strong class="red">Versioning</strong></li>
          </ul>
        </li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 24 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
    <p>A definition of "version" is the following.</p>
    <br/>
	<p>A version is a particular form of something differing in certain respects from an earlier form or other forms of the same type of thing.</p>
	<br/>
	<p>Versioning in a database systems means that all modifications of data items are stored in a database together with timestamps when such modifications occurred.</p>
	<br/>
	<p>In practice versioning is performed to a predefined depth, i.e. a total number of versions of data item is determined when a data item is created.</p>
	<br/>
	<p>Versioning allows for representation of historical information.</p>
    <br/>
	<p>Numbering of data versions through timestamps allows to track when a data item has changed and if a new version is available allows to determine specifically which version is the most current one.</p>
	<br/>
      </section>
    </aside>    
    <hgroup>
      <h2 class="blue">Versioning</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">version</strong> is a <strong class="blue"> particular form of something differing in certain respects from an earlier form or other forms of the same type of thing</strong></li>
        <li><strong class="red">Versioning</strong> in a database systems means that all modifications of data items are stored in a database together with timestamps when such modifications occurred</li>
	<li>In practice <strong class="red">versioning</strong> is performed to a predefined <strong class="red">depth</strong>, i.e. a total number of versions of data item is determined when a data item is created</li>
	<li><strong class="red">Versioning</strong> allows for representation of historical information</li>
	<li>Numbering of <strong class="red">data versions</strong> through <strong class="red">timestamps</strong> allows to track when a data item  has changed and if a new version is available allows to determine specifically which version is the most current one</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 25 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Harrison G., Next Generation Databases, NoSQL, NewSQL, Big Data, Apress, 2015</li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/WW4WC1WLwwtwVB5gCpcv8Q?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>


</body>
</html>

