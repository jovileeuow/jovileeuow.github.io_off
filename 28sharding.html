<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>28 MongoDB Sharding</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 
<!--
  <slide class="logoslide nobackground">
    <article class="flexbox vcenter">
      <span><img src="images/ISIT311.png"></span>
    </article>
  </slide>
-->
<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>MongoDB Sharding</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
        <li><a class="red" href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Basics</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Sharding</strong> is the process of partitioning a large dataset into smaller and more manageable pieces</li>
        <li>A <strong class="red">shared nothing</strong> architecture is a distributed computing architecture in which each computing node does not share data with other the nodes</li>
	<li>In database systems it is called as <strong class="red">sharding</strong> (<strong class="red">shar</strong>e<strong class="red">d</strong> noth<strong class="red">ing</strong>)</li>
	<li>What to do when:
          <ul class="build">
            <li>large amount of data and greater read/write throughput demands make commodity database servers not sufficient ?</li>
            <li>the database servers are not be able to address enough RAM, or they might not have enough CPU  cores, to process the workload efficiently ?</li>
	    <li>due to large amount of data it is not practical to store and to manage backups on one disk or <strong class="red">RAID</strong> storage (<strong class="red">R</strong>edundant <strong class="red">A</strong>rray of <strong class="red">I</strong>nexpensive <strong class="red">D</strong>isks) ?</li>
          </ul>
        </li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 04 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Basics</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A solution to these problems is to distribute a database and database processing across more than one server</li>
        <li>The method for doing this in Mongo DB  is called <strong class="red">sharding</strong>.</li>
		<li><strong class="red">Sharding</strong> makes a database system complex due to administrative and performance overhead</li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 05 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
        <li><a href="#2">Basics</a></li>
	<li><a class="red" href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 06 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Why sharding ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>There are two main reasons to <strong class="red">shard</strong>:
          <ul class="build">
            <li>storage distribution</li>
            <li> load distribution</li>
          </ul>
        </li>
	<li>If monitoring of storage capacity shows that at certain moment the database applications require more storage than it is available and adding more strage is impossible then <strong class="red">sharding</strong> is the best option</li>
        <li><strong class="red">Mongodb monitoring</strong> means running <strong class="green">db.stats()</strong> and
<strong class="green">db.collection.stats()</strong> in the <strong class="green">mongo</strong> shell to get the statistics about the storage usage of the current database and <strong class="green">collection</strong> within it</li>
	<li><strong class="red">Load</strong> means <strong class="red">CPU and RAM utilization, I/O bandwidth, network transmission</strong> used by the requests from the clients => <strong class="red">response time</strong></li>
	<li>If at certain moment <strong class="red">response time</strong> does not match the client's expectations then it triggers a decision to <strong class="red">shard</strong></li>
        <li>A decision to <strong class="red">shard</strong> depends on network usage, disk usage, CPU usage, and RAM usage</li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 07 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
        <li><a href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a class="red" href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 08 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Architecture</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>In MongoDB a sharded cluster consists of <strong class="red">shards</strong>, <strong class="green">mongos</strong> <strong class="red">routers</strong>, and <strong class="red">config
servers</strong></li>
        <li><strong class="red">Shards </strong>store the application data</li>
	<li><strong class="green">mongos</strong> <strong class="red">routers</strong> or system administrators are connected directly to the shards</li>
	<li>A <strong class="red">shard</strong> is either a single <strong class="green">mongod</strong> <strong class="red">server</strong> or a <strong class="red">replica set</strong> that stores a partition of
the application data</li>
	    <li>Like an <strong class="red">unsharded deployment</strong>, each <strong class="red">shard</strong> can be a single node for <strong class="blue">development</strong>
and <strong class="blue">testing stage</strong></li>
        <li>Each shard should be a <strong class="red">replica set</strong> in <strong class="blue">production</strong> stage because it is able to provide
automatic <strong class="red">replication</strong> and failover mechanisms</li>
	   <li><strong class="red">Shards</strong> are the only places where the application data gets saved in a <strong class="red">sharded
cluster</strong></li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 09 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Architecture</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>It is possible to connect to an individual <strong class="red">shard</strong> as to a single <strong class="red">computing node</strong> or a <strong class="red">replica set</strong>, then it is possible to see only a portion of the total data stored in entire <strong class="red">shard</strong></li>
        <li>Because each <strong class="red">shard</strong> contains only part of entire data it is necessary to route
the operations to the appropriate <strong class="red">shards</strong></li>
        <li><strong class="green">mongos</strong> <strong class="red">routers</strong> cache the cluster <strong class="blue">metadata</strong> and use it to route operations to the correct shard or shards</li>
	<li><strong class="green">mongos</strong> <strong class="red">routers</strong> provide clients with a single point of contact with the cluster</li>
	<li><strong class="green">mongos</strong> provide a view of a <strong class="red">sharded cluster</strong> the same as a view an <strong class="red">unsharded one</strong></li>
	<li>Because <strong class="green">mongos</strong> processes are lightweight and nonpersistent they can be deployed on the same machines as the <strong class="red">application servers</strong></li>
	<li>Then only one network step is required for requests to any given <strong class="red">shard</strong></li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 10 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Architecture</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>As <strong class="green">mongos</strong> processes are non-persistent then an additional process is needed to durably store the <strong class="red">metadata</strong> needed to properly manage the cluster</li>
        <li><strong class="red">Config servers</strong> persistently store <strong class="blue">metadata</strong> about the cluster, including which <strong class="red">shard</strong> has what subset of the data</li>
	<li><strong class="blue">Metadata</strong> includes the global cluster configuration, the locations of each database, collection, and the particular ranges of data in a collection and a change log preserving a history of the migrations of data across <strong class="red">shards</strong></li>
	<li>For example, every time a <strong class="green">mongos</strong> process is started, it fetches a copy of the <strong class="red">metadata</strong> from <strong class="red">config servers</strong> to get a coherent view of the <strong class="red">shard cluster</strong></li>
        <li><strong class="red">Shard cluster</strong> requires several <strong class="red">config servers</strong> not deployed as as a replica set</li>
       <li>Write operations on a <strong class="red">config server</strong> use a two-phase commit protocol to ensure the data consistency across the <strong class="red">config servers</strong></li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 11 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Architecture</h2>
    </hgroup>
    <article>
      <ul>
	<li>In production environment more than one <strong class="red">config server</strong> must be used and all <strong class="red">config servers</strong> must reside on the separate machines to provide redundancy</li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 12 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
         <li><a href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a class="red" href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  13 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Distribution</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>There are four levels of data granularity in MongoDB:
          <ul class="build">
            <li><strong class="red">Document</strong>: the smallest unit of data in MongoDB; a <strong class="red">document</strong> represents a single object in the system (like a row in a relational database)</li>
            <li><strong class="red">Chunk</strong>: a group of documents clustered by the values on a field; a <strong class="red">chunk</strong> is a concept that exists only in sharded setups; a <strong class="red">chunk</strong> is created by the logical grouping of documents based on their values for a key or set of keys, known as a <strong class="red">shard key</strong></li>
            <li><strong class="red">Collection</strong>: a named grouping of documents within a database; a
<strong class="red">collection</strong> allows users to separate a database into logical groupings that make sense for the application</li>
            <li><strong class="red">Database</strong>: a set of collections of documents; a combination of a database name and a collection name is unique throughout the system, and it is commonly referred to as the <strong class="red">namespace</strong></li>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  14 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Distribution</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Data can be distributed in a <strong class="red">sharded cluster</strong> in the following ways:
          <ul class="build">
            <li>at a level of an <strong class="red">entire database</strong> where each database along with all its collections is put on its own shard</li>
            <li>at a level of <strong class="red">partitions</strong> or <strong class="red">chunks</strong> of a collection, where the documents within a collection itself are spread out over multiple shards based on values of a key or set of keys (<strong class="red">shard key</strong>) in the documents</li>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  15 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Database Distribution</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Each database in a sharded cluster is assigned to a different <strong class="red">shard</strong></li>
	<li>A database itself is not sharded</li>
	<li>It is some sort of <strong class="red">manual sharding</strong> (<strong class="red">partitioning</strong>)</strong></li>
        <li>MongoDB has nothing to do with how well data is <strong class="red">partitioned</strong> and it is completely up to a user to decide which database is located into which <strong class="red">shard</strong></li>
        <li>One example of a real application for database distribution is MongoDB as a service</li>
        <li>In such implementation of <strong class="red">sharding</strong> customers can pay for access to a single MongoDB database</li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  16 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Collection Distribution</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The second method is <strong class="red">sharding</strong> an individual collection</li>
	<li>It is an <strong class="red">automatic sharding</strong> in which MongoDB itself makes all the partitioning decisions, without any direct intervention from the applications</li>
	<li>For example, consider the following document:
          <ul class="build">
            <pre class="prettyprint" data-lang="BSON">
{
  "_id": ObjectId("4d6e9b89b600c2c196442c21")
  "filename": "spreadsheet-1",
  "updated_at": ISODate("2011-03-02T19:22:54.845Z"),
  "username": "banks",
  "data": "raw document data"
}</pre>
          </ul>
        </li>
	<li>If all the documents in a collection have this format, and if we choose <strong class="green prettyprint">"_id"</strong> key and the <strong class="green prettyprint">"username"</strong> key as a <strong class="red">shard key</strong> then a pair of values associated with <strong class="green prettyprint">"_id"</strong>
and <strong class="green prettyprint">"name"</strong> in each document is used to determine what chunk the document belongs to</li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  17 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Collection Distribution</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Sharding in MongoDB is <strong class="red">range-based</strong></li>
	<li>It means that each <strong class="red">chunk</strong> represents a range of <strong class="red">shard keys</strong></li>
         <li>To determine what <strong class="red">chunk</strong> a document belongs to, MongoDB extracts the values for a <strong class="red">shard key</strong> and then finds a  <strong class="red">chunk</strong> whose shard
<strong class="red">key range</strong> contains the given <strong class="red">shard key</strong> values</li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 18 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
         <li><a href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a class="red" href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 19 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>A process of setting up a sharded cluster consists of three steps:
          <ul class="build">
            <li>starting the  <strong class="green">mongod</strong>  and  <strong class="green">mongos</strong>  servers through spawning all the individual <strong class="green">mongod</strong>  and  <strong class="green">mongos</strong>  processes that make up the cluster</li>
            <li>configuring the cluster through updating the configuration such that the replica sets are initialized and the shards are added to the cluster and the nodes are be able to communicate with each other</li>
	    <li>sharding collections such that it can be spread across multiple shards</li>
          </ul>
        </li>
	<li>Start <strong class="blue">Terminal</strong> and process the following shell commands to create <strong class="red">config server</strong> (just one)
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mkdir conf1
mkdir conf2</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mongod --configsvr --replSet conf --dbpath conf1 --port 4001</pre>
          </ul>
        </li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 20 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell">mongod --configsvr --replSet conf --dbpath conf2 --port 4002</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="port 4001">mongo -port 4001
rs.initiate()
rs.conf()
rs.add("localhost:4002")
rs.status()
exit</pre>
			<pre class="prettyprint" data-lang="port 4002">mongo --port 4002
rs.slaveOk()
exit</pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 21 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
	     <li>Process the following command in a new <strong class="blue">Terminal</strong> window to create data shards (two replication sets each
one consisting of two servers)
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mkdir data1-1
mkdir data1-2</pre>
          </ul>
        </li>
        <li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mongod --shardsvr --replSet data1 --dbpath data1-1 --port 4003</pre>
          </ul>
        </li>
		 <li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mongod --shardsvr --replSet data1 --dbpath data1-2 --port 4004</pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 22 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="port 4003">mongo -port 4003
rs.initiate()
rs.conf()
rs.add("localhost:4004")
rs.status()
exit</pre>
	    <pre class="prettyprint" data-lang="port 4003">mongo --port 4004
rs.slaveOk()
exit</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mkdir data2-1
mkdir data2-2</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mongod --shardsvr --replSet data2 --dbpath data2-1 --port 4005</pre>
          </ul>
        </li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 23 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Process the following command in a new <strong class="blue">Terminal</strong> window
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell">mongod --shardsvr --replSet data2 --dbpath data2-2 --port 4006</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal </strong>window
          <ul class="build">
            <pre class="prettyprint" data-lang="port 4005">mongo -port 4005
rs.initiate()
rs.conf()
rs.add("localhost:4006")
rs.status()
exit</pre>
             <pre class="prettyprint" data-lang="port 4005">mongo --port 4006
rs.slaveOk()
exit</pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 24 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Process the following command in a new <strong class="blue">Terminal</strong> window to start <strong class="green">mongos</strong>
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell">

mongos --configdb conf/localhost:4001,localhost:4002 --port 4000</pre>
          </ul>
        </li>
	<li>Process the following command in a new <strong class="blue">Terminal</strong> window to create shards on
replica sets on ports 4003 and 4005
          <ul class="build">
            <pre class="prettyprint" data-lang="Command shell ">mongo --port 4000
sh.addShard("data1/localhost:4003")
sh.addShard("data2/localhost:4005")</pre>
          </ul>
        </li>
	<li>List the data shards
          <ul class="build">
            <pre class="prettyprint" data-lang="getSiblingDB()">db.getSiblingDB("config").shards.find()</pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 25 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Enable sharding of a database
          <ul class="build">
            <pre class="prettyprint" data-lang="enableSharding()">sh.enableSharding("test")
db.getSiblingDB("config").databases.find()</pre>
          </ul>
        </li>
		<li>Insert a collection into shard
          <ul class="build">
            <pre class="prettyprint" data-lang="insert()">use test
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"000"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"001"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"002"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"003"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"004"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"005"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"006"})
db.testcol.insert({"fname":"James", "lname":"Bond", "shard-key":"007"})</pre>
          </ul>
        </li>
		<li>Create index on <strong class="green prettyprint28">"shard-key"</strong>
          <ul class="build">
            <pre class="prettyprint" data-lang="createIndex()">db.testcol.createIndex({"shard-key":1})</pre>
          </ul>
        </li>	
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 26 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Shard a collection
          <ul class="build">
            <pre class="prettyprint" data-lang="shardCollection()">sh.shardCollection("test.testcol", {"shard-key": 1})</pre>
          </ul>
	</li>
	<li>Get statistics
          <ul class="build">
            <pre class="prettyprint" data-lang="stats()">db.test_collection.stats()</pre>
	    <pre class="prettyprint" data-lang="Statistics">...    ...   ...   ... 
"shards" : {
   "data2" : {
              "ns" : "test.testcol",
              "size" : 592,
              "count" : 8,
              "avgObjSize" : 74,
              "storageSize" : 32768,
...    ...   ...   ...  </pre>
          </ul>
        </li>		
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 27 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Create large collection <strong class="green prettyprint">"test_collection"</strong>
          <ul class="build">
            <pre class="prettyprint" data-lang="test_collection">use test
var bulk = db.test_collection.initializeUnorderedBulkOp();
people = ["Marc", "Bill", "George", "Eliot", "Matt", "Trey", "Tracy",
"Greg", "Steve", "Kristina", "Katie", "Jeff"];
for(var i=0; i<1000000; i++){
    user_id = i;
    name = people[Math.floor(Math.random()*people.length)];
    number = Math.floor(Math.random()*10001);
    bulk.insert( { "user_id":user_id, "name":name, "number":number });
}
bulk.execute();</pre>
          </ul>
        </li>
	<li>Create index on <strong class="green prettyprint">"user_id"</strong>
          <ul class="build">
            <pre class="prettyprint" data-lang="createIndex()">db.test_collection.createIndex({user_id:1})</pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 28 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
        <li>Shard a colection over <strong class="green prettyprint">"user_id"</strong>
          <ul class="build">
            <pre class="prettyprint" data-lang="shardCollection()">sh.shardCollection("test.test_collection",{"user_id":1})</pre>
          </ul>
 	<li>Get statistics
	  <ul class="build">
            <pre class="prettyprint" data-lang="shardCollection()">sh.shardCollection("test.test_collection",{"user_id":1})</pre>
	    <pre class="prettyprint" data-lang="Statistics">...    ...   ...   ... 
"shards" : {
        "data1" : {
            "ns" : "test.test_collection",
            "size" : 184478484,
            "count" : 2604399,
            "avgObjSize" : 70,
            "storageSize" : 80326656,
...    ...   ...   ...  </pre>
	    <pre class="prettyprint" data-lang="Statistics">...    ...   ...   ... 
        "data2" : {
            "ns" : "test.test_collection",
            "size" : 135758751,
            "count" : 1916602,
            "avgObjSize" : 70,
            "storageSize" : 67858432,
...    ...   ...   ...  </pre>
	  </ul>
	</li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 29 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Find sharding status
          <ul class="build">
            <pre class="prettyprint" data-lang="status()">sh.status()</pre>
	    <pre class="prettyprint" data-lang="Status">databases:
{  "_id" : "config",  "primary" : "config",  "partitioned" : true }
                config.system.sessions
                        shard key: { "_id" : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                data1    1
                        { "_id" : { "$minKey" : 1 } } -->>
                        { "_id" : { "$maxKey" : 1 } } on : data1 Timestamp(1, 0)
...    ...   ...   ...</pre>
          </ul>
        </li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 30 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article class="smallest">
      <ul>
        <li>Sharding status
          <ul>
	    <pre class="prettyprint" data-lang="Status">                test.test_collection
                        shard key: { "user_id" : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                data1    10
                                data2    9
                        { "user_id" : { "$minKey" : 1 } } -->> { "user_id" : 0 } on : data2 Timestamp(8, 0)
                        { "user_id" : 0 } -->> { "user_id" : 166667 } on : data2 Timestamp(9, 0)
                        { "user_id" : 166667 } -->> { "user_id" : 289501 } on : data1 Timestamp(9, 1)
                        { "user_id" : 289501 } -->> { "user_id" : 414501 } on : data1 Timestamp(7, 5)
                        { "user_id" : 414501 } -->> { "user_id" : 479349 } on : data1 Timestamp(7, 6)
                        { "user_id" : 479349 } -->> { "user_id" : 604349 } on : data1 Timestamp(3, 0)
                        { "user_id" : 604349 } -->> { "user_id" : 789699 } on : data1 Timestamp(5, 0)
                        { "user_id" : 789699 } -->> { "user_id" : 958699 } on : data2 Timestamp(7, 1)
                        { "user_id" : 958699 } -->> { "user_id" : 1167398 } on : data2 Timestamp(3, 2)
                        { "user_id" : 1167398 } -->> { "user_id" : 1417399 } on : data2 Timestamp(3, 3)
                        { "user_id" : 1417399 } -->> { "user_id" : 1667400 } on : data2 Timestamp(3, 4)
                        { "user_id" : 1667400 } -->> { "user_id" : 1982999 } on : data2 Timestamp(3, 5)
                        { "user_id" : 1982999 } -->> { "user_id" : 2232999 } on : data1 Timestamp(5, 2)
                        { "user_id" : 2232999 } -->> { "user_id" : 2483000 } on : data1 Timestamp(5, 3)
                        { "user_id" : 2483000 } -->> { "user_id" : 2733001 } on : data1 Timestamp(5, 4)
                        { "user_id" : 2733001 } -->> { "user_id" : 3007999 } on : data1 Timestamp(5, 5)
                        { "user_id" : 3007999 } -->> { "user_id" : 3257999 } on : data2 Timestamp(6, 2)
                        { "user_id" : 3257999 } -->> { "user_id" : 3520999 } on : data2 Timestamp(6, 3)
                        { "user_id" : 3520999 } -->> { "user_id" : { "$maxKey" : 1 } } on : data1 Timestamp(7, 0) </pre>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 31 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Experiment</h2>
    </hgroup>
    <article>
      <ul>
        <li>Sharding status
          <ul>
	    <pre class="prettyprint" data-lang="Status">                test.testcol
                        shard key: { "shard-key" : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                data2    1
                        { "shard-key" : { "$minKey" : 1 } } -->>
                        { "shard-key" : { "$maxKey" : 1 } } on : data2 Timestamp(1, 0) </pre>
          </ul>
        </li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 32 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
        <li><a href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a class="red" href="#32">Querying and indexing</a></li>
        <li><a href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 33 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Querying and indexing</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>From a database application perspective, there is no difference between querying a sharded
cluster and querying a single unsharded database</li>
        <li>In both cases, the query interface and the process of iterating over the result set are the same</li>
	<li>How does it work inside the system ?</li>
        <li><strong class="red">Config servers</strong> maintain a mapping of shard key ranges to shards</li>
	<li>If a query includes a <strong class="red">shard key</strong>, then <strong class="rgreen">mongos</strong> can quickly find which shard contains the query result set; it is called a <strong class="red">targeted query</strong></li>
        <li>If the shard key is not part of the query then a query planner visits all shards to fulfill the query completely; it is called as a <strong class="red">global or scatter/gather query</strong></li>
	<li>In <strong class="red">sharded</strong> environment indexing is an important part of optimizing performance</li>
      </ul>
     <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 34 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Querying and indexing</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Indexing of a <strong class="red">sharded cluster</strong> has the following properties:
          <ul class="build">
           <li>each shard maintains its own indexes</li>
           <li>when an index is created on a sharded collection, each shard builds a separate index for its portion of the collection</li>
	   <li>it means that the sharded collections on each shard should have the same indexes, otherwise query performance is inconsistent</li>
	   <li>sharded collections permit unique indexes on the <strong class="green prettyprint">"_id"</strong> field and on the shard key only</li>
           <li>unique indexes are prohibited elsewhere because enforcing them would require inter-shard communication</li>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 35 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Sharding</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
         <li><a href="#2">Basics</a></li>
	<li><a href="#5">Why sharding ?</a></li>
        <li><a href="#7">Architecture</a></li>
	<li><a href="#12">Distribution</a></li>
        <li><a href="#18">Experiment</a></li>
        <li><a href="#32">Querying and indexing</a></li>
        <li><a class="red" href="#35">Production</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 36 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Production</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Theoretically to launch the sample MongoDB shard cluster, you had to start a total of nine
processes (three <strong class="green">mongod</strong>s for each replica set, plus three config servers</li>
        <li>In practice there is no need for so many processes</li>
		<li>Replicated <strong class="green">mongod</strong>s are the most resource-intensive processes in a shard cluster and must be
given their own machines</li>
        <li>Replica set arbiters incur little overhead and they don‚Äôt need their own servers.</li>
		<li>Config servers store a relatively small amount of data</li>
        <li>This means that config servers don‚Äôt necessarily need their own machines, either</li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 37 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">Production</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>From what you already know about replica sets and shard clusters, you can construct
a list of minimum deployment requirements:
          <ul class="build">
            <li>each member of a replica set, whether it‚Äôs a complete replica or an arbiter, needs to
live on a distinct machine</li>
            <li>every replicating replica set member needs its own machine.</li>
		    <li>replica set arbiters are lightweight enough to share a machine with another
process</li>
            <li>config servers can optionally share a machine; the only hard requirement is
that all config servers in the config cluster reside on distinct machines</li>
          </ul>
        </li>
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 38 ================================================================================= -->
<slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Banker K., Bakkum P., Verch S., Garret D., Hawkins T., MongoDB in Action, 2nd ed., Manning Publishers, 2016</li>
	<li><a href="https://docs.mongodb.com/v3.6/sharding/">MongoDB Manual, Sharding</a></li>	
      </ul>
      <footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>


  <slide class="backdrop"></slide>


</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>
