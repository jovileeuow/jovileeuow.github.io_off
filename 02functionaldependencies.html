<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/XACWC6XQ88iZ3r61f6Zcbt?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
-->
<!DOCTYPE html>
<html>
<head>
  <title>02FunctionalDependencies</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 

<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside> 
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>Functional Dependencies</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
       <li><a class="red" href="#2">Functional dependency ? What is it ?</a></li>	
	<li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>	
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <aside class="note">
      <section>
	<p>What is a data dependency ?</p>
	<br/>
	<p>Data dependency is a constraint/condition imposed on the contents of a database and always valid in every permanent state of a database.</p>
	<br/>
	<p>Data dependency is a reflection of the real world constraint in the contents of a database. For example, in the reality it is always true that age of a person is a positive number. It is impossible to have a negative age, well, maybe it is because we cannot travel back in time. A reflection of such real world constraint on the contents of a database is a condition enforced on the contents of a column "age" in a relational table and says that "age" > 0.</p>
	<br/>
	<p>What is a functional dependency ?</p>
	<br/>
	<p>A functional dependency is a special kind of data dependency saying that each value in a column or a tuple of values in the columns can be associated with only one value in another column or a tuple of values in another columns.</p>
	<br/>
	<p>A functional dependency is called "functional" because it is a function that maps the values in a column or a tuple of values in the columns into one value in another column or a tuple of values in another columns.</p>
	<br/>
	<p>Consider Let be a relational schema (a header of relational table) R  that consists of n columns (attributes) ( A1, ..., An). Assume that X, Y are the nonempty subsets of as schema R, for example X = {A1,A3} and Y = {A5}</p>
	<br/>
	<p>We say that a functional dependency X → Y (X functionally determines Y) is valid in a relational schema R if for any contents of a relational table R, it is not possible that R has two rows that agree in the components for all attributes in a set X yet disagree on one or more component for the attributes in a set Y. For example if {A1,A3} →  {A5} then it means that every pair of values of attributes A1, A3 is associated in. any state of a relational table R, with only one values of an attribute A5.</p>
	<br/>
	<p>For example, if a warehouse is located at one address then warehouse → address (warehouse functionally determines address) and it means that every value in a column warehouse is associated with only one value in a column address.</p>
	<br/>
	<p>For example, if at each address there is only one warehouse then address → warehouse (address functionally determines warehouse) and it means that every value in a column address is associated with only one value in a column warehouse.</p>
	<br/>
	<p>For example, if at each warehouse  the parts of the same sort have only one total quantity then warehouse,part → quantity ( a pair of attributes warehouse, part functionally determine an attribute quantity)and it means that every pair of values in the columns warehouse and part is associated with only one value in a column quantity.</p>
	<br/>
	<p>For example, if a car has one owner then registration → driving license (a registration number functionally determines driving license of its owner) and it means that each value in a column registration is associated with one value in a column driving license.</p>
	<br/>
	<p>For example, if a students has one first name and one last name and one date of birth then student-number → first-name, last-name-date-of-birth (a student number functionally determines first name, last name and date of birth) and it means that each value in a column student number is associated with one value in a column first name, one value in a column last name and one value in a column date of birth).</p>
	<br/>
      </section>
    </aside>  
  <hgroup>
      <h2 class="blue">Functional dependency ? What is it ?</h2>
  </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = ( A<sub class="subscript">1</sub>, ..., A<sub class="subscript">n</sub>)</strong> be a relational schema (a header of relational table) and let <strong class="red">X</strong>, <strong class="red">Y</strong> be the nonempty subsets of <strong class="red">R</strong></li>
        <li>We say that a functional dependency <strong class="red">X &rarr; Y</strong> is valid in a relational schema <strong class="red">R</strong> if</li>
	<li>for any contents of a relational table <strong class="red">R</strong>, it is not possible that <strong class="red">R</strong> has two rows that agree in the components for all attributes in a set <strong class="red">X</strong> yet</li>
	<li>disagree on one or more component for the attributes in a set <strong class="red">Y</strong></li>
	<li>Examples
	  <ul class="build">
	    <li>A warehouse is located at exactly one address: <strong class="blue">warehouse &rarr; address</strong></li>
    	    <li>An address is related to exactly one warehouse: <strong class="blue">address &rarr; warehouse</strong></li> 
	    <li>At a warehouse, the parts of the same sort have only one total quantity:<br><strong class="blue">warehouse,part &rarr; quantity</strong></li>
	    <li>A car has one owner: <strong class="blue">registration &rarr; driving license</strong></li>
	    <li>A student has one first name and one last name and one date of birth:<br><strong class="blue">student-number &rarr; first-name, last-name-date-of-birth</strong></li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
20232</footer>
    </article>
</slide>
<!-- slide 04 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>More examples:</p>
	<br/>
	<p>A fact that each employee belongs to one department is represented by a functional dependency: employee-number → department-name.</p>
	<br/>
	<p>A fact that each manager manages one department is represented by a functional dependency: manager-number → department-name</p>
	<br/>
	<p>A fact that each employee has one manager is represented by a functional dependency: employee-number → manager-number</p>
	<br/>
	<p>A fact that each student enrols a subject only one time  is represented by a functional dependency: student-number,subject-code → enrolment-date</p>
	<br/>
	<p>A fact that each employee is located in one building in one office is represented by a functional dependency: employee-number → building-number, office-number</p>
	<br/>
	<p>A fact that each office in a building hosts one employee is represented by a functional dependency: building-number, office-number → employee-number</p>
	<br/>
	<p>A fact that each office in a building at a campus hosts one employee is represented by a functional dependency: campus-name,building-number, office-number → employee-number</p>
	<br/>
	<p>A fact that each department has one manager is represented by a functional dependency: department-name → manager-number</p>
	<br/>
	<p>A fact that each department is located in one building is represented by a functional dependency: department-name → building-number</p>
	<br/>
	<p>A fact that each department has one manager and it is located in one building is represented by a functional dependency: department-name → manager-number,building-number</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependency ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>More examples
	  <ul class="build">
	    <li>An employee belongs to one department:<br/> <strong class="blue">employee-number &rarr; department-name</strong></li>
	    <li>A manager manages one department: <strong class="blue">manager-number &rarr; department-name </strong></li>
	    <li>An employee has one manager: <strong class="blue">employee-number &rarr; manager-number</strong></li>
	    <li>A student enrols a subject one time: <br/><strong class="blue">student-number,subject-code &rarr; enrolment-date</strong></li>
	    <li>An employee is located in one building in one office:<br><strong class="blue">employee-number &rarr; building-number, office-number</strong></li>
	    <li>An office in a building hosts one employee:<br><strong class="blue">building-number, office-number &rarr; employee-number</strong></li>
	    <li>An office in a building at a campus hosts one employee:<br><strong class="blue">campus-name,building-number, office-number &rarr; employee-number</strong></li>
	    <li>A department has one manager: <strong class="blue">department-name &rarr; manager-number</strong></li>
	    <li>A department is located in one building: <strong class="blue">department-name &rarr; building-number</strong></li>
	    <li>A department has one manager and it is located in one building:<br><strong class="blue">department-name &rarr; manager-number,building-number</strong></li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 05 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>An interesting question is how to discover the functional dependencies in a relational table ?</p>
	<br/>
	<p>What can first ask a question if it is possible to discover the functional dependencies in a relational schema (a header of relational table) R(A, B, C, D, E)  where a schema name and the attributes are single letters ? Of course it is impossible to do it because we do not know the semantics (the meanings) of the names: R, A, B, C, D, E.  In the other words we do not have good arguments to claim that for example A → B.</p>
	<br/>
	<p>It means that to discover the functional dependencies in a relational table we must use the semantics of a relational table name and the names of attributes.</p>
	<br/>
	<p>For example, consider a relational schema (a header of relational table) TRIP(rego#, licence#, tdate) of a relational table that contains information about the trips made by the drivers (licence#) who used the trucks (rego#) on a given day (tdate).</p>
	<br/>
	<p>To discover functional dependencies we may ask the following questions:</p>
	<br/>
	<p>Is it true in a real world domain described by a relational schema TRIP that a truck be used only one time ? If yes then rego# → tdate, it means that registration number functionally determines trip date, well, it is not true because each truck can be used on many different days.</p>
	<br/>
	<p>Is it true that  a driver make only one trip ? If yes the licence# → tdate, it means that driving license number functionally determines trip date, well it is not true because each driver can perform many trips on different days).</p>
	<br/>
	<p>Can a driver use more than one truck ? If yes then licence# → rego#, it means that driving license number functionally determines registration number, well, it is possible if each driver is assigned to only one truck</p>
	<br/>
	<p>Can a truck be used by more than one driver ? If yes then rego# → licence#, it means that registration number functionally determines driving license number, well, it is possible that each truck is used by only one driver.</p>
	<br/>
	<p>And so on, and so on, ... </p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependency ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>How to discover the <strong class="red">functional dependencies</strong> in a relational table ?
	  <ul class="build">
	    <li>Is it possible to discover the <strong class="red">functional dependencies</strong> in a <strong class="red">relational schema</strong> (a header of relational table) <strong class="green prettyprint">R(A, B, C, D, E)</strong> ? </li>
	    <li>Of course it is impossible to do it because we do not know the <strong class="red">semantics</strong> (<strong class="red">the meanings</strong>) of the names: <strong class="green prettyprint">R, A, B, C, D, E</strong> </li>
	    <li>To discover the <strong class="red">functional dependencies</strong> in a relational table we must use the <strong class="red">semantics</strong> of a <strong class="green">relational table name</strong> and the <strong class="green">names of attributes</strong></li>
	    <li>For example consider a relational schema (a header of relational table)  <strong class="green prettyprint">TRIP(rego#, licence#,  tdate)</strong> of a relational table that contains information about the <strong class="blue">trips</strong> made by the <strong class="blue">drivers</strong> (<strong class="green prettyprint">licence#</strong>) who used the <strong class="blue">trucks</strong> (<strong class="green prettyprint">rego#</strong>) on a given <strong class="blue">day </strong>(<strong class="green prettyprint">tdate</strong>)</li>
	    <li>Can a truck be used only one time ? If yes then <strong class="blue">rego# &rarr; tdate</strong></li>
	    <li>Can a driver make only one trip ? If yes then <strong class="blue">licence# &rarr; tdate</strong></li>
	    <li>Can a driver use more than one truck ? If no then <strong class="blue">licence# &rarr; rego#</strong></li>
	    <li>Can a truck be used by more than one driver ? If no then <strong class="blue">rego# &rarr; licence#</strong></li>
	    <li>And so on ... </li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 06 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">Functional dependency ? What is it ?</a></li>	
	<li><a class="red" href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 07 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>How functional dependencies are related to conceptual modeling ? Is is a different concept ? is it possible to discover the functional dependencies directly from the conceptual schemas ?</p>
	<br/>
	<p>Yes, a concept of functional dependency is a different concept from a concept of conceptual schema. Functional dependencies provide information about data  dependencies among the values of attributes. Conceptual schema groups the attributes within classes and does say anything about the association between values of the attributes within a class. However it is possible to almost automatically discover some of the functional dependencies from the identifiers of a class of objects.</p>
	<br/>
	<p>For example, if an attribute student number is an identifier of a class STUDENT then it means that each student must have a different student number. Then it never happens that two or more students have the same student number and it means that student number when assigned to one student is associated with one first name, one last name, one date of birth and one average of grades. It means that student number functionally determines first name, last name, date of birth and average.</p>
	<br/>
	<p>In the same way, if a triple of attributes (first name, last name, date of birth) is an identifier than such triple functionally determines student number and average.</p>
	<br/>
	<p>Then, in a general case it is true that identifier functionally determines all other single valued attributes in a class of objects.</p>
	<br/>
	<p>Of course these are not the only functional dependencies that can be valid among the attributes of a class of objects. For example, a class of objects ENROLMENT(s#,c#,title,edate) described by student number, course number, course title and enrolment date has an identifier(s#,c#,edate) and still c#  → edate, (course number has one title and because of that course number functionally determines enrolment date).</p>
	<br/>
	<p>Please also note that student number does not functionally determines language because language is a multivalued attribute, i.e. a student can speak more than one language.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies versus classes of objects</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A class of objects <strong class="green prettyprint">STUDENT</strong></li>
	<p style="text-align:center;"><img src="images/slide-07-1.png" alt="Owns" title="Owns"></p>
	<li>validates (satisfies) the following functional dependencies:<br><strong class="blue">s# &rarr; fname</strong><br><strong class="blue">s# &rarr; lname</strong><br><strong class="blue">s# &rarr; dob</strong><br><strong class="blue">s# &rarr; average</strong><br><strong class="blue">fname, lname, dob &rarr; s#</strong><br><strong class="blue">fname, lname, dob &rarr; average</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 08 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A set of functional dependencies {s# → fname, s# → lname, s# → dob, s# → average} is equivalent to a functional dependency s# → fname, lname, dob, average.</p>
        </br>
	<p>It means that it is possible to logically derive from a set of functional dependencies  {s# → fname, s# → lname, s# → dob, s# → average} a functional dependency  s# → fname, lname, dob, average and from a functional dependency  s# → fname, lname, dob, average it is possible to logically derive a set of functional dependencies {s# → fname, s# → lname, s# → dob, s# → average}</p>
	<br/>
	<p>Indeed if a student has one first name one last name one date of birth and one average then such student must have one quadruple of values [first name, last name, date of birth and average] On the other hand, if a student has one quadruple of values [first name, last name, date of birth and average]  then such student must have only one first name because more than first name would indicate more than one quadruple of values. The same applies to last name, date of birth an average.</p>
	<br/>
	<p>In the future we shall formulate a set of rules that will allow us to logically derive new valid functional dependencies from the dependencies about which we know that are valid in a relational schema.</p>
	<br/>
	<p>In the same way we can show that a set of functional dependencies {fname, lname, dob → s#, fname, lname, dob → average} is equivalent to a functional dependency fname, lname, dob → s#, average.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies versus classes of objects</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The functional dependencies:<br><strong class="blue">s# &rarr; fname</strong><br><strong class="blue">s# &rarr; lname</strong><br><strong class="blue">s# &rarr; dob</strong><br><strong class="blue">s# &rarr; average</strong><br> are equivalent to a functional dependency <br/> <strong class="blue">s# &rarr; fname, lname, dob, average</strong></li>
	<li>The functional dependencies <br><strong class="blue">fname, lname, dob &rarr; s#</strong><br/><strong class="blue">fname, lname, dob &rarr; average</strong> <br/> are equivalent to a functional dependency <br/> <strong class="blue">fname, lname, dob &rarr; s#, average</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 09 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
         <li><a href="#2">Functional dependency ? What is it ?</a></li>	
	 <li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a class="red" href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 10 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The classes of objects DEPARTMENT and CHAIRPERSON and association Has validate/satisfy the following functional dependencies:</p>
	<br/>
	<p>name → budget, building#, total-employees</p>
	<br/>
	<p>building# → name, budget, total-employees</p>
	<br/>
	<p>c# → fname, lname</p>
	<br/>
	<p>because the attributes name and building# are the identifiers in a class DEPARTMENT and an attribute c# is an identifier in a class CHAIRPERSON.</p>
	<br/>
	<p>If an association DEPARTMENT has Chairperson is one-to-one then each department is associated with one chairperson and because of that each name of a department is associated with one chairperson number, first name and last name. Such conclusion contributes to a functional dependency name → c#, fname, lname.</p>
	<br/>
	<p>In the same way we can logically derive a functional dependency building# → c#, fname, lname. </p>
	<br/>
	<p>If each chair person is associated with one department then each each chairperson number is associated with one name of department, one building number, one budget and one total number of employees in a department. It means that c# → name, building#, budget, total-employees.</p>
	<br/>
	<p>We can say that in a general case the single valued attributes on "one" of association are always functionally dependent on the identifier of a class on the other side of the same association.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies versus associations</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The classes of objects <strong class="green prettyprint">DEPARTMENT</strong> and <strong class="green prettyprint">CHAIRPERSON</strong> and association <strong class="green prettyprint">Has</strong></li>
	<p style="text-align:center;"><img src="images/slide-09-1.png" alt="Owns" title="Owns"></p>
	<li>validate (satisfy) the following functional dependencies:<br><strong class="blue">name &rarr; budget, building#, total-employees</strong><br><strong class="blue">building# &rarr; name, budget, total-employees</strong></li>
	<li><strong class="blue">c# &rarr; fname, lname</strong></li>
	<li><strong class="blue">name &rarr; c#, fname, lname</strong><br><strong class="blue">building# &rarr; c#, fname, lname</strong><br><strong class="blue">c# &rarr; name, building#, budget, total-employees</strong><br></li>

      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 11 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A rule saying that the single valued attributes on "one" of association are always functionally dependent on the identifier of a class on the other side of the same association applies to one-to-many association.</p>
	<br/>
	<p>For example, consider many-to-one association EMPLOYEE Works-on PROJECT. The single valued attributes on one side of association Works-on: title, budget, deadline are functionally dependent on the identifiers (e#), (fname, lname, dob ). </p>
	<br/>
	<p>Hence it is true that:</p>
	<br/>
	<p>e# → title, budget, deadline</p>
	<br/>
	<p>fname, lname, dob → title, budget, deadline</p>
	<br/>
	<p>It is NOT TRUE that title → e#, fname, lname, dob, salary because the attributes e#, fname, lname, dob, salary describe a class on "many" side of association. It is consistent with the reality because a project may have many employees involved.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies versus associations</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The classes of objects <strong class="green prettyprint">EMPLOYEE</strong> and <strong class="green prettyprint">PROJECT</strong> and association <strong class="green prettyprint">Works-on</strong></li>
	<p style="text-align:center;"><img src="images/slide-10-1.png" alt="Owns" title="Owns"></p>
	<li>validate (satisfy) the following functional dependencies:<br><strong class="blue">e# &rarr; fname, lname, dob, salary</strong><br><strong class="blue">fname, lname, dob &rarr; e#, salary</strong></li>
	<li><strong class="blue">title &rarr; budget, deadline</strong></li>
	<li><strong class="blue">e# &rarr; title, budget, deadline</strong></li>
		<li><strong class="blue">fname, lname, dob &rarr; title, budget, deadline</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 12 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>What about "many-to-many" association STUDENT Enrols COURSE ?</p>
	<br/>
	<p>In this case the only functional dependencies that can derived from a conceptual schema are coming from interpretation of identifiers of the classes of objects:</p>
	<br/>
	<p>s# → fname, lname</p>
	<br/>
	<p>code → title, credits</p>
	<br/>
	<p>title → code, credits</p>
	<br/>
	<p>and association class:</p>
	<br/>
	<p>s#, code, edate → score</p>
	<br/>
	<p>s#, title, edate → score</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies versus associations</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The classes of objects <strong class="green prettyprint">STUDENT</strong> and <strong class="green prettyprint">COURSE</strong> and association <strong class="green prettyprint">Enrols</strong></li>
	<p style="text-align:center;"><img src="images/slide-11-1.png" alt="Owns" title="Owns"></p>
	<li>validate (satisfy) the following functional dependencies:<br><strong class="blue">s# &rarr; fname, lname</strong></li>
	<li><strong class="blue">code &rarr; title, credits</strong><br>
	    <strong class="blue">title &rarr; code, credits</strong></li>
	<li><strong class="blue">s#, code, edate &rarr; score</strong><br>
	    <strong class="blue">s#, title, edate &rarr; score</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 13 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
       <li><a href="#2">Functional dependency ? What is it ?</a></li>	
	 <li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a class="red" href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 14 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Few slides. ago we discovered a rule saying that if a set of functional dependencies has the same left-hand side then such set of functional dependencies is equivalent to a single functional dependency that has the same left-hand side an all other attributes on the right hand side. For example, if it is true that X → Y1 and X → Y2 and ... X → Yn then it is true that X → Y1,Y2,... Yn. The opposite is also true: if is true that X → Y1,Y2,... Y then it is true that X → Y1 and X → Y2 and ... X → Yn.</p>
	<br/>
	<p>To discover more logical derivation rules for functional dependencies consider a relational schema:</p>
	<br/>
	<p>EMPLOYEE(e#, ename, department, address, chairperson)</p>
	<br/>
	<p>What we know up to now is such that if e# → ename and e# → department then e# → ename, department and the opposite, if  e# → ename, department  then e# → ename and e# → department.</p>
	<br/>
	<p>A logical inference rule saying that if p implies q and q implies r then p implies r (Robinson's principle)  can be applied to functional dependencies. It mean that if e# → department and department → address then e# → address.</p>
	<br/>
	<p>Using the same rule we can say that if e# → department and department → chairperson then e# → chairperson.</p>
	<br/>
	<p>Another simple rule is based on a principle saying that if f(x) is a function of a single variable then any extension over more variables is still a function. For example, if e# → department then e#, ename → department. It leads to a simple rule saying that we can add any attribute to a left-hand side of a valid functional dependency  to get another valid functional dependency. For example if e#, ename → department then e#, ename, address → department.</p>
	<br/>
	<p>Another interpretation of a rule saying that if  X → Y1,Y2,... Y then it is true that X → Y1 and X → Y2 and ... X → Yn can be such that it is always possible to remove an attribute from the right-hand side of a valid functional dependency to get another functional dependency,</p>
	<br/>
	<p>It leads to nice formulation of two "symmetrical" rules saying that we can add the attributes to left-hand side of a valid functional dependency and we can remove the attributes from the right-hand side of a valid functional dependency.</p>
	<br/>
	<p>An interesting observation that it is always true that e# → e# leads to a concept of so called "trivial functional dependency". A functional dependency e# → e# is always true because if a student number is related to the same student number then such relationship must be on-to-one.</p>
	<br/>
	<p>If we apply a derivation rule that allows to add attributes to a left-hand side of a functional dependency than we can find hat it is always true that e#, ename → e#. Every functional dependency X → Y such that Y is included or equal to X is always valid and it is called "trivial functional dependency"</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Derivations of functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Consider a relational schema (a header of relational table)<br><strong class="green prettyprint">EMPLOYEE(e#, ename, department, address, chairperson)</strong></li>
	<li>If <strong class="blue">e# &rarr; ename</strong> and <strong class="blue">e# &rarr; department</strong> then <strong class="blue">e# &rarr; ename, department</strong></li>
	<li>If <strong class="blue">e# &rarr; department</strong> and <strong class="blue">department &rarr; address</strong> then <strong class="blue">e# &rarr; address</strong></li>	
	<li>If <strong class="blue">e# &rarr; department</strong> and <strong class="blue">department &rarr; chairperson</strong> then <br/> <strong class="blue">e# &rarr; chairperson</strong></li>
	<li>If <strong class="blue">e# &rarr; department</strong> then <strong class="blue">e#, ename &rarr; department</strong></li>
	<li>If <strong class="blue">e#, ename &rarr; department</strong> then <strong class="blue">e#, ename, address &rarr; department</strong></li>
	<li>It is always true that <strong class="blue">e# &rarr; e#</strong></li>
	<li>Functional dependency <strong class="blue">e# &rarr; e#</strong> is called as a <strong class="red">trivial functional dependency</strong></li>
	<li>It is always true that <strong class="blue">e#, ename &rarr; e#</strong></li>
	<li>A functional dependency <strong class="blue">e#, ename &rarr; e#</strong> is also called as a <strong class="red">trivial functional dependency</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 15 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A trivial functional dependency is a functional dependency that is always true no matter what its left and right hand sides are, For example,</p>
	<br/>
	<p>e# → e#,</p>
	<br/>
	<p>department → department</p>
	<br/>
	<p>e#, ename → e#,</p>
	<br/>
	<p>e#, ename, department → e#, department,</p>
	<br/>
	<p>and so on</p>
	<br/>
	<p>A trivial functional dependency contributes to one more derivation rule accordingly to which we can derive a valid function dependency from nothing. it is a rule like if true then e# → e# is valid.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Derivations of functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">trivial functional dependency</strong> is a functional dependency that is always true no matter what its left and right hand sides are</li>
	<li>For example, <br/> <strong class="blue">e# &rarr; e#</strong>, <br/> <strong class="blue">department &rarr; department</strong> <br/><strong class="blue">e#, ename &rarr; e#</strong>, <br/><strong class="blue">e#, ename, department &rarr; e#, department</strong>, <br/> and so on</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 16 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now, we summarise the derivation rules for functional dependencies discovered so far. Consider a relational schema  R(A, B, C)</p>
	<br/>
	<p>(1) Then it is always true that A → A and  A, B → A and  A, B, C → A (trivial functional dependencies)</p>
	<br/>
	<p>(2) It is always true that if A → B then A, C → B (extension of left-hand side)</p>
	<br/>
	<p>(3) It is always true that if A → B, C then A → B and A → C (contraction fo the right-hand side)</p>
	<br/>
	<p>(4) It is always true that if A → B and B → C then A → C (transitivity)</p>
	<br/>
	<p>It is interesting that such system of derivation rules is complete. It means that any functional dependency that it logically implied by a set of valid function dependencies can be derives using the four derivation rule listed above. Unfortunately such system of rules is not minimal. It is possible to find a system of three derivation rules that is complete.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Derivations of functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Consider a relational schema <strong class="green prettyprint">R(A, B, C)</strong></li>
	<li>It is always true that <strong class="blue">A &rarr; A</strong></li>
	<li>It is always true that <strong class="blue">A, B &rarr; A</strong></li>
		<li>It is always true that <strong class="blue">A, B, C &rarr; A</strong></li>
	<li>If <strong class="blue">A &rarr; B</strong> then <strong class="blue">A, C &rarr; B</strong></li>
	<li>If <strong class="blue">A &rarr; B, C</strong> then <strong class="blue">A &rarr; B</strong> and <strong class="blue">A &rarr; C</strong></li>	
	<li>If <strong class="blue">A &rarr; B</strong> and <strong class="blue">B &rarr; C</strong> then <strong class="blue">A &rarr; C</strong></li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 17 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	  <li><a href="#2">Functional dependency ? What is it ?</a></li>	
	 <li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a class="red" href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 18 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A minimal and complete system of derivation rules forfunctional dependencies invented by William W. Armtrong in 1974 consist of 3 rules only.</p>
	<br/>
	<p>Consider Let  be a relational schema (a header of relational table) R = (A1, ..., An) where R is a name of the schema and A1, ..., An are the names of attributes (columns in a relational table). Let X, Y, Z be the nonempty subsets of {A1, ..., An}.</p>
	<br/>
	<p>Then the following 3 rules form a minimal and complete set of derivation rule  (axioms) for functional dependencies.</p>
	<br/>
	<p>(i) If Y ⊆ X then X → Y (reflexivity axiom)</p>
	<br/>
	<p>The first rule can be used to create trivial functional dependencies for any sets of attributes, It says that a set of attributes Y is included or if it is equal to a set of attributes X then X functionally determines Y,  X → Y . The first rule is called "reflexivity axiom".</p>
	<br/>
	<p>ii) If X → Y then X, Z → Y, Z (augmentation axiom)</p>
	<br/>
	<p>The second rule allows for the derivations of the new and valid functional dependencies from the given and valid functional dependencies. A derivation is performed through addition of the same set of attributes Z to both sides of a given functional dependency. The second rule is commonly known as "augmentation axiom".</p>
	<br/>
	<p>(iii) If X → Y and Y → Z then X → Z (transitivity axiom)</p>
	<br/>
	<p>The third rule, allows for the derivations of the new and valid functional dependencies from two given and valid functional dependencies such that the right-hand side of the first functional dependency is the same as the left-hand size of the second functional dependency. The third rule is call "transitivity axiom".</p>
	<br/>
	<p>The axioms (i),(ii), and (iii) form a minimal and complete set of derivation rules for functional dependencies. A set of rules is minimal because it is impossible remove any of the axioms such that a smaller set of rules obtained after elimination of an axiom is enough to derive all functional dependencies that can be logically inferred from a given set of functional dependencies.</p>
	<br/>
	<p>The axions form a complete set because it possible with the given set of axioms to derive all functional dependencies that can be logical inferred from a given set of functional dependencies.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Armstrong axioms</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A<sub class="subscript">1</sub>, ...,  A<sub class="subscript">n</sub>)</strong> be a relational schema (a header of relational table)  and<br>let <strong class="blue">X</strong>, <strong class="blue">Y</strong>, <strong class="blue">Z</strong> be the nonempty subsets of <strong class="blue">{A<sub class="subscript">1</sub>, ...,  A<sub class="subscript">n</sub>}</strong></li>
	<li>(i) If <strong class="blue">Y &sube; X</strong> then <strong class="blue">X &rarr; Y</strong> (<strong class="red">reflexivity axiom</strong>)</li>
	<li>(ii) If <strong class="blue">X &rarr; Y</strong> then <strong class="blue">X, Z &rarr; Y, Z</strong> (<strong class="red">augmentation axiom</strong>)</li>
	<li>(iii) If <strong class="blue">X &rarr; Y</strong> and <strong class="blue">Y &rarr; Z</strong> then <strong class="blue">X &rarr; Z</strong> (<strong class="red">transitivity axiom</strong>)</li>
	<li>The axioms (i),(ii), and (iii) form a <strong class="red">minimal and complete set of axioms</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 19 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#2">Functional dependency ? What is it ?</a></li>	
	 <li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a class="red" href="#19">Other inference rules</a></li>		
	<li><a href="#21">Using inference rules</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 20 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>It is possible to create from the Armstrong axioms other derivation rules that can be used to create new and valid functional dependencies from a given set of valid functional dependencies.</p>
	<br/>
	<p>Let like before  R = (A1, ..., An) be a relational schema and let X, Y, Z be the nonempty subsets of {A1, ..., An}.</p>
	<br/>
	<p>Then, if X → Y and X → Z then X → Y, Z </p>
	<br/>
	<p>It is so called "union rule" saying that if left-hand side of two or more functional dependencies is the same then we can create a new functional dependecy with the same left-hand side and right-hand side being union of right-hand side of functional depndencies involved.</p>
	<br/>
	<p>If X → Y and W, Y → Z then W, X → Z</p>
	<br/>
	<p>It is so called pseudotransitivity rule which is a generalization of transitivity rule. If we assume that W is an empty set than the pseudotransitivity rule reduces to the transitivity rule. Correctness of pseudo transitivity rule can be quite easily proved with the Armstrong axioms. We can apply augmentation rule to X → Y getting WX → WY. Then we apply transitivity rule to WX → WY and WY → Z  obtaining WX→ Z .</p>
	<br/>
	<p>If X → Y and Z ⊆ Y then X → Z </p>
	<br/>
	<p>It is  so called decomposition rule or reduce right hand side rule. it means that we can always remove an attribute from right-hand side of any functional dependency and the result is still valid functional dependency. However, note that a set of attributes on the right-hand side of functional dependency cannot be empty.</p>
	<br/>
	<p>If X → Y then X, Z → Y</p>
	<br/>
	<p>It is a rule that allows us to extend a right-hand side of any valid functional dependency with any attribute and to still get a valid functional dependency.</p>
	<br/>
	<p>It is worth to remember to simple principles governing derivations of functional dependencies. It is allowed to reduce the right-hand side of any functional dependency and it is allowed to extend the left-hand size of any functional dependency and ... NOT the opposite.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Other inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A<sub class="subscript">1</sub>, ...,  A<sub class="subscript">n</sub>)</strong> be a relational schema (a header of relational table)  and<br>let <strong class="blue">X</strong>, <strong class="blue">Y</strong>, <strong class="blue">Z</strong> be the nonempty subsets of <strong class="blue">{A<sub class="subscript">1</sub>, ...,  A<sub class="subscript">n</sub>}</strong></li>
	<li>If <strong class="blue">X &rarr; Y </strong>and <strong class="blue">X &rarr; Z</strong> then <strong class="blue">X &rarr; Y, Z</strong> (<strong class="red">union rule</strong>)</li>
	<li>If <strong class="blue">X &rarr; Y</strong> and <strong class="blue">W, Y &rarr; Z</strong> then <strong class="blue">W, X &rarr; Z</strong>	(<strong class="red">pseudotransitivity rule</strong>)</li>
	<li>If <strong class="blue">X &rarr; Y</strong> and <strong class="blue">Z &sube; Y</strong> then <strong class="blue">X &rarr; Z</strong> (<strong class="red">decomposition rule</strong> or <strong class="red">reduce right hand side rule</strong>)</li>
	<li>If <strong class="blue">X &rarr; Y</strong> then <strong class="blue">X, Z &rarr; Y</strong> (<strong class="red">extend left hand side rule</strong>)</li>

      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 21 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Functional dependencies</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#2">Functional dependency ? What is it ?</a></li>	
	 <li><a href="#6">Functional dependencies versus classes of objects</a></li>	
	<li><a href="#9">Functional dependencies versus associations</a></li>	
	<li><a href="#13">Derivations of functional dependencies</a></li>	
	<li><a href="#17">Armstrong axioms</a></li>	
	<li><a href="#19">Other inference rules</a></li>		
	<li><a class="red" href="#21">Using inference rules</a></li>
      </ul></strong>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 22 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the next few slides we practice derivations of functional dependencies. We use Armstrong axioms to prove the correctness of the other derivation rules presented in the previous slides.</p>
	<br/>
	<p>Let R = (A, B, C) be a relational schema. Assume that the following functional dependencies A → B, B → C are valid in R. We shall try to prove that a functional dependency A → C is also valid in R.</p>
	<br/>
	<p>A proof is very simple. Assume that X = A, Y = B and Z = C. Then, we apply a transitivity axiom to the functional dependencies A → B, B → C  and we get A → C.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Using inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A, B, C)</strong> be a relational schema</li>
	<li>Given set of functional dependencies <strong class="blue">F = {A &rarr; B, B &rarr; C}</strong> valid in <strong class="red">R</strong></li>
	<li>Is it true that <strong class="blue">A &rarr; C</strong> ?</li>
	<li>If <strong class="blue">A &rarr; B</strong> and <strong class="blue">B &rarr; C</strong> then application of <strong class="red">transitivity axiom</strong> provides <strong class="blue">A &rarr; C</strong></li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 23 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Let R = (A, B, C) be a relational schema. Assume that the following functional dependency A → B,C is valid in R. We shall try to prove that a functional dependencies A → C and are also valid in R. In the other words we try to prove the correctness of "reduce right-hand size" rule.</p>
	<br/>
	<p>From reflexivity axiom we can B,C → C.  Then, application of transitivity axiom to A → B,C and B,C → C provides A → C.</p>
	<br/>
	<p>In the same way we can start from B,C → B using reflexivity axiom. Then,  application of transitivity axiom to A → B,C and B,C → B provides A → B.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Using inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A, B, C)</strong> be a relational schema</li>
	<li>Given set of functional dependencies <strong class="blue">F = {A &rarr; B, C}</strong> valid in <strong class="red">R</strong></li>
	<li>Is it true that <strong class="blue">A &rarr; B</strong> and <strong class="blue">A &rarr; C</strong> ?</li>
	<li><strong class="red">Reflexivity axiom</strong> provides <strong class="blue">B, C &rarr; C</strong></li>
	<li>If <strong class="blue">A &rarr; B, C</strong> and <strong class="blue">B, C &rarr; C</strong> then <strong class="red">transitivity axiom</strong> provides <strong class="blue">A &rarr; C</strong></li>
	<li><strong class="red">Reflexivity axiom</strong> provides <strong class="blue">B, C &rarr; B</strong></li>
	<li>If <strong class="blue">A &rarr; B, C</strong> and <strong class="blue">B, C &rarr; B</strong> then <strong class="red">transitivity axiom</strong> provides <strong class="blue">A &rarr; B</strong></li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 24 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Let R = (A, B, C) be a relational schema. Assume that the following functional dependencies A → B and A → C are valid in R. We shall try to prove that a functional dependencies A → B,C is also valid in R. In the other words we try to prove the correctness of "union" rule.</p>
	<br/>
	<p>This time we apply augmentation axiom to a functional dependency A → B. We add A to both sides getting  A → A,B. Note hat in set theory A union A = A. it is why left-hand side of a derived functional dependency is A and not AA.</p>
	<br/>
	<p>Next, we apply augmentation rule to  A → C again adding B to both sides  and getting A ,B→ B,C</p>
	<br/>
	<p>Then an application of transitivity rule to A → A,B and A,B → B,C provides A → B,C.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Using inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A, B, C)</strong> be a relational schema</li>
	<li>Given set of functional dependencies <strong class="blue">F = {A &rarr; B, A &rarr; C}</strong> valid in <strong class="red">R</strong></li>
	<li>Is it true that <strong class="blue">A &rarr; B, C</strong> ?</li>
	<li>If <strong class="blue">A &rarr; B</strong> then <strong class="red">augmentation axiom</strong> provides <strong class="blue">A &rarr; A, B</strong></li>
	<li>If <strong class="blue">A &rarr; C</strong> then <strong class="red">augmentation axiom</strong> provides <strong class="blue">A, B &rarr; B, C</strong></li>
	<li>If <strong class="blue">A &rarr; A, B</strong> and <strong class="blue">A, B &rarr; B, C</strong> then <strong class="red">transitivity axiom</strong> provides <strong class="blue">A &rarr; B, C</strong></li>
	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 25 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Let R = (A, B, C) be a relational schema. Assume that the following functional dependency A → B is valid in R. We shall try to prove that a functional dependencies A,C → B is also valid in R. In the other words we try to prove the correctness of "extend right-hand side" rule. rule to the first</p>
	<br/>
	<p>Like before we start from application of reflexivity axiom. Reflexivity axiom says that it is true that A,C → A. Then we apply transitivity to  A,C→ A and A → B obtaining  A,C → B.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Using inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A, B, C)</strong> be a relational schema</li>
	<li>Given set of functional dependencies <strong class="blue">F = {A &rarr; B}</strong> valid in <strong class="red">R</strong></li>
	<li>Is it true that <strong class="blue">A, C &rarr; B</strong> ?</li>
	<li><strong class="red">Reflexivity axiom</strong> provides <strong class="blue">A, C &rarr; A</strong></li>	
	<li>If <strong class="blue">A, C &rarr; A</strong> and <strong class="blue">A &rarr; B</strong> then <strong class="red">transitivity axiom</strong> provides <strong class="blue">A, C &rarr; B</strong></li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 26 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In this case, we consider a relational schema STUDENT(s#, fname, lname, dob, average) and we assume that the following functional dependencies are valid in a schema STUDENT: </p>
	<br/>
	<p>s# → fname</p>
	<br/>
	<p>s# → lname</p>
	<br/>
	<p>s# → dob</p>
	<br/>
	<p>s# → average</p>
	<br/>
	<p>fname, lname, dob → s#</p>
	<br/>
	<p>fname, lname, dob → average</p>
	<br/>
	<p>Validity of both groups of functional dependencies comes from the identifiers of a class STUDENT considered earlier.</p>
	<br/>
	<p>We apply union rule to the first four functional dependencies with a left-hand size s# and we obtain a single functional dependency s# → fname, lname, dob, average. In the same way we merge the last two functional dependencies  into fname, lname, dob → s#, average.</p>
	<br/>
	<p>Both functional dependencies derived now have two interesting properties. A set of attributes from both left and right-hand side of each functional dependency is the same as a set of attributes of a relational schema STUDENT. We say that it "covers" a relational schema STUDENT.</p>
	<br/>
	<p>The second interesting property is such that it is impossible to remove from the left-hand side of both functional dependencies any attribute that we still get a valid functional dependency. in  the first case of s# → fname, lname, dob, average we cannot remove s# because left-hand side cannot be empty. in the second case if we remove fname then it is not true that lname, dob → s#, average because it is possible to find two students with the same last name and the same date of birth who have  a different student number and an average. If we remove lname then it is not true that fname, dob → s#, average becasue it is possible to find two students with the same first name and date of birth who have a different student number and an average. in the last case, if we remove date of birth then it is not true that fname, lname → s#, average because it is possible to find two students with the same first name and last name who have a different student number and average. It means that we cannot remove any attribute from the left hand side of a functional dependency fname, lname, dob → s#, average and in the same moment preserve validity of a new functional dependency obtained after elimination of an attribute from the left-hand side. In such a case we say that left-hand side of a functional dependency is minimal.</p>
	<br/>
	<p>If all attributes of a functional dependency cover a relational schema and left-hand side of a functional dependency is minimal then left-hand side is a minimal key of the relational schema. It means that it is either primary key or candidate key.  Such interesting conclusion allows us to find minimal keys directl y from functional dependencies valid in a relational schema. We no longer need to use information about the identifiers.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Using inference rules</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="red">STUDENT(s#, fname,lname, dob, average)</strong> validates (satisfies) the following functional dependencies:<br><strong class="blue">s# &rarr; fname</strong><br><strong class="blue">s# &rarr; lname</strong><br><strong class="blue">s# &rarr; dob</strong><br><strong class="blue">s# &rarr; average</strong><br><strong class="blue">fname, lname, dob &rarr; s#</strong><br><strong class="blue">fname, lname, dob &rarr; average</strong></li>
	<li>We proved that if <strong class="blue">A &rarr; B</strong> and <strong class="blue">A &rarr; C</strong> then <strong class="blue">A &rarr; B, C</strong></li>
	<li>Hence, <br><strong class="blue">s# &rarr; fname, lname, dob, average</strong> and ... </li>
	<li><strong class="blue">fname, lname, dob &rarr; s#, average</strong></li>
	<li>Note, that both functional dependencies <strong class="red">cover</strong> entire relational schema and <strong class="red">no other</strong> functional dependencies that <strong class="red">do not cover </strong>entire relational schema validate in the schema e.g. <strong class="blue">fname &rarr; s#</strong><li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 27 ================================================================================= -->
  <slide>
   <aside class="note">
      <section>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
	<p></p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>T. Connoly, C. Begg, Database Systems, A Practical Approach to Design, Implementation, and Management, Chapter 14.4  Functional Dependencies, Chapter 15.1 More on Functional Dependencies, Pearson Education Ltd,  2015</li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/Nk6HC71R33TnPAXQSBKVHv?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>

