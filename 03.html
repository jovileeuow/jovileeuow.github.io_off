<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/eImcCzvkppUOWvLzcXmNuF?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
  -->
<!DOCTYPE html>
<html>
<head>
  <title>03DatabaseNormalization</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 

<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>Database Normalization</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a class="red" href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>			
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <aside class="note">
      <section>
	<p>The first presentation on the relational database mode in a subject CSIT115 introduced a concept of the first normal form (1NF).</p>
	<br/>
	<p>We say that a relational schema is in the First Normal Form (1NF) if all occurrences of rows in the respective relational table contain the same number of fields and include the atomic values only, i.e. there are no repeating fields and groups.</p>
	<br/>
	<p>A relational table given on the present slide is in the first normal form despite that the values in a column odate (order date) consist of three components: day, month and year. The values of type date can exceptionally have a complex structure because it allows for an easy implementation of date arithmetic (tomorrow = today +1) and date comparison (tomorrow > today). Distribution of date, month and year over separate columns will require additional operations for assembling date components into  a complete date.</p>
	<br/>
	<p>The other columns in a relational table given on the present slide contain only atomic values.</p>
	<br/>
	<p>We also say that a relational schema which is not in the First Normal Form (1NF) is in the Zeroth Normal Form (0NF) or it is called as a nested relational schema. A relational table built over a nested relational schema is called as a nested relational table or 0NF relational table. Do exist database systems that provide a logical view of data as a nested relational table ?  In the past such systems have been implemented and later on failed to capture a location at a commercial market. Additionally, later on, object-oriented, object-relational, XML, and JSON data models provide more sophisticated ways of representation of nested data structures than simple nested relational tables.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">First Normal Form (1NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema is in the <strong class="red">First Normal Form (1NF)</strong> if all occurrences of rows in  the respective relational  table contain the same number of fields and include the atomic values only, i.e. there are no repeating fields and groups
	  <ul class="build">
	    <pre class="prettyprint" data-lang="1NF relational table">
	      
+--------+-------+-------+---------+------------+---------+-------+-------+-------+
|cnumber | fname | lname | onumber |   odate    | lnumber | item  | price | total |
+--------+-------+-------+---------+------------+---------+-------+-------+-------+
|   7    | James | Bond  |    7    | 2017-01-01 |    1    | bolt  | 23.04     5   |
|   7    | James | Bond  |    7    | 2017-01-01 |    2    | nut   | 29.01 |   3   |
|   7    | James | Bond  |    8    | 2017-01-02 |    1    | nut   |  4.55 |   2   |
|   7    | James | Bond  |    8    | 2017-01-02 |    2    | pin   | 14.25 |   2   |
+--------+-------+-------+---------+------------+---------+-------+-------+-------+</pre>
	  </ul>
	<li>A relational schema which is not in the <strong class="blue">First Normal Form (1NF)</strong> is in <strong class="red">Zeroth Normal Form (0NF)</strong> or it is called as a <strong class="red">nested relational schema</strong></li>
	<li>A relational table built over a <strong class="blue">nested relational schema</strong> is called as a <strong class="red">nested relational table</strong> or <strong class="red">0NF relational table</strong>.</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 04 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The present slide shows a nested relational table where information about the orders submitted by a customer is a value in a column orders. A value is a relational table where the values in the columns order number and order date are atomic and the ordered parts is a relational table in a column parts.</p>
	<br/>
	<p>In the present example a customer 7, James Bond submitted two orders  on 2017-01-01 and on 2017-01-02. The first order included two items: bolt and nut. The second order also included two parts: nut an pin,</p>
	<br/>
	<p>A relational table given in the present slide is in 0NF because the values in the columns orders and parts are not atomic.The nested relational tables are the values in the columns orders and parts. It is why a relational table in 0NF is also called as nested  relational table.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">First Normal Form (1NF)</h2>
    </hgroup>
    <article>
      <ul>
	  <ul>
	    <pre class="prettyprint" data-lang="0NF relational table">
	      
+---------+-------+-------+---------------------------------------------------------+
| cnumber | fname | lname |                      orders                             |
+---------+-------+-------+---------------------------------------------------------+
|         |       |       | +-----------------------------------------------------+ |
|    7    | James | Bond  | |  onumber | odate       |         parts              | |
|         |       |       | +-----------------------------------------------------+ |
|         |       |       | |          |             | +------------------------+ | |  
|         |       |       | |    7     | 2017-01-01  | |lnumber|item|price|total| | |
|         |       |       | |          |             | +------------------------+ | |
|         |       |       | |          |             | |  1    |bolt|23.04|  5  | | |
|         |       |       | |          |             | |  2    |nut |29.01|  3  | | |
|         |       |       | |          |             | +------------------------+ | |
|         |       |       | |          |             | +------------------------+ | |  
|         |       |       | |    8     | 2017-01-02  | |lnumber|item|price|total| | |
|         |       |       | |          |             | +------------------------+ | |
|         |       |       | |          |             | |  1    |nut | 4.55|  2  | | |
|         |       |       | |          |             | |  2    |pin |14.25|  2  | | |
|         |       |       | |          |             | +------------------------+ | |
|         |       |       | +-----------------------------------------------------+ |
+---------+-------+-------+---------------------------------------------------------+</pre>
	  </ul>	    
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 05 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
         <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a class="red" href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 06 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A concept of a key has been already introduced when the relational database model has been presented in the first year database subject. The keys where defined as the smallest sets of attributes obtained from the transformations of identifiers of classes of objects into primary and candidate keys in a process of logical design. An assumption was such that the identifiers of the classes of objects were created in a correct way.</p>
	<br/>
	<p>At a level of conceptual modelling the identifiers are created in an informal way on the base of our knowledge of modelled database domain. When proving the correctness of a relational design with functional dependencies all what we have are the functional dependencies describing the semantics of data. And it means that in such a case the keys must be derived from functional dependencies.</p>
	<br/>
	<p>We start from a definition of a superkey. A superkey is a nonempty subset X of relational schema R = (A1, ... , An) such that for any two rows ti, tj, ti‚â† tj in a relational table created over a relational schema R ti[X] ‚â† tj[X]. It also means that if X is a superkey then no two rows can have identical X-values in a relational table.</p>
	<br/>
	<p>A superkey is called as "superkey" because it is a subset of minimal key, i.e. either primary key or one of candidate keys.</p>
	<br/>
	<p>An important observation from the previous slide is that if X is a superkey in R then X ‚Üí A1, ... , An. It means that a superkey functionally determines all other attributes in a relational schema. it also means that if from a given set of functional dependencies we can derive X ‚Üí A1, ... , An then X is a superkey. If for none of proper subsets X' of X it is true that X' ‚Üí A1, ... , An then left-hand side of functional dependence is minimal and a superkey X' is minimal. It is later on called as "minimal key".</p>
	<br/>
	<p>A minimal key is a superkey K with an additional property such that removal of any attribute from K causes K not to be a superkey.</p>
	<br/>
	<p>For example, a relational schema TRIP(rego#, licence#, tdate) has one minimal key (rego#, licence#, tdate). In the systems where a precision of date is a day,  a driver can make at most one trip per day. If in the reality such constraint is not true then it is always possible to make granulation of time finer and consider date and time.</p>
	<br/>
	<p>A set of attributes is (rego#, licence#, tdate) is a minimal key because none of its subsets has a property to be a key. For example a pair of attributes (rego#, licence#) is not a key because a drive can use the same vehicle for two trips on different days.</p>
	<br/>
	<p>It is possible that a relational schema has more than one minimal key. For example, a relational schema DRIVER(licence#, employee#, first-name, last-name) has two minimal keys (licence#) and (employee#).</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Keys</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">superkey</strong> is a  nonempty subset <strong class="red">X</strong> of relational schema <strong class="red">R = (A<sub class="subscript">1</sub>, ... , A<sub class="subscript">n</sub>)</strong> such that for any two rows <strong class="red">t<sub class="subscript">i</sub>, t<sub class="subscript">j</sub></strong>,  <strong class="red">t<sub class="subscript">i</sub>&ne; t<sub class="subscript">j</sub></strong> in a relational table created over a relational schema <strong class="red">R t<sub class="subscript">i</sub>[X] &ne; t<sub class="subscript">j</sub>[X]</strong></li>
	<li>If <strong class="red">X</strong> is a <strong class="blue">superkey</strong> in <strong class="red">R</strong> then <strong class="blue">X &rarr; A<sub class="subscript">1</sub>, ... , A<sub class="subscript">n</sub></strong></li>
	<li>A <strong class="red">minimal key</strong> is a <strong class="blue">superkey</strong> <strong class="red">K</strong> with an additional property such that removal of any attribute from <strong class="red">K</strong> causes <strong class="red">K</strong> not to be a <strong class="blue">superkey</strong></li>
	<li>For example, a relational schema  <strong class="green prettyprint">TRIP(rego#, licence#,  tdate)</strong> has one <strong class="red">minimal key</strong> <strong class="green prettyprint">(rego#, licence#,  tdate)</strong></li>
	<li>For example, a relational schema <strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> has two <strong class="red">minimal key</strong>s <strong class="green prettyprint">(licence#)</strong> and <strong class="green prettyprint">(employee#)</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 07 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>If we know what is a minimal key in a schema, for example a set of attributes X, then any X and any proper superset of X is a superkey.</p>
	<br/>
	<p>For example, relational schema </p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<br/>
	<p>has many superkeys: (licence#) , (employee#) , (licence#, employee#) , (licence#, first-name) , (licence#, last-name) , (licence#, first-name, last-name), and so on ...</p>
	<br/>
	<p>How does a concept of minimal key is related to the already known concepts of primary and candidate keys ? A minimal key is a smallest set of attribute whose values uniquely identify each row in a relational table.</p>
	<br/>
	<p>It means that a primary key is an arbitrarily selected minimal key.</p>
	<br/>
	<p>A candidate key is any other minimal key which is not a primary key.</p>
	<br/>
	<p>For example a minimal key (rego#, licence#, tdate) in a relational schema </p>
	<br/>
	<p>TRIP(rego#, licence#, tdate) </p>
	<br/>
	<p>can be nominated as a primary key (rego#, licence#, tdate).</p>
	<br/>
	<p>For example, a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<br/>
	<p>has a primary key (licence#) and a candidate key (employee#) or the opposite. </p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Keys</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>For example, relational schema <strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> has many <strong class="red">superkeys</strong>: <strong class="green prettyprint">(licence#)</strong> , <strong class="green prettyprint">(employee#)</strong> , <strong class="green prettyprint">(licence#, employee#)</strong> , <strong class="green prettyprint">(licence#, first-name)</strong> , <strong class="green prettyprint">(licence#, last-name)</strong> , <strong class="green prettyprint">(licence#, first-name, last-name)</strong>, and so on ... </li>
	<li>A <strong class="red">primary key</strong> is an arbitrarily selected <strong class="blue">minimal key</strong></li>
	<li>A <strong class="red">candidate key</strong> is any other <strong class="blue">minimal key</strong> which is not a <strong class="red">primary key</strong></li>
	<li>For example, a relational schema <br> <strong class="green prettyprint">TRIP(rego#, licence#,  tdate)</strong> <br> has a <strong class="red">primary key</strong> <strong class="green prettyprint">(rego#, licence#,  tdate)</strong></li>	
	<li>For example, a relational schema <br><strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> <br> has a  <strong class="red">primary key</strong> <strong class="green prettyprint">(licence#)</strong> and a <strong class="red">candidate key</strong> <strong class="green prettyprint">(employee#)</strong> or the opposite</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 08 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
         <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a class="red" href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 09 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>What are the relationships between superkeys, minimal keys and functional dependencies ?</p>
	<br/>
	<p>Assume that we have a relational schema R = (A1, ... , An) that consists of n attributes (columns in a relational table with a header (A1, ... , An) ). We consider two nonempty subsets X, Y of a set of attributes (A1, ... , An) such that X ‚à™ Y = R. We say that X ‚à™ Y "covers" a relational schema R.
</p>
	<br/>
	<p>Then, if a functional dependency  X ‚Üí Y is valid in R then X is a superkey. The opposite is also true. If X is a superkey then a functional dependency X ‚Üí Y is valid in R.
</p>
	<br/>
	<p>If a functional dependency  X ‚Üí Y is valid in R and if X is minimal, i.e. it is not true that X' ‚Üí Y for any X' properly included in X then X is a minimal key. The opposite is also true. If X is a minimal key than  X ‚Üí Y is valid in R and it is not true that X' ‚Üí Y for any X' properly included in X. It means that left hand side of functional dependency  X ‚Üí Y is minimal.
</p>
	<br/>
	<p>For example, if a functional dependency licence#, employee# ‚Üí first-name, last-name is valid in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name) then (licence#, employee#) is a superkey.</p>
	<br/>
	<p>If a functional dependency licence# ‚Üí first-name, last-name is valid in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name) then (licence#) is a minimal key.</p>
	<br/>
	<p>For example, if a functional dependency employee# ‚Üí first-name, last-name is valid in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name) then (employee#) is a minimal key.</p>
	<br/>
	<p>Opposite, if (licence#) is a superkey in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<br/>
	<p>then a functional dependency licence# ‚Üí employee#, first-name, last-name is valid in a schema DRIVER.</p>
	<br/>
	<p>Opposite, if (employee#) is a superkey in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<br/>
	<p>then a functional dependency employee# ‚Üí licence#, first-name, last-name is valid in a schema DRIVER.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Functional dependencies and keys</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = (A<sub class="subscript">1</sub>, ... , A<sub class="subscript">n</sub>)</strong> be a relational schema and let <strong class="red">X</strong>, <strong class="red">Y</strong> be nonempty subsets of <strong class="red">R</strong> such that <strong class="red">X &cup; Y = R</strong></li>
	<li>If a functional dependency <strong class="blue">X &rarr; Y</strong> is valid in <strong class="red">R</strong> then <strong class="red">X</strong> is a <strong class="blue">superkey</strong></li>
	<li>If <strong class="red">X</strong> is a <strong class="blue">superkey</strong> then a functional dependency <strong class="blue">X &rarr; Y</strong> is valid in <strong class="red">R</strong></li> 
	<li>For example, if a functional dependency <strong class="blue">licence#, employee# &rarr; first-name, last-name</strong> is valid in a  relational schema <br><strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> <br> then  <strong class="green prettyprint">(licence#, employee#)</strong> is a <strong class="blue">superkey</strong></li>
	<li>For example, if <strong class="green prettyprint">(licence#)</strong> is a superkey in a relational schema <br> <strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> <br> then a functional dependency <strong class="blue">licence# &rarr; employee#, first-name, last-name</strong> is valid in <strong class="green prettyprint">DRIVER</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 10 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
         <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a class="red" href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 11 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Assume that X is a minimal key valid in a  relational schema  R. Any attribute A in X is called as "prime attribute". In the other words, a prime attribute is an attribute from relational schema R which is a member of at least one minimal key in R.</p>
	<br/>
	<p>An attribute that is not prime is called as "nonprime attribute". A nonprime attribute is an attribute that is not a member of any minimal key in a schema R.</p>
	<br/>
	<p>For example, the attributes licence# and employee# are prime attributes in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name).</p>
	<br/>
	<p>It is because licence# is a member of a minimal key (licence#) and employee# is a member of a minimal key (employee#).</p>
	<br/>
	<p>The attributes first-name and last-name are nonprime attributes in a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name) </p>
	<br/>
	<p>because both attributes do not belong to the minimal keys (licence#) and (employee#).</p>
	<br/>
	<p>In a relational schema </p>
	<br/>
	<p>TRIP(rego#, licence#, tdate)</p>
	<br/>
	<p>all attributes are prime because all of them belong to a minimal key (rego#, licence#, tdate).</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Attributes</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">prime attribute</strong> is an attribute from relational schema <strong class="red">R</strong> which is a member of at least one  minimal  key in <strong class="red">R</strong></li>
	<li>A <strong class="red">nonprime attribute</strong> is an attribute which is not <strong class="blue">prime</strong></li>	
	<li>For example, the attributes  <strong class="green prettyprint">licence#</strong> and  <strong class="green prettyprint">employee#</strong> are <strong class="red">prime attribute</strong>s in a relational schema <br><strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong></li>
	<li>For example, the attributes  <strong class="green prettyprint">first-name</strong> and  <strong class="green prettyprint">last-name</strong> are <strong class="red">nonprime attribute</strong>s in a  relational schema <br> <strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 12 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a class="red" href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>			
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 13 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the previous slide we found that there exist functional dependencies such that it is impossible to remove any attribute from the left-hand side and still get a valid functional dependency. For example, licence# ‚Üí employee#, first-name, last-name and  employee# ‚Üí licence#, first-name, last-name belong to such group of functional dependencies. Functional dependency that has such property is call full functional dependency.</p>
	<br/>
	<p>A full functional dependency is a functional dependency X ‚Üí Y such that removal of any attribute A from X causes that (X-A) not ‚Üí Y.</p>
	<br/>
	<p>A partial functional dependency is a functional dependency which is not full functional dependency.</p>
	<br/>
	<p>For example, a functional dependency</p>
	<p>student#, subject#, edate ‚Üí grade</p>
	<p>valid in a relational schema</p>
	<p>ENROLMENT(student#, subject#, edate, grade) </p>
	<p>is a full functional dependency because none of the attributes student#, subject#, edate can be removed from the left hand side of the functional dependency such that it is still valid.</p>
	<br/>
	<p>In another example, a functional dependency</p>
	<p>licence#, employee# ‚Üí first-name, last-name</p>
	<p>valid in a relational schema</p>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<p>is a partial functional dependency because if either licence# or employee# attributes are removed from the left hand side of the functional dependency then it is still valid.</p>
	<br/>
	<p>If a functional dependency X ‚Üí Y is full and if a union of X and Y cover entire relational schema R then X is a minimal key in R.</p>
	<br/>
	<p>For example, a functional dependency</p>
	<p>student#, subject#, edate ‚Üí grade</p>
	<p>valid in a relational schema</p>
	<p>ENROLMENT(student#, subject#, edate, grade) </p>
	<p>is a full functional dependency because none of the attributes student#, subject#, edate can be removed from the left hand side of the functional dependency such that it is still valid.</p>
	<br/>
	<p>For example, a functional dependency</p>
	<p>licence#, employee# ‚Üí first-name, last-name valid in a relational schema </p>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<p>is a partial functional dependency because if either licence# or employee# attributes are removed from the left hand side of the functional dependency then it is still valid.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Full and partial functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">full functional dependency</strong> is a functional dependency <strong class="blue">X &rarr; Y</strong> such that removal of any attribute <strong class="red">A</strong> from <strong class="red">X</strong> causes that <strong class="blue">(X-A) &nrarr; Y</strong>
	</li>
	<li>A <strong class="red">partial functional dependency</strong> is a functional dependency which is not <strong class="blue">full functional dependency</strong></li>
	<li>For example, a functional dependency <br/> <strong class="blue">student#, subject#, edate &rarr; grade</strong> <br> valid in a relational schema <br> <strong class="green prettyprint">ENROLMENT(student#, subject#, edate, grade)</strong> is a <strong class="red">full functional dependency</strong> because none of the attributes  <strong class="blue">student#, subject#, edate</strong> can be removed from the left hand side of the functional dependency such that it is still valid</li>
	<li>For example, a functional dependency <br><strong class="blue">licence#, employee# &rarr; first-name, last-name</strong> valid in a relational schema <strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> <br> is a <strong class="red">partial functional dependency</strong> because if either <strong class="blue">licence#</strong> or <strong class="blue">employee#</strong> attributes are removed from the left hand side of the functional dependency then it is still valid</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 14 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
       <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a class="red" href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 15 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now, we have all concepts required to define the Second Normal Form (2NF) for a relational schema.</p>
	<br/>
	<p>We say that a relational schema R is in the Second Normal Form (2NF) if every nonprime attribute A in R is fully functionally dependent on all minimal keys of schema R.</p>
	<br/>
	<p>So, to verifiy if a relational schema is in 2NF we need to know all its minimal keys and all functional dependencies valid in the schema. The minimal keys provide us with information about prime and nonprime attributes. From a set of functional dependencies valid in a relational schema we can pick full functional dependencies.</p>
	<br/>
	<p>Usually it is more convenient to negate the definition of 2NF and to say that a schema R is not in 2NF if there exists a nonprime attribute that is partially dependent on one of minimal keys, i.e. it is functionally dependent on a proper subset of one of minimal keys.</p>
	<br/>
	<p>As a very simple example consider a relational schema R(A,B,C) and a set of functional dependencies {AB ‚Üí C and A ‚Üí C}. Then, from a functional dependence AB ‚Üí C we can conclude that (AB) is a minimal key. Note that a functional dependence A ‚Üí C does not contribute to a minimal key because it does not cover a schema (A,B,C). Then, the prime attributes are A and B. An attribute C is nonprime. In our case a non prime attribute C functionally dependent on a subset (A) of minimal key (A,B) and because of that it violates 2NF. It is not true that every nonprime attribute  is fully functionally dependent on all minimal keys. Attribute C depends on a subset of a minimal key.</p>
	<br/>
	<p>Typically, 2NF is violated when a minimal key is composite, i.e. it consists of more than one attribute, and one or more of the prime attributes in a minimal key functionally determines a nonprime attribute.</p>
	<br/>
	<p>As a more realistic example consider a relational schema</p>
	<br/>
	<p>INVENTORY(part, quantity, warehouse, warehouse address)</p>
	<br/>
	<p>that contains information about the parts stored in warehouses, quantities of parts, and addresses of warehouse.</p>
	<br/>
	<p>The following functional dependencies are valid  in a relational schema WAREHOUSE:</p>
	<br/>
	<p>warehouse ‚Üí warehouse-address; it means that each warehouse is located at one address, however more than one warehouse can be located at the same address</p>
	<br/>
	<p>part, warehouse ‚Üí quantity; it means that a part located in a warehouse has one quantity information associated with it. In the other words there is only one quantity recorded for each part located in a warehouse.</p>
	<br/>
	<p>First we try to derive a minimal key. To do so we need to find a functional dependency that covers entire schema and such that its left-hand side cannot be reduced. To get two functional dependencies with the same left-hand side we extend left-hand side of  warehouse ‚Üí warehouse-address in the following way: if warehouse ‚Üí warehouse-address then part, warehouse ‚Üí warehouse-address.</p>
	<br/>
	<p>Next, if part, warehouse ‚Üí warehouse-address and part, warehouse ‚Üí quantity then we can apply a union rule to get part, warehouse ‚Üí quantity, warehouse-address. Now, we got a functional dependence that covers entire schema and such that its left-hand side cannot be reduced. Hence, its left-hand size is a minimal key (part, warehouse).</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Second Normal Form (2NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="red">R</strong> is in the <strong class="red">Second Normal Form</strong> (<strong class="red">2NF</strong>) if every nonprime attribute <strong class="red">A</strong> in <strong class="red">R</strong> is fully functionally dependent on all minimal keys of schema <strong class="red">R</strong></li>	
	<li>A relational table based on a relational schema <br><strong class="green prettyprint">INVENTORY(part, quantity, warehouse,warehouse-address)</strong> <br> contains information about parts stored in warehouses, quantities of parts, and addresses of warehouse</li>
	<li>The following functional dependencies are valid in a relational schema <strong class="green prettyprint">INVENTORY(part, quantity, warehouse,warehouse-address)</strong> <br> <strong class="blue">warehouse &rarr; warehouse-address</strong><br> <strong class="blue">part, warehouse &rarr; quantity</strong></li>
	<li>If <strong class="blue">warehouse &rarr; warehouse-address</strong> then <br><strong class="blue">part, warehouse &rarr; warehouse-address</strong></li>
	<li>If <strong class="blue">part, warehouse &rarr; warehouse-address</strong> and <strong class="blue">part, warehouse &rarr; quantity</strong> then <strong class="blue">part, warehouse &rarr; warehouse-address, quantity</strong></li> 
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 16 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>If part, warehouse ‚Üí warehouse-address, quantity then a minimal key is (part, warehouse).</p>
	<br/>
	<p>Now, to fail 2NF we try to find a nonprime attribute (one of: quantity or warehouse-address) that functionally depends on a subset of a minimal key. Indeed an attribute warehouse-address functionally depends on warehouse because each warehouse has one address: warehouse ‚Üí warehouse-address.</p>
	<br/>
	<p>It means that a relational schema</p>
	<br/>
	<p>INVENTORY(part, quantity, warehouse, warehouse-address)</p>
	<br/>
	<p>is not in 2NF because nonprime attribute warehouse-address depends on a part (warehouse) of a key (part, warehouse). A functional dependency that violates 2NF is warehouse ‚Üí warehouse-address. </p>
	<br/>
	<p>An interesting observation is that if all minimal keys in a relational schema consist of only one attribute (single attribute keys) then such schema is always in 2NF. It is impossible to find a nonprime attribute that functionally depends on a subset of a minimal key. It is because a minimal key cannot be empty. Then any nonprime attribute in the schema does not depend on a part of a key because each key consists of one attribute only.</p>
	<br/>
	<p>An interesting question is why a relational schema </p>
	<br/>
	<p>INVENTORY(part, quantity, warehouse, warehouse-address)</p>
	<br/>
	<p>is constructed in an incorrect way. A simple insertion test provides an answer. Try to insert into a relational table with INVENTORY header the following rows:</p>
	<br/>
	<p>[bolt,    20,  XYZ,  Station St 20]</p>
	<br/>
	<p>[screw, 30,  XYZ,  Station St 20]</p>
	<br/>
	<p>[nut,     20,  XYZ,  Station St  20]</p>
	<br/>
	<p>It is quite easy to discover that information about an address Station St 20 of a warehouse XYZ must be repeated as many time as many different types of items are kept in the warehouse. It is because warehouse name  functionally determines warehouse address.</p>
	<br/>
	<p>Another reason why a relational schema INVENTORY is constructed in an incorrect way is such that a relational table with INVENTORY header contains two different types of information: the first, the total number of items of each type in each warehouse and the second, an address of each warehouse.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Second Normal Form (2NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>If  <strong class="blue">part, warehouse &rarr; warehouse-address, quantity</strong> then a minimal key is <strong class="green prettyprint">(part, warehouse)</strong></li>
	<li>A relational schema <br><strong class="green prettyprint">INVENTORY(part, quantity, warehouse,warehouse-address)</strong><br> is not in <strong class="red">2NF</strong> because nonprime attribute <strong class="green prettyprint">warehouse-address</strong> depends on a part (<strong class="green prettyprint">warehouse</strong>) of a key (<strong class="green prettyprint">part, warehouse</strong>)</li>
	<li>A functional dependency that <strong class="red">violates 2NF</strong> is <strong class="blue">warehouse &rarr; warehouse-address</strong></li>
	<li>If all <strong class="red">minimal keys</strong> in a relational schema consist of only one attribute (single attribute keys) then such schema is always in <strong class="red">2NF</strong></li>
	<li>This is because any <strong class="red">nonprime attribute</strong> in the schema does not depend on a part of a key because each key consists of one attribute only</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 17 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>So, what do we do if a relational schema is not in 2NF. eE must decompose it into two or more schemas. In our case a relational schema</p>
	<br/>
	<p>INVENTORY(part, quantity, warehouse, warehouse address)</p>
	<br/>
	<p>must be decomposed into the relational schemas:</p>
	<br/>
	<p>INVENTORY(part, quantity, warehouse)</p>
	<br/>
	<p>WAREHOUSE(warehouse, warehouse-address)</p>
	<br/>
	<p>We simply separate information about the quantities of different types of parts in each warehouse from the addresses of warehouses.</p>
	<br/>
	<p>The decomposition must be performed such that it is possible to join the tables based on the relational schemas obtained after decomposition. In our case an attribute warehouse present in both schemas can be used to formulate a join condition.</p>
	<br/>
	<p>Additionally we try to decompose the schema such that all functional dependencies valid in the original schema are also valid in the decomposed schemas. Note, that it is not always possible to enforce all functional dependencies in the decomposed schemas. If it is possible to enforce a functional dependency in a relational schema then it can be usually done through a primary key constraint that is automatically enforced by a database systems. If a functional dependency cannot be enforced in a decomposed schema that the respective consistency constraint can be still enforce with stored procedures or database triggers. We shall return to this problem later on.</p>
	<br/>
	<p>The following functional dependencies are valid in a relational schema INVENTORY(part, quantity, warehouse)</p>
	<br/>
	<p>part, warehouse ‚Üí quantity</p>
	<br/>
	<p>Hence (part, warehouse) is a minimal key in a new INVENTORY schemas. Because no nonprime attributes are partially dependent on a minimal key the new INVENTORY schema is in 2NF.</p>
	<br/>
	<p>A functional dependency part, warehouse ‚Üí quantity is automatically enforced through a primary key constraint.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Second Normal Form (2NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <br>
	  <strong class="green prettyprint">INVENTORY(part, quantity, warehouse,warehouse address)</strong><br>
	  must be decomposed into the relational schemas<br>
	  <strong class="green prettyprint">INVENTORY(part, quantity, warehouse)</strong><br>
	  <strong class="green prettyprint">WAREHOUSE(warehouse,warehouse-address)</strong></li>
	<li>The following functional dependencies are valid in a relational schema <strong class="green prettyprint">INVENTORY(part, quantity, warehouse)</strong> <br> <strong class="blue">part, warehouse &rarr; quantity</strong></li>
	<li>Hence <strong class="green prettyprint">(part, warehouse)</strong> is a minimal key</li>
	<li>A relational schema <strong class="green prettyprint">INVENTORY(part, quantity, warehouse)</strong> <br> is in <strong class="red">2NF</strong> because a nonprime attribute  <strong class="green prettyprint">quantity</strong> does not depend on a part of key <strong class="green prettyprint">(part, warehouse)</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 18 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The following functional dependencies are valid in the second relational schema </p>
	<p>WAREHOUSE(warehouse, warehouse-address):</p>
	<p>warehouse ‚Üí warehouse-address</p>
	<p>It means that warehouse is a minimal key. It also means that it is impossible to find a nonprime attribute that functionally depends on a part of a key and because of that WAREHOUSE relational schema is in 2NF.</p>
	<br/>
	<p>A functional dependency warehouse ‚Üí warehouse-address is automatically enforced through a primary key constraint.</p>
	<br/>
	<p>Unfortunately, a  relational schema can be in 2NF and still a relational table built over such schema may have a lot of redundancies because a functional dependence enforces the repetition of identical pair of values in the relational table.</p>
	<br/>
	<p>As a simple example consider a relational schema R(A,B,C) with the following functional dependencies valid in the schema:</p>
	<p>A ‚Üí B and B ‚Üí C.</p>
	<br/>
	<p>Then application of a transitivity axiom allows for a derivation: if A ‚Üí B and B ‚Üí C then A ‚Üí C. Application of union rule to</p>
	<p>A ‚Üí B and A ‚Üí C provides A ‚Üí BC. It means that (A) is a minimal key. If (A) is a minimal key then all nonprime attributes B and C are fully functionally dependent on a minimal key and a schema R is in 2NF.</p>
	<br/>
	<p>However, insertion of the following rows to a relational table built over a schema R(A, B, C) reveals a redundancy problem:</p>
	<p>[1, 2, 3]</p>
	<p>[2, 2, 3]</p>
	<p>[3, 2, 3]</p>
	</br>
	<p>The pairs (2,3) are repeated as many times as any value of A is a associated with a value of B equal to 2. Then a functional dependency B ‚Üí C forces a value of C to be equal to 3 and it forces the repetitions of a pair (2,3). It means that the redundancies are still possible in a relatioanal table whose schema is in 2NF.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Second Normal Form (2NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The following functional dependencies are valid in a relational schema <strong class="green prettyprint">WAREHOUSE(warehouse, warehouse-address)</strong> <br> <strong class="blue">warehouse &rarr; warehouse-address</strong></li>
	<li>Hence <strong class="green prettyprint">(warehouse)</strong> is a minimal key</li>
	<li>A relational schema <strong class="green prettyprint">WAREHOUSE(warehouse, warehouse-address)</strong> <br> is in <strong class="red">2NF</strong> because a nonprime attribute  <strong class="green prettyprint">warehouse-address</strong> does not depend on a part of key <strong class="green prettyprint">(warehouse)</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 19 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	 <li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a class="red" href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>					
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 20 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In order to find a new correctness criterion for relational schemas we introduce a concept of "transitive functional dependency"</p>
	<br/>
	<p>A functional dependency X ‚Üí Y valid in a relational schema R is a transitive functional dependency if there exists a nonempty subset Z of R, that is not a subset of any key in R and such that the functional dependencies X ‚Üí Z and Z ‚Üí Y are valid in R.</p>
	<br/>
	<p>As a simple example consider a relational schema</p>
	<br/>
	<p>DEPARTMENT(department-name, project-title, employee#)</p>
	<br/>
	<p>and assume that each employee works on one project and each project is implemented by one department. It means that the following functional dependencies are valid in a relational schema DEPARTMENT:</p>
	<br/>
	<p>employee# ‚Üí project-title; each employee works on one project and</p>
	<br/>
	<p>project-title ‚Üí department-name; each project is implemented by one department.</p>
	<br/>
	<p>Then a functional dependency employee# ‚Üí department-name is a transitive functional dependency because there exists a set of attributes (project-title) such that employee# ‚Üí project-title and project-title ‚Üí department-name. It means that it is possible to derive a functional dependency dependency employee# ‚Üí department-name using a transitivity rule over a set of attributes (project-title) not included in any minimal key.</p>
	<br/>
	<p>As another example consider a relational schema</p>
	<br/>
	<p>DRIVER(licence#, employee#, first-name, last-name)</p>
	<br/>
	<p>and assume that a driving licence is granted to only one employee and each employee has one first name. It means that the following functional dependencies are valid in a relational schema DRIVER:</p>
	<br/>
	<p>licence# ‚Üí employee#; a driving licence is granted to one employee and</p>
	<br/>
	<p>employee# ‚Üí first-name; each employee has one first name</p>
	<br/>
	<p>Then a functional dependency licence# ‚Üí first-name can be derived through application of transitivity axiom to licence# ‚Üí employee# and employee# ‚Üí first-name. However, in this particular case an attribute employee# is minimal key in a relational schema DRIVER. An attribute employee# violates a definition of a transitive functional dependency and because of that a functional dependency</p>
	<p>licence# ‚Üí first-name  is not transitive.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Transitive functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A functional dependency  <strong class="blue">X &rarr; Y</strong> valid  in a  relational schema <strong class="red">R</strong> is a <strong class="red">transitive functional dependency</strong>  if there exists a nonempty subset <strong class="red">Z</strong> of <strong class="red">R</strong>, that is not a subset of any key in <strong class="red">R</strong> and such that the functional dependencies <strong class="blue">X &rarr; Z</strong> and <strong class="blue">Z &rarr; Y</strong> are valid in <strong class="red">R</strong></li>
	<li>For example, if the functional dependencies <br> <strong class="blue">employee# &rarr; project-title</strong> and <strong class="blue">project-title &rarr; department-name</strong><br> are valid in a relational schema <br> <strong class="prettyprint green">DEPARTMENT(department-name, project-title, employee#)</strong> <br> then a functional dependency <strong class="blue">employee# &rarr; department-name</strong> is a <strong class="red">transitive functional dependency</strong></li>
	<li>For example, if the functional dependencies <br><strong class="blue">licence# &rarr; employee#</strong> and <strong class="blue">employee# &rarr; first-name</strong> <br> are valid in a relational schema <br><strong class="green prettyprint">DRIVER(licence#, employee#, first-name, last-name)</strong> <br> then a functional dependency <strong class="blue">licence# &rarr; first-name</strong> is <strong class="red">not</strong> a <strong class="red">transitive functional dependency</strong></li>
	<li>It is because (<strong class="green prettyprint">employee#</strong>) is a key in a relational schema <strong class="green prettyprint">DRIVER</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 21 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>We say that "Y is transitively dependent on X" in a schema R if X ‚Üí Y is valid in R and X ‚Üí Y is a transitive functional dependency.</p>
	<br/>
	<p>As an example consider a relational schema </p>
	<br/>
	<p>TRIP(trip#, licence#, employee#)</p>
	<br/>
	<p>where the following functional dependencies are valid in the schema:</p>
	<br/>
	<p>trip# ‚Üí licence#; a trip is performed by one driver</p>
	<br/>
	<p>licence# ‚Üí employee#; a driving licence is granted to one employee and</p>
	<br/>
	<p>employee# ‚Üí licence#; and employee has one driving licence.</p>
	<br/>
	<p>Then it is possible to apply a transitivity axiom in the following way: if trip# ‚Üí licence# and licence# ‚Üí employee# then we can derive trip# ‚Üí employee#. An attribute licence# is not included in a minimal key (trip#) and because of that a functional dependence</p>
	<p>trip# ‚Üí employee# is transitive. It means that an attribute employee# is transitively dependent on an attribute trip#.</p>
	<br/>
	<p>In the same way it is possible to show that an attribute licence# is transitively dependent on an attribute trip#. If trip# ‚Üí employee# and employee# ‚Üí licence# then trip# ‚Üí licence#. An attribute employee# is not included in a minimal key (trop#) and because of that a functional dependence trip# ‚Üí licence## is transitive. It means that an attribute licence# is transitively dependent on an attribute trip#.</p>
	<br/>
	<p>A relational schema</p>
	<br/>
	<p>TRIP(trip#, licence#, employee#)</p>
	<br/>
	<p>is constructed in an incorrect way because information about a licence# of a driver with a given employee# is listed as many times as many times a trip is performed by the driver. For example, if a driver performed 100 trips then his/her licence# is listed together with his/her employee# 100 times.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Transitive functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>We say that <strong class="red">Y is  transitively dependent on X</strong> in a schema <strong class="red">R</strong> if <strong class="blue">X &rarr; Y</strong> is valid in <strong class="red">R</strong> and <strong class="blue">X &rarr; Y</strong> is a <strong class="red">transitive functional dependency</strong></li>
	<li>For example, if the functional dependencies <br> <strong class="blue">trip# &rarr; licence#</strong>, <strong class="blue">licence# &rarr; employee#</strong>, and <strong class="blue">employee# &rarr; licence#</strong> are valid in a relational schema <strong class="prettyprint green">TRIP(trip#, licence#, employee#)</strong> <br> then an attribute  <strong class="prettyprint green">employee#</strong> is <strong class="red">transitively dependent</strong> on an attribute  <strong class="prettyprint green">trip#</strong> and ...</li>
	<li> ... an attribute  <strong class="prettyprint green">licence#</strong> is <strong class="red">transitively dependent</strong> on an attribute  <strong class="prettyprint green">trip#</strong></li>
	<li>Then, information about a <strong class="prettyprint green">licence#</strong> of a driver with a given <strong class="prettyprint green">employee#</strong> is listed as many times as the total number of trips performed by the driver</li>
	<li>For example, if a driver performed 100 trips then his/her  <strong class="prettyprint green">licence#</strong> is listed together with his/her  <strong class="prettyprint green">employee#</strong> 100 times.</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 22 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Consider a relational schema:</p>
	<br/>
	<p>OUTLINE(lecturer, subject, textbook)</p>
	<br/>
	<p>such that a textbook is used for only one subject and a subject is taught by one lecturer. It means that the following functional dependencies are valid in a schema OUTLINE:</p>
	<br/>
	<p>textbook ‚Üí subject; a textbook is used for one subject</p>
	<br/>
	<p>subject ‚Üí lecturer; a subject is taught by one lecturer.</p>
	<br/>
	<p>Then, it is possible to derive a functional dependency textbook ‚Üí lecturer using transitivity axiom in the following way:</p>
	<br/>
	<p>if textbook ‚Üí subject and subject ‚Üí lecturer then textbook ‚Üí lecturer.</p>
	<br/>
	<p>A minimal key in a schema OUTLINE is (textbook). Because an attribute subject is not included in a minimal key then an attribute lecturer is transitively dependent on an attribute textbook.</p>
	<br/>
	<p>Then, information about a lecturer assigned to a subject is repeated as many times as many textbooks are listed for the subject.</p>
	<br/>
	<p>For example, if a subject has 2 textbooks then information about a lecturer assigned to a subject is listed twice.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Transitive functional dependencies</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>For example, if the functional dependencies <br> <strong class="blue">textbook &rarr; subject</strong> and <strong class="blue">subject &rarr; lecturer</strong> are valid in a relational schema <strong class="prettyprint green">OUTLINE(lecturer, subject, textbook)</strong> <br> then an attribute  <strong class="prettyprint green">lecturer</strong> is <strong class="red">transitively dependent</strong> on an attribute  <strong class="prettyprint green">textbook</strong></li>
	<li>Then, information about a <strong class="prettyprint green">lecturer</strong> assigned to a <strong class="prettyprint green">subject</strong> is repeated as many times as many <strong class="prettyprint green">textbook</strong>s are listed for the <strong class="prettyprint green">subject</strong></li>
	<li>For example, if a <strong class="prettyprint green">subject</strong> has 2 <strong class="prettyprint green">textbook</strong>s then information about a <strong class="prettyprint green">lecturer</strong> assigned to a <strong class="prettyprint green">subject</strong> is listed twice</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 23 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
         <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	 <li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a class="red" href="#23">Third Normal Form (3NF)</a></li>
	<li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 24 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The definitions of transitive functional dependencies and the attributes being functionally dependent on other attributes allow us to look the first definition of the Third Normal Form (3NF).</p>
   <br/>
  <p>Definition of 3NF</p>
  <br/>
  <p>A relational schema R is in the Third Normal Form (3NF) if it is in 2NF and no nonprime attribute of R is transitively dependent on the primary key.</p>
  <br/>
  <p>We start from an application of the 3NF definition to a simple example studied at the end of 2NF section where the functional dependencies  A ‚Üí B and B ‚Üí C are valid in a relational schema R(A,B,C). Then a minimal key can be derived through application of transitivity axiom A ‚Üí B and B ‚Üí C  provide A ‚Üí C and later on union rule A ‚Üí B and A ‚Üí C provide A ‚Üí BC. Hence (A) is a minimal key.</p> 
  <br/>
  <p>Now when testing 3NF definition we find that a nonprime attribute C is transitively dependent on the primary/minimal key (A). It means that 3NF does not hold in the schema R(A,B,C).</p>
  <br/>
  <p>Now, we look at more realistic example. Assume that  relational table based on a relational schema (header)</p>
  <br/>
  <p>SUPPLIER(s#, sname, company-name, city)
  <br/>
  <p>contains information about suppliers working for a company located in a given city.</p> 
  <br/>

  <p>Then the following functional dependencies are valid in a relational schema SUPPLIER(s#, sname, company-name, city)</p>
  <br/>
  <p>s# ‚Üí sname ; each supplier has one name</p>
  <br/>
  <p>s# ‚Üí company-name ; each supplier belongs to one company</p>
  <br/>
  <p>s# ‚Üí city ; each supplier lives in one city</p>
  <br/>
  <p>company-name ‚Üí city ; each company is located in one city</p>
  <br/>
  <p>If we apply a union rule to the first the functional dependencies with the left-hand side s# then we can derive a functional dependency</p>
  <br/>
  <p>s# ‚Üí sname, company-name, city. The functional dependency  cover entire schema SUPPLIER and it is left-hand side is minimal. It means that the left hand size (s#) is a minimal key.</p>  
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="red">R</strong> is in the <strong class="red">Third Normal Form</strong> (<strong class="red">3NF</strong>) if it is in <strong class="red">2NF</strong> and no <strong class="blue">nonprime attribute</strong> of <strong class="red">R</strong> is <strong class="red">transitively dependent</strong> on the primary key</li>	
	<li>A relational table based on a relational schema <br><strong class="green prettyprint">SUPPLIER(s#, sname, company-name, city)</strong> <br> contains information about suppliers working for a company located in a given city</li>
	<li>The following functional dependencies are valid in a relational schema <strong class="green prettyprint">SUPPLIER(s#, sname, company-name, city)</strong> <br> <strong class="blue">s# &rarr; sname</strong><br> <strong class="blue">s# &rarr; company-name</strong><br><strong class="blue">s# &rarr; city</strong><br><strong class="blue">company-name &rarr; city</strong></li>
	<li>A primary key in a relational schema <strong class="green prettyprint">SUPPLIER</strong> is (<strong class="green prettyprint">s#</strong>) because <br><strong class="blue">s# &rarr; sname, company-name, city</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 25 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	  <p>A set of functional dependencies give above includes two functional dependencies consistent with a transitivity pattern explained earlier:</p>
	  <br/>
      <p>s# ‚Üí company-name</p> 
	  <br/>
      <p>company-name ‚Üí city</p>
	  <br/>
      <p>Application of the transitivity axiom provides a functional dependency s# ‚Üí city. It is a transitive functional dependency because an attribute company-name is not included. If it is so then and attribute city is transitively dependent on a primary/minimal key. At the end it leads to a conclusion that a relational schema SUPPLIER is not in 3NF.</p>
      <br/>
      <p>If a relational a schema SUPPLIER is not in 3NF then it contributes to the redundancies in a relational table built on a schema (header) INVENTORY. We can apply an insertion test to show the redundancies. We insert information about 3 suppliers working for the same company:</p>
      <br/>
	  <p>7 James, MI6, London</p>
	  <br/>
      <p>6 Harry, MI6, London</p>
	  <br/>
      <p>5 Robin, MI6, London</p>
	  <br/>
      <p>A functional dependency company-name ‚Üí city forces the repetitions of a pair [MI6, London] as many times as many suppliers work for a company MI6.</p>
       <br/>
      <p>It is interesting that a relational schema SUPPLIER is in the Second Normal Form (2NF) because each nonprime attribute sname, company-name, and city is fully functionally dependent on a primary key (s#)</p>
      <br/>
	 <p>s# ‚Üí sname</p>
	 <br/>
      <p>s# ‚Üí company-name</p>
	  <br/>
      <p>s# ‚Üí city</p>
      <br/>
      <p>It is yet another evidence that 2NF is not sufficient to completely eliminate the redundancies.</p>
	  <br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li> A relational schema <strong class="green prettyprint">SUPPLIER</strong> is <strong class="red">not</strong> in the <strong class="red">Third Normal Form</strong> (<strong class="red">3NF</strong>) because an attribute <strong class="green prettyprint">city</strong> is transitively dependent on a primary key (<strong class="green prettyprint">s#</strong>)</li>
	<li>An attribute <strong class="green prettyprint">city</strong> is transitively dependent on a primary key (<strong class="green prettyprint">s#</strong>) because <br> <strong class="blue">s# &rarr; company-name</strong> and <strong class="blue">company-name &rarr; city</strong></li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIER</strong> is in the <strong class="red">Second Normal Form</strong> (<strong class="red">2NF</strong>) because each noprime attribute <strong class="green prettyprint">sname</strong>,<strong class="green prettyprint">company-name</strong>, and <strong class="green prettyprint">city</strong> is fully functionally dependent on a primary key (<strong class="green prettyprint">s#</strong>)<br><strong class="blue">s# &rarr; sname</strong><br> <strong class="blue">s# &rarr; company-name</strong><br><strong class="blue">s# &rarr; city</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 26 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	  <p>To avoid the redundancies we must separate information about the suppliers from information about the locations of the companies.</p>
     <br/>
	 <p>to do so, a relational schema</p> 
	 <br/>
      <p>SUPPLIER(s#, sname, company-name, city)</p>
	  <br/>
      <p>should be decomposed into the relational schemas</p>
	  <br/>
      <p>SUPPLIER(s#, sname, company-name)</p>
	  <br/>
      <p>COMPANY(company-name, city)</p>
	  <br/>
      <p>Does such decomposition solves the problem ?</p>
      <br/>
      <p>A new relational schema</p> 
	  <br/>
      <p>SUPPLIER(s#, sname, company-name)</p>
	  <br/>
      <p>is in 3NF because no attribute is transitively dependent on a primary key (s#)</p>
	  <br/>
      <p>s# ‚Üí sname</p>
	  <br/>
      <p>s# ‚Üí company-name</p>
	  <br/>
      <p>This time the decomposition "eliminated" a functional dependency company-name ‚Üí city that forced the repetitions of a company-name and a city where a company is located.</p>
      <br/>
      <p>A new relational schema</p>
      <br/>	  
      <p>COMPANY(company-name, city)</p>
	  <br/>
      <p>is in 3NF because no nonprime attribute is transitively dependent on a primary key (company-name)</p>
	  <br/>
      <p>company-name ‚Üí city</p>
      <br/>
	  <p>Please note again, that the decomposition must be done such that it is later on possible to join the relational tables with the headers SUPPLIER and COMPANY. A column company-name is common to both relational tables. The functional dependencies are enforced through primary keys in the relational tables, primary key (s#) in a new SUPPLIER and company-name in COMPANY. Additionally and attribute company-name in a relational table with a header SUPPLIER is a foreign key referencing primary key in a relational table with a header COMPANY.</p>
        <br/>       
	 </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, sname, company-name, city)</strong><br> should be decomposed into the relational schemas <br> <strong class="green prettyprint">SUPPLIER(s#, sname, company-name)</strong> <br>
	  <strong class="green prettyprint">COMPANY(company-name, city)</strong></li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, sname, company-name)</strong><br> is in <strong class="red">3NF</strong> because no attribute is transitively dependent on a primary key (<strong class="green prettyprint">s#</strong>)<br> <strong class="blue">s# &rarr; sname</strong><br> <strong class="blue">s# &rarr; company-name</strong></li>
	<li>A relational schema <strong class="green prettyprint">COMPANY(company-name, city)</strong><br> is in <strong class="red">3NF</strong> because no nonprime attribute is transitively dependent on a primary key (<strong class="green prettyprint">company-name</strong>) <br> <strong class="blue">company-name &rarr; city</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 27 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	  <p>Like for 2NF a relational schema that consists of only 2 attributes (a relational table with only 2 columns) is always in 3NF no matter what attributes are included in the schema.</p>
      <br/>
      <p>We shall prove it by enumerating all possible configurations of nontrivial functional dependencies: no functional dependencies, one functional dependency, two functional dependencies.</p>
       <br/>
      <p>We start from a case where a relational schema R(a,b) has no nontrivial functional dependencies. Then, a minimal key can be derived from a trivial functional dependency ab ‚Üí ab. Hence a minimal key is (ab) and no nonprime attribute is transitively dependent on a minimal key (a, b). It is because there are no nonprime attributes. It means that a relational schema R(a,b) is in 3NF.</p>
      <br/>
      <p>In the second case we assume that only one nontrivial functional dependency is valid in the relational schema: a ‚Üí b (a case where b ‚Üí a is the same). Then, a minimal key is (a) and no nonprime attribute is transitively dependent on a minimal key key (a).  It means that a relational schema R(a,b) is in 3NF.</p>
        <br/>
	 </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Any relational schema that consists of at most 2 attributes is always in <strong class="red">3NF</strong></li>
	<li>Let <strong class="red">R(a,b)</strong> be a relational schema such that no notrivial functional dependencies are valid in <strong class="red">R</strong></li>
	<li>Then (<strong class="green prettyprint">a, b</strong>) is a primary key in <strong class="red">R</strong> and ... </li>
	<li> ... no nonprime attribute is transitively dependent on a primary key <br/> (<strong class="green prettyprint">a, b</strong>)</li>
	<li>Let <strong class="red">R(a,b)</strong> be a relational schema such that a functional dependency <br/> <strong class="blue">a &rarr; b</strong> is valid in <strong class="red">R</strong></li>
	<li>Then (<strong class="green prettyprint">a</strong>) is a primary key in <strong class="red">R</strong> and ... </li>
	<li> ... no nonprime attribute is transitively dependent on a primary key  (<strong class="green prettyprint">a</strong>)</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 28 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the third case we assume that two nontrivial functional dependencies are valid in the relational schema: a ‚Üí b and b ‚Üí a. Then we have two minimal keys (a) and (b). Again, no nonprime attribute is transitively dependent on either (a) or (b) because there are no nonprime attributes. Hence the schema R(a,b) is in 3NF.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R(a,b)</strong> be a relational schema such that the functional dependencies <strong class="blue">a &rarr; b</strong> and <strong class="blue">b &rarr; a</strong> are valid in <strong class="red">R</strong></li>
	<li>Then either (<strong class="green prettyprint">a</strong>) is a primary key in <strong class="red">R</strong> or (<strong class="green prettyprint">b</strong>) is a primary key in <strong class="red">R</strong> and ... </li>
	<li> ... no nonprime attribute is transitively dependent on either (<strong class="green prettyprint">a</strong>) or (<strong class="green prettyprint">b</strong>) </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 29 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now, we consider an alternative definition of 3NF.  Such definition is useful to explain the differences between 3NF and BCNF. An alternative definition of 3NF is equivalent to the original one base on a concept of transitively dependent attributes.</p>
	<br/>
	<p>Accordingly to an alternative definition a relational schema R is in the Third Normal Form (3NF) if whenever a functional dependency X ‚Üí A is valid in R then either </p>
	<br/>
	<p>(i) X is a superkey in R or</p>
	<br/>
	<p>(ii) A is a prime attribute in R</p>
	<br/>
	<p>It is important to note that a relational schema is in 3NF if ONE of TWO conditions is satisfied. There is no need for both of them to be satisfied. For example, if the first condition fails, i.e.  X is not a superkey in R then we still have the "second chance" where A is a prime attribute in R.</p>
	<br/>
	<p>For example we use an alternative definition to show that a relational schema</p>
	<br/>
	<p>SUPPLIER(s#, sname, company-name, city) with the following valid functional dependecies:</p>
	<br/>
	<p>s# ‚Üí sname</p>
	<br/>
	<p>s# ‚Üí company-name</p>
	<br/>
	<p>s# ‚Üí city</p>
	<br/>
	<p>company-name ‚Üí city</p>
	<br/>
	<p>is not in 3NF.</p>
	<br/>
	<p>We have already found that a minimal key is equal to (s#). Then, a condition(i) is satisfied for the first 3 functional dependencies. However, a functional dependency company-name ‚Üí city fails a condition (i) because its left-hand side is not superkey in SUPPLIER. We still have the second chance; condition (ii). Unfortunately, condition (ii) fails as well, because  right-hand side city of </p>
	<p>company-name ‚Üí city is not a prime attribute in SUPPLIER.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Alternative definition of the <strong class="red">Third Normal Form</strong></li>
	<li>A relational schema <strong class="red">R</strong> is in the <strong class="red">Third Normal Form</strong> (<strong class="red">3NF</strong>) if whenever a functional dependency <strong class="blue">X &rarr; A</strong> is valid in <strong class="red">R</strong> then either ...
	  <ul class="build">
	    <li><strong class="red">X</strong> is a superkey in <strong class="red">R</strong>  or</li>
	    <li><strong class="red">A</strong> is a prime attribute in <strong class="red">R</strong></li>
	  </ul>
	</li>
	<li>For example, a relational schema <br> <strong class="green prettyprint">SUPPLIER(s#, sname, company-name, city)</strong> <br> <strong class="blue">s# &rarr; sname</strong><br> <strong class="blue">s# &rarr; company-name</strong><br><strong class="blue">s# &rarr; city</strong><br><strong class="blue">company-name &rarr; city</strong><br> is <strong class="red">not</strong> in <strong class="red">3NF</strong> because ...</li>
	<li>... if we consider a functional dependency <strong class="blue">company-name &rarr; city</strong> then ...
	  <ul class="build">
	    <li>an atribute <strong class="green prettyprint">company-name</strong> is not a superkey and</li>
	    <li>an attribute <strong class="green prettyprint">city</strong> is not a prime attribute</li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 30 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the next example we consider a relational schema</p>
	<br/>
	<p>LOCATION(city, street, zipcode) </p>
	<br/>
	<p>and the following functional dependencies valid in the schema:</p>
	<br/>
	<p>city, street ‚Üí zipcode; a street in a city cannot be split over two or more zipcodes</p>
	<br/>
	<p>zipcode ‚Üí city ; each zip code is associated with only one city</p>
	<br/>
	<p>are valid in a relational schema LOCATION(city, street, zipcode)</p>
	<br/>
	<p>The schema has two minimal keys:</p>
	<br/>
	<p>(city, street) sthat comes directly from a functional dependecy: city, street ‚Üí zipcode</p>
	<br/>
	<p>and </p>
	<br/>
	<p>(zipcode, street) that comes from application of augmentation axiom to zipcode ‚Üí city ==> zipcode, street ‚Üí city, street.</p>
	<br/>
	<p>A relational schema LOCATION(city, street, zipcode) is in 3NF because:</p>
	<br/>
	<p>(i) the left hand side of city, street ‚Üí zipcode is a superkey and</p>
	<br/>
	<p>(ii)the left side of zipcode ‚Üí city is not a superkey but ... the right hand side (city) of zipcode ‚Üí city is a prime attribute.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>For example, if the functional dependencies <br> <strong class="blue">city, street &rarr; zipcode</strong> <br> <strong class="blue">zipcode &rarr; city</strong> <br> are valid in a relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> <br> then the schema has two minimal keys</li>
	<li>(<strong class="green prettyprint">city</strong>, <strong class="green prettyprint">street</strong>)<br> Directly implied by a functional dependency <strong class="blue">city, street &rarr; zipcode</strong></li>
	<li>(<strong class="green prettyprint">zipcode</strong>, <strong class="green prettyprint">street</strong>)<br> If <strong class="blue">zipcode &rarr; city</strong> then <strong class="blue">zipcode, street &rarr; city, street</strong></li>
	<li>A relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> is in <strong class="red">3NF</strong> because
	  <ul class="build">
	    <li>the left hand side of  <strong class="blue">city, street &rarr; zipcode</strong> is a superkey and </li>
	    <li>the left side of <strong class="blue">zipcode &rarr; city</strong> is not a superkey but ...  the right hand side (<strong class="green prettyprint">city</strong>) of <strong class="blue">zipcode &rarr; city</strong> is a prime attribute</li>
	  </ul>
	</li>	  
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 31 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Unfortunately, it is possible to find a relational table with a header LOCATION(city, street, zipcode) and such that its contents is redundant:</p>
	<br/>
	    <pre class="prettyprint">
+------+--------+---------+	      
| city | street | zipcode |
+------+--------+---------+
|  NY  |   55   |   484   |
|  NY  |   56   |   484   |
|  LA  |   55   |   473   |
|  LA  |   56   |   473   |
|  LA  |   57   |   474   |    
+------+--------+---------+</pre>	<br/>
	<p>In the table above a pair [city, zipcode] is repeated as many time as many streets in the city has the same zipcode. For example, a pair [NY, 484] is repeated twice because the table contains information about two streets 55, and 56 with the same zipcode 484. A pair [LA,473] is repeated twice because of two streets 55, 56 having the same zip code 473.
</p>
	<br/>
	<p>A discovery of a redundant relational table that is in 3NF means that 3NF is not the highest form required.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Third Normal Form (3NF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The following relational table created over a relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> is redundant
	  <ul class="build">
	    <pre class="prettyprint" data-lang="3NF relational table">
+------+--------+---------+	      
| city | street | zipcode |
+------+--------+---------+
|  NY  |   55   |   484   |
|  NY  |   56   |   484   |
|  LA  |   55   |   473   |
|  LA  |   56   |   473   |
|  LA  |   57   |   474   |    
+------+--------+---------+</pre>
          </ul>
        </li>
	<li>because the repetitions of <strong class="green prettyprint">| LA ... 473 |</strong> and <strong class="green prettyprint">| NY ... 484 |</strong> are forced by a functional dependency <strong class="blue">zip-code &rarr; city</strong></li>
	<li>It means that <strong class="red">3NF</strong> is not the highest normal form required !</li>	  
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 32 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	<li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">Third Normal Form (3NF)</a></li>
	<li><a class="red" href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a href="#37">Normalization of relational schemas</a></li>			
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 33 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A definition of correctness stronger than 3NF is a definition of Boyce-Codd Normal Form(BCNC). A definition of BCNF says that a relational schema R is in the Boyce-Codd Normal Form (BCNF) if whenever a functional dependency X ‚Üí A is valid in R then X is a superkey in R.</p>
	<br/>
	<p>The definition of BCNF is stronger than a definition of 3NF because it does not allow for the second option when the right-hand side of a functional dependency is a prime.</p>
	<br/>
	<p>For example, if the functional dependencies</p>
	<br/>
	<p>city, street ‚Üí zipcode</p>
	<br/>
	<p>zipcode ‚Üí city</p>
	<br/>
	<p>are valid in a relational schema LOCATION(city, street, zipcode) then as we found earlier, the schema has two minimal keys:</p>
	<br/>
	<p>(city, street) and (zipcode, street)</p>
	<br/>
	<p>Then, a relational schema LOCATION is not in BCNF because the left side of zipcode ‚Üí city is not a superkey.</p>
	<br/>
	<p>Note, that a functional dependency forced the repetitions of the pairs [zip-code, city] in a relational table that has a header LOCATION(city, street, zipcode).  Lack of the second option in a definition of BCNF eliminates the chances for the redundant pairs [zip-code, city].</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Boyce-Codd Normal Form (BCNF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="red">R</strong> is in the <strong class="red">Boyce-Codd Normal Form</strong> (<strong class="red">BCNF</strong>) if whenever a functional dependency <strong class="blue">X &rarr; A</strong> is valid in <strong class="red">R</strong> then 
	  <ul class="build">
	    <li><strong class="red">X</strong> is a superkey in <strong class="red">R</strong></li>
	  </ul>
	</li>
	<li><strong class="red">Boyce-Codd Normal Form</strong> is more restrictive because its definition does not give the "second chance"
	  <ul class="build">
	    <li><strong class="red">A</strong> is a prime attribute in <strong class="red">R</strong></li>
	  </ul>
	</li>
	<li>For example, if the functional dependencies <br> <strong class="blue">city, street &rarr; zipcode</strong> <br> <strong class="blue">zipcode &rarr; city</strong> <br> are valid in a relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> then the schema has
two minimal keys <br>
(<strong class="green prettyprint">city</strong>, <strong class="green prettyprint">street</strong>) and (<strong class="green prettyprint">zipcode</strong>, <strong class="green prettyprint">street</strong>)</li>
	<li>Then, a relational schema <strong class="prettyprint green">LOCATION</strong> is not in <strong class="red">BCNF</strong> because
	  <ul class="build">
	    <li>the left side of <strong class="blue">zipcode &rarr; city</strong> is not a superkey</li>
	  </ul>
	</li>	  	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 34 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In order to get BCNF relational schemas, a relational schema LOCATION(city, street, zipcode) must be decomposed into the schemas:</p>
	<br/>
	<p>SZ(street, zipcode)</p>
	<br/>
	<p>CZ(city, zipcode)</p>
	<br/>
	<p>A relational schema SZ(street, zipcode) has no valid nontrivial functional dependencies. Then, its minimal key is</p>
	<br/>
	<p>(street, zipcode)</p>
	<br/>
	<p>A relational schema SZ(street, zipcode) is in BCNF because does not exist a functional dependency whose left hand side is not a superkey.</p>
	<br/>
	<p>It means that wevery relational schema that has no valid nontrivial functional dependencies is in BCNF. In the future we shall find that such property is a starting point for yet another normal form.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Boyce-Codd Normal Form (BCNF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> <br> should be decomposed into the relational schemas<br> <strong class="green prettyprint">SZ(street, zipcode)</strong> <br> <strong class="green prettyprint">CZ(city, zipcode)</strong></li>
	<li>A relational schema <strong class="green prettyprint">SZ(street, zipcode)</strong> has no valid nontrivial functional dependencies</li>
	<li>A minimal key in a relational schema <strong class="green prettyprint">SZ(street, zipcode)</strong> is <br>(<strong class="green prettyprint">street, zipcode</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">SZ(street, zipcode)</strong> is in <strong class="red">BCNF</strong> because  does not exist a functional dependency whose left hand side is not a superkey</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 35 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A functional dependency zipcode ‚Üí city is valid in a relational schema</p>
	<br/>
	<p>CZ(city, zipcode)</p>
	<br/>
	<p>It is why a minimal key in a relational schema CZ(city, zipcode) is (zipcode). A relational schema CZ(city, zipcode) is in BCNF because the left hand of functional dependency zipcode ‚Üí city is a superkey (zipcode).</p>
	<br/>
	<p>Like in 2NF and 3NF every relational schema, which consists of at most 2 attributes (so called "binary" relational schema) is always in BCNF. It is possible to prove it in the same way as we proved it before for 3NF.</p>
	<br/>
	<p>It is interesting that in this case normalization to BCNF "costs" a functional dependency city, street ‚Üí zipcode that can not be enforced through primary key or candidate key constraints on the decomposed relational schemas. It is because the attributes city and street are in two different relational schemas. It is a "price" we pay for elimination of redundancies in this case. It is why sometimes we may wish to stay at 3NF level and trade the enforcement of functional dependencies for redundancies.</p>
	<br/>
	<p>Additional 3NF reduces fine granulation of the relational schemas eliminating the needs for join operation in SELECT statement when a query asks about association of the values from city and street columns. Elimination of join operation supports better performance of query processing.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Boyce-Codd Normal Form (BCNF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A functional dependency <strong class="blue">zipcode &rarr; city</strong> is valid in a relational schema <br><strong class="green prettyprint">CZ(city, zipcode)</strong></li>
	<li>A minimal key in a relational schema <strong class="green prettyprint">CZ(city, zipcode)</strong> is <br>(<strong class="green prettyprint">zipcode</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">CZ(city, zipcode)</strong> is in <strong class="red">BCNF</strong> because the left hand of functional dependency  <strong class="blue">zipcode &rarr; city</strong> is a superkey (<strong class="green prettyprint">zipcode</strong>)</li>
	<li>Every relational schema, which consists of at most 2 attributes is always in <strong class="red">BCNF</strong></li>
	<li>Normalization to <strong class="red">BCNF</strong> "costs" a functional dependency <strong class="blue">city, street&rarr; zipcode</strong></li>
	<li>It means that it is impossible to enforce the functional dependency <br> <strong class="blue">city, street&rarr; zipcode</strong> <br>
	  with a primary key or candidate key constraints of <strong class="blue prettyprint">CREATE TABLE</strong> statement</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 36 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The following relational tables are created through decomposition of a relational schema LOCATION(city, street, zipcode) into the relational schemas SZ(street, zipcode) and CZ(city, zipcode):</p>
	<br/>
	<pre class="prettyprint" data-lang="A value of system initialization variable 'slow_query_log'">
         LOCATION                      SZ                    CZ
    +------+--------+---------+   +--------+---------+  +------+---------+	      
    | city | street | zipcode |   | street | zipcode |  | city | zipcode |
    +------+--------+---------+   +--------+---------+  +------+---------+
    |  NY  |   55   |   484   |   |   55   |   484   |  |  NY  |   484   |
    |  NY  |   56   |   484   |   |   56   |   484   |  |  LA  |   473   |
    |  LA  |   55   |   473   |   |   55   |   473   |  |  LA  |   474   |
    |  LA  |   56   |   473   |   |   56   |   473   |  +------+---------+
    |  LA  |   57   |   474   |   |   57   |   474   | 
    +------+--------+---------+   +--------+---------+ 
</pre>
	<p>A functional dependency city, street ‚Üí zipcode cannot be enforced in the relational tables SZ and CZ.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Boyce-Codd Normal Form (BCNF)</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The following relational tables are created through decomposition of a relational schema <strong class="prettyprint green">LOCATION(city, street, zipcode)</strong> into the relational schemas <strong class="green prettyprint">SZ(street, zipcode)</strong> and <strong class="green prettyprint">CZ(city, zipcode)</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Decomposition into BCNF tables">

LOCATION                      SZ                    CZ
+------+--------+---------+   +--------+---------+  +------+---------+	      
| city | street | zipcode |   | street | zipcode |  | city | zipcode |
+------+--------+---------+   +--------+---------+  +------+---------+
|  NY  |   55   |   484   |   |   55   |   484   |  |  NY  |   484   |
|  NY  |   56   |   484   |   |   56   |   484   |  |  LA  |   473   |
|  LA  |   55   |   473   |   |   55   |   473   |  |  LA  |   474   |
|  LA  |   56   |   473   |   |   56   |   473   |  +------+---------+
|  LA  |   57   |   474   |   |   57   |   474   | 
+------+--------+---------+   +--------+---------+ 
	    </pre>
          </ul>
        </li>
	<li>A functional dependency <strong class="blue">city, street &rarr; zipcode</strong> cannot be enforced in the relational tables <strong class="green prettyprint">SZ</strong> and <strong class="green prettyprint">CZ</strong></li>	  
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 37 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database normalization</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">First Normal Form (1NF)</a></li>
	<li><a href="#5">Keys</a></li>
	<li><a href="#8">Functional dependencies and keys</a></li>
	<li><a href="#10">Attributes</a></li>
	<li><a href="#12">Full and partial functional dependencies</a></li>
	 <li><a href="#14">Second Normal Form (2NF)</a></li>	
	<li><a href="#19">Transitive functional dependencies</a></li>
	<li><a href="#23">FThird Normal Form (3NF)</a></li>
	 <li><a href="#32">Boyce-Codd Normal Form (BCNF)</a></li>
	<li><a class="red" href="#37">Normalization of relational schemas</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 38 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Assume that we would like to normalize a relational schema R. Normalization of relational schemas, i.e. bringing the schemas to BCNF consists of the following steps:</p>
	<br/>
	<p>(1) First, we identify all functional dependencies valid in a relational schema R to be normalized. It is a difficult step that requires good understanding of a database domain represented by the contents of a relational table with a header R. A mistake at this stage may propagate to the next steps and it may completely destroy the correctness of entires process. For example, a missing functional dependency may by mistake validate a relational schema in BCNF while the schema would not be even in 2NF. Correct identification of the functional dependencies valid in a relational schema requires very good knowledge of the database domain.</p>
	<br/>
	<p>(2) Next, we use the functional dependencies to derive all minimal keys. It is a step where the Armstrong axioms and other derivation rules are used to derive functional dependencies that cover entire relational schema and such that their left-hand sides are minimal. Then, the left hand-sides of such functional dependencies become the minimal keys.</p>
	<br/>
	<p>(3) Next, we use the functional dependencies and minimal keys to identify the highest normal form satisfied by a relational schema R. Such verification can be done either from 2NF towards BCNF or from BCNF towards 2NF.</p>
	<br/>
	<p>(4) Finally, if a relational schema R is not in BCNF we decompose it into the relational schemas in BCNF (optionally 3NF). Decomposition should preserve as many  nontrivial functional dependencies as it is possible. It also must be possible to restore the original relational table from the components obtained after the decomposition.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Normalization of relational schemas</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Let <strong class="red">R = ( A<sub class="subscript">1</sub>, ..., A<sub class="subscript">n</sub>)</strong> be a relational schema (a header of relational table)</li>
        <li>Normalization of a relational schema <strong class="red">R</strong> is performed in the following way
	  <ul class="build">
	    <li>Identify all functional dependencies valid in a relational schema <strong class="red">R</strong></li>
	    <li>Use the functional dependencies to derive all minimal keys</li>
	    <li>Use the functional dependencies and minimal keys to identify the highest normal form  satisfied by a relational schema <strong class="red">R</strong></li>
	    <li>Decompose a relational schema <strong class="red">R</strong> into the relational schemas in <strong class="red">BCNF</strong> (<strong class="red">3NF</strong>)</li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 39 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>We apply a procedure explained in the previous slide to normalize a relational schema:</p>
	<br/>
	<p>SHIPMENT(s#, city, status, p#, quantity)</p>
	<br/>
	<p>A relational table with a header SHIPMENT(s#, city, status, p#, quantity) contains information about suppliers (s#), locations of suppliers (city), status of each city (status, for example big, small, capital, etc) parts shipped by each supplier (p#) and total quantity of parts shipped so far (quantity)</p>
	<br/>
	<p>Analysis of a database domain leads to identification of the following functional dependencies valid in a relational schema SHIPMENT:</p>
	<br/>
	<p>s# ‚Üí city; each supplier is located in one city</p>
	<br/>
	<p>s# ‚Üí status; each supplier is associated with on status of a city</p>
	<br/>
	<p>city ‚Üí status; each city has one status</p>
	<br/>
	<p>s#,p# ‚Üí quantity; if a supplier (s#) supplies part with a given part number (p#) then only one cumulative quantity is recorded for all shipments of suhc part.</p>
	<br/>
	<p>s#,p# ‚Üí city; this functional dependency can be derived from s# ‚Üí city.</p>
	<br/>
	<p>s#,p# ‚Üí status this functional dependency can be derived from s# ‚Üí status.</p>
	<br/>
	<p>The last three functional dependencies can be simplified into on functional dependency: s#,p# ‚Üí quantity, city, status. Such functional dependecy covers entire schema and with left-hand side minimal, it contributes to a minimal key (s#,p#).</p>
	<br/>
	<p>A functional dependency breaks 2NF because a nonprime attribute city functionally depends on a subset (s#) of a minimal key (s#,p#). So, relational schema SHIPMENT(s#, city, status, p#, quantity) is not in 2NF because a nonprime attribute city depends on a subset of a minimal key (s#, p#), s# ‚Üí city.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Normalization of relational schemas</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>For example, consider a relational schema <br/> <strong class="green prettyprint">SHIPMENT(s#, city, status, p#, quantity)</strong></li>
        <li>The following functional dependencies are valid in the schema</li>
	<li><strong class="blue">s# &rarr; city</strong><br>
	  <strong class="blue">s# &rarr; status</strong><br>
	  <strong class="blue">city &rarr; status</strong><br>
	  <strong class="blue">s#, p# &rarr; quantity</strong><br>
	  <strong class="blue">s#, p# &rarr; city</strong><br>
	  <strong class="blue">s#, p# &rarr; status</strong></li>
	<li>A minimal key is (<strong class="green prettyprint">s#, p#</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">SHIPMENT(s#, city, status, p#, quantity)</strong> is <strong class="red">not</strong> in <strong class="red">2NF</strong> because a nonprime attribute <strong class="green prettyprint">city</strong> depends on a subset of a minimal key  (<strong class="green prettyprint">s#, p#</strong>), <strong class="blue">s# &rarr; city</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 40 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A decomposition of a relational schema SHIPMENT that preserves the functional dependencies is the following:</p>
	<br/>
	<p>SP(s#, p#, quantity)</p>
	<br/>
	<p>s#,p# ‚Üí quantity. It immediately provides a minimal key (s#,p#). </p>
	<br/>
	<p>SUPPLIER(s#, city, status)</p>
	<br/>
	<p>s# ‚Üí city</p>
	<br/>
	<p>s# ‚Üí status</p>
	<br/>
	<p>city ‚Üí status</p>
	<br/>
	<p>The first two functional dependencies can be simplified to s# ‚Üí city, status</p>
	<br/>
	<p>A relational schema SP(s#, p#, quantity) is in BCNF because s#, p# ‚Üí quantity, i.e. left hand side of the functional dependency is a superkey.</p>
	<br/>
	<p>A relational schema SUPPLIER(s#, city, status) is not in 3NF because an attribute status is transitively dependent on an attribute s#, i.e. s# ‚Üí city and</p>
	<br/>
	<p>s# ‚Üí status.</p>
	<br/>
	<p>It is also possible to use an alternative definition of 3NF in the following way: a relational schema SUPPLIER(s#, city, status) is not in 3NF because left hand side of functional dependency city ‚Üí status is not a superkey and right hand side is not prime attribute.</p>
	<br/>
	<p>A relational schema SUPPLIER is in 2NF because no nonprime attribute functionally depends on a subset of  a minimal key. It means that a relational schema SUPPLIER must be further decomposed into the schemas in BCNF.</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue">Normalization of relational schemas</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="green prettyprint">SHIPMENT(s#, city, status, p#, quantity)</strong> should be decomposed into the relational schemas <br> <strong class="green prettyprint">SP(s#, p#, quantity)</strong> with a minimal key (<strong class="green prettyprint">s#, p#</strong>)<br>
	<strong class="green prettyprint">SUPPLIER(s#, city, status)</strong> with a minimal key (<strong class="green prettyprint">s#</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">SP(s#, p#, quantity)</strong> is in <strong class="red">BCNF</strong> because  <br> <strong class="blue">s#, p# &rarr; quantity</strong>, i.e. left hand side of the functional dependency is a superkey</li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, city, status)</strong> is <strong class="red">not</strong> in <strong class="red">3NF</strong> because an attribute <strong class="green prettyprint">status</strong> is transitively dependent on an attribute <strong class="green prettyprint">s#</strong>, i.e. <strong class="blue">s# &rarr; city</strong> and <br><strong class="blue">s# &rarr; status</strong><br></li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, city, status)</strong> is <strong class="red">not</strong> in <strong class="red">3NF</strong> because left hand side of functional dependency <strong class="blue">city &rarr; status</strong> is not a superkey and right hand side is not prime attribute</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 41 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A relational schema </p>
	<br/>
	<p>SUPPLIER(s#, city, status) can be decomposed into the relational schemas:</p>
	<br/>
	<p>SUPPLIERCITY(s#, city) where s# ‚Üí city and it means that (s#) is a minimal key and</p>
	<br/>
	<p>LOCATION(city, status) where city ‚Üí status and it means that (city) is a minimal key.</p>
	<br/>
	<p>A relational schema SUPPLIERCITY(s#, city) is in BCNF because s# ‚Üí city, i.e. left hand side of the functional dependency is a superkey. the same applies to a relational schema LOCATION. A relational schema LOCATION(city, status) is in BCNF because  because city ‚Üí status, i.e. left hand side of the functional dependency is a superkey.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Normalization of relational schemas</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, city, status)</strong> should be decomposed into the relational schemas <br> <strong class="green prettyprint">SUPPLIERCITY(s#, city)</strong> with a minimal key (<strong class="green prettyprint">s#</strong>)<br>
	<strong class="green prettyprint">LOCATION(city, status)</strong> with a minimal key (<strong class="green prettyprint">city</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIERCITY(s#, city)</strong> is in <strong class="red">BCNF</strong> because  <br> <strong class="blue">s# &rarr; city</strong>, i.e. left hand side of the functional dependency is a superkey</li>
	<li>A relational schema <strong class="green prettyprint">LOCATION(city, status)</strong> is in <strong class="red">BCNF</strong> because <br> <strong class="blue">city &rarr; status</strong>, i.e. left hand side of the functional dependency is a superkey</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 42 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Note that a relational schema SUPPLIER(s#, city, status)can be decomposed in a different way into the schemas in BCNF. The other way enforces the functional dependencies:</p>
	<br/>
	<p>s# ‚Üí city and</p>
	<br/>
	<p>s# ‚Üí status</p>
	<br/>
	<p>However, it does not enforce a functional dependency city ‚Üí status because such functional dependency cannot be derived from s# ‚Üí city, s# ‚Üí status. In the previous decomposition we enforced:</p>
	<br/>
	<p>s# ‚Üí city and</p>
	<br/>
	<p>city ‚Üí status.</p>
	<br/>
	<p>Then, a functional dependency s# ‚Üí status can be always derived from s# ‚Üí city, city ‚Üí status and when both functional dependencies are enforced then s# ‚Üí status is automatically enforced.</p>
	<br/>
	<p>A relational schema SUPPLIER(s#, city, status) can be alternatively decomposed into the relational schemas:</p>
	<br/>
	<p>SUPPLIERCITY(s#, city) with a minimal key (s#)</p>
	<br/>
	<p>SUPPLIERSTAT(s#, status) with a minimal key (s#)</p>
	<br/>
	<p>A relational schema SUPPLIERCITY(s#, city) is in BCNF because</p>
	<br/>
	<p>s# ‚Üí city, i.e. left hand side of the functional dependency is a superkey</p>
	<br/>
	<p>A relational schema SUPPLIERSTAT(s#, status) is in BCNF because</p>
	<br/>
	<p>s# ‚Üí status, i.e. left hand side of the functional dependency is a superkey</p>
	<br/>
	<p>In order to automatically enforce a functional dependency city ‚Üí status we have to implement either implement a stored procedure/function that verifies the functional dependency or implement a trigger that fires after each update or insertion on the relational tables. So, it is an additional complication in the design.</p>
	<br/>
	<p>An interesting question is in what circumstances the second decomposition would be preferable over the first one ? Consider a query that finds associations between the values of attributes s# and status, for example, what is a status of a city where a given supplier lives in ? In the first design, to implement such query, we must join the tables build over the relational schemas SUPPLIER and  SUPPLIERCITY. In the second design it is enough to access a relational table built over a relational schema SUPPLIERSTAT. It means that processing of such query would be much faster than in the first. If we would like to improve performance of some database applications it is possible to re-structure a database such that processing of selected applications is faster.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Normalization of relational schemas</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A relational schema <strong class="green prettyprint">SUPPLIER(s#, city, status)</strong> can be alternatively decomposed into the relational schemas <br> <strong class="green prettyprint">SUPPLIERCITY(s#, city)</strong> with a minimal key (<strong class="green prettyprint">s#</strong>)<br>
	<strong class="green prettyprint">SUPPLIERSTAT(s#, status)</strong> with a minimal key (<strong class="green prettyprint">s#</strong>)</li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIERCITY(s#, city)</strong> is in <strong class="red">BCNF</strong> because  <br> <strong class="blue">s# &rarr; city</strong>, i.e. left hand side of the functional dependency is a superkey</li>
	<li>A relational schema <strong class="green prettyprint">SUPPLIERSTAT(s#, status)</strong> is in <strong class="red">BCNF</strong> because <br> <strong class="blue">s# &rarr; status</strong>, i.e. left hand side of the functional dependency is a superkey</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 43 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>T. Connoly, C. Begg, Database Systems, A Practical Approach to Design, Implementation, and Management, Chapter 14.5 The Process of Normalization, Chapter 14.6 First Normal Form (1NF), Chapter 14.7 Second Normal Form (2NF), Chapter 14.8 Third Normal Form (3NF), Chapter 14.9 General definitions of 2NF and 3NF, Chapter 15.2 Boyce-Codd Normal Form (BCNF) Pearson Education Ltd, 2015</li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>


</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/EitECANpDDtGpMY5T9SUTs?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>

