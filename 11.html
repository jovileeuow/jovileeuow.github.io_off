<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/gY7dCVAROOC1yR03HzglrF?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
-->
<!DOCTYPE html>
<html>
<head>
  <title>11IntroductionToTransactionProcessing(2)</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 
<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside> 
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>Introduction To TransactionProcessing(2)</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
	<li><a class="red" href="#02">Correctness</a></li>	
	<li><a href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a href="#14">Order preserving conflict serializability</a></li>	
	<li><a href="#18">Recoverable executions</a></li>	
	<li><a href="#20">Cascadeless executions</a></li>	
	<li><a href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 03 ================================================================================= -->
<slide>
    <aside class="note">
      <section>
	<p>If we would like to solve a problem of correct execution of concurrent database transactions then we must start from an answer to a question:</p>
	<p>What makes concurrent execution of database transaction incorrect ? or from an answer to a question:</p>
	<p>How do we define a correct concurrent execution of database transactions ?</p>
	<br/>
	<p>To find a correctness criterion for a concurrent execution of database transactions we have to find an execution that is always correct and apply the properties of such execution to a definition of correctness.</p>
	<br/>
	<p>Which concurrent execution is always correct ? If we assume that the transactions are written in a correct way then an execution where the transactions are processed serially (one-by-one) is always correct. Why ? It is because the transactions do not interleave their operations and process all operations one at a time till either commit or rollback operation. So, if a transaction is implemented in a correct way, i.e. a way that does not corrupt a database, then a serial execution of correctly written transactions must be correct. If it is correct than a state of a database after serial processing of database transactions is correct. Hence any concurrent and not serial execution that brings a database to the same state as one of serial executions must be correct. it is how we invented the first definition of correctness fro concurrent execution of database transactions.</p>
	<br/>
	<p>We say that a concurrent execution of database transactions is view serializable (correct) if there exists a possible serial execution of the same set of transactions such that in both executions each transaction reads the same values and the final states of the database are the same. It simply means that in such a case it is impossible to distinguish between the outcomes of a concurrent execution and one of the serial executions.</p>
	<br/>
	<p>Please note that our first definition of correctness does not determine well which serial execution is used to compare with a concurrent execution. We say, any serial execution will do. If a database is brought to the same state and each transaction reads the same data items then it is the same as one of serial execution.</p>
	<br/>
	<p>The final conclusion is such that a concurrent execution of database transactions is correct when it is view serializable.</p>
	<br/>
      </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>What makes concurrent execution of database transaction <strong class="blue">incorrect</strong> ?</li>
	<li>How do we define a <strong class="red">correct</strong> concurrent execution of database transactions ?</li>
        <li>Concurrent execution of database transactions is <strong class="red">view serializable</strong> if there <strong class="blue">exists a possible serial execution of the same set of transactions</strong> such that in both executions each <strong class="blue">transaction reads the same values and the final states of the database are the same</strong></li>
	<li>A concurrent execution of database transactions is <strong class="red">correct</strong> when it is <strong class="red">view serializable</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 04 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>in the next two slides we show how to apply a definition of correctness based on view serialzability to verify correctness of concurrent execution of database transactions.</p>
	<br/>
	<p>Consider a sample concurrent execution of database transactions. We shall show that the execution is view serializable, i.e it is correct accordingly to a definition of correctness based on view serializability.</p>
	<br/>
	<p>To show that a concurrent execution is view serializable we must find at least one serial execution such that a state of a database after concurrent execution is the same as after a serial execution and each transaction in concurrent execution reads the same values as in a serial execution. If only two transactions T1 and T2 are involved in a concurrent execution then only two serial executions are possible: T1 before T2 and T2 before T1.</p>
	<br/>
	<p>We find that both data items x and y are read by a transaction T2 after each one of them was updated by a transaction T1. Such observation suggest verification of a serial order T1 before T2 first. Then both b=read(x) and d=read(y) return the same values as in a concurrent execution. A transaction t2 does not change the contents of a database, hence after a serial processing T1 -> T2 the contents of a database is the same as in a concurrent execution.</p>
	<br/>
	<p>Hence, the execution of database transactions is view serializable because there exists a serial execution of the same transactions (T1-> T2) such that in both executions the transactions read the same values and the final states of the database are the same (see next slide).</p>
	<br/>
	<p>It is interesting that the second serial execution T2 before T1 cannot be used to prove view serializability condition because in such a case a transaction T2 would read different values from the values read n a concurrent execution. But at the end if we find one serial execution that satisfies the conditions of view serializability then it is completely sufficient to claim that a concurrent execution is correct.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">view serializable</strong> execution of database transactions
	   <ul class="build">
	     <pre class="prettyprint" data-lang="Concurrent processing of database transactions">

T1                                        T2</pre> 
	     <pre class="prettyprint">a=read(x)</pre> 
	     <pre class="prettyprint">write(x, a-10)</pre> 
	     <pre class="prettyprint">                                          b=read(x)</pre> 
	     <pre class="prettyprint">c=read(y)</pre> 
	     <pre class="prettyprint">write(y,c+10)</pre> 
	     <pre class="prettyprint">                                          d=read(y)</pre> 
	   </ul>
	</li>
	<li>The execution of database transactions above is <strong class="red">view serializable</strong> because there exists a <strong class="blue">serial execution</strong> of the same transactions such that in both executions the transactions <strong class="blue">read the same values and the final states of the database are the same</strong> (see next slide)</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 05 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>The present slide contains a visualization of a sample serial execution equivalent to a concurrent execution from the previous slide.</p>
	<br/>
	<p>it is important to note that view serializability i.e. correctness of concurrent execution may depend on the contents of a database. two transactions may interleave their operations such that fro one contents of database a concurrent execution would not view serializable while for the other contents of a database the same execution would be view serializable. It is because a definition of view serializability takes under the consideration the contents of a database.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample serial execution equivalent to a concurrent execution from the previous slide
	   <ul class="build">
	     <pre class="prettyprint" data-lang="Concurrent processing of database transactions">

T1                                 T2</pre> 
	     <pre class="prettyprint">a=read(x)</pre> 
	     <pre class="prettyprint">write(x, a-10)</pre> 
	     <pre class="prettyprint">c=read(y)</pre> 
	     <pre class="prettyprint">write(y,c+10)</pre> 
	     <pre class="prettyprint">                                   b=read(x)</pre> 
	     <pre class="prettyprint">                                   d=read(y)</pre> 
	   </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 06 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>A definition of correctness of concurrent execution of database transactions based on a concept of view serializability is based on a very simple assumption saying that serial execution of database transactions must be correct. It is why, it very clearly determine whether a concurrent execution is correct or not. Unfortunately such definition has a serious problem.</p>
	<br/>
	<p>The problem is related to the computational complexity of testing view serializability criterion. If n transactions are involved in concurrent execution then in the worst case we have to check n! serial orders to answer a question about view serializability. It means that verification that concurrent execution of Database transactions is view serializable is NP-complete. It means that it takes to much time to check whether execution of a database operation violates view serializability correctness criterion.</p>
	<br/>
	<p>So we need a more practical correctness criterion.</p>
	<br/>
	<p>A more practical correctness criterion is "conflict serializability". A definition of conflict serializability is the following. A concurrent execution of database transactions is conflict serializable if there exists a possible serial execution of the same set of transactions such that in both executions the order of conflicting operations is the same. Then, concurrent execution of database transactions is correct if it is conflict serializable.</p>
	<br/>
	<p>A definition of conflict serializability is based a concept of conflicting operations.  Which operations are conflicting operations ?</p>
	<br/>
	<p>Two operations are conflicting operations if both access the same data item and one or both of them is write operation. A table given at the bottom of the present slide visualizes a definition of conflicting operations. Two read(x) operations performed on the asme data item x do not conflict because the results of read do not depend on the order of operations. The operations read(x) and write(x) performed by the transactions T1 and t2 respectively provide different results depending on the order of operations. For example, if x = 5 then read(x) and later on write(3,x) returns a result 5different from write(3,x) and later on read(x) (3). The same applies to a pair of operations write(a,x) performed by T1 and later on write(b,x) performed by T2. An order write(b,x) and later on write(a,x) returns a different state of a database.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A problem with <strong class="red">view serializability</strong>
	  <ul class="build">
            <li>Verification that concurrent execution of Database transactions is <strong class="red">view serializable </strong>is <strong class="blue">NP-complete</strong></li>
	    <li>It means that it takes to much time to check whether execution of a database operation violates <strong class="red">view serializability</strong> correctness
criterion</li>
	  </ul>
	</li>
        <li>A more practical correctness criterion is <strong class="red">conflict serializability</strong>
	  <ul class="build">
            <li>Concurrent execution of database transactions is <strong class="red">conflict serializable</strong> if there exists a possible serial execution of the same set of transactions such that in both executions <strong class="blue">the order of conflicting operations</strong> is the same</li>
	  </ul>
	</li>
	<li>Which operations are <strong class="red">conflicting operations</strong> ?</li>
	<li>Two operations are <strong class="red">conflicting operations</strong> if both <strong class="blue">access the same data item</strong> and one or both of them is <strong class="green prettyprint">write</strong> operation
	<ul class="build">
	     <pre class="prettyprint" data-lang="Conflicting operations">                        read                  write</pre> 
	     <pre class="prettyprint">           read         NO                    YES</pre> 
	     <pre class="prettyprint">           write        YES                   YES</pre>
	   </ul>
	</li>
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 07 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>Detection of conflicting operations  in a concurrent execution of of database transactions is quite simple. Atv least one of the operations must be write(a,x) and both operations must act on the same data item. hence the following pairs of operations are conflicting: <write(a,x), write(b,x)> <write(a,x), read(x)>, <read(x), write(a,x)>.</p>
	<br/>
	<p>In the first example a transaction T1 processed  write(x, a-10) and later on a transaction T2 processed b=read(x). Both operations act on the same data item x and one of them is write. So, the operations are conflicting operations. One more thing that must be done when conflicting operations are identified. We must find an order of conflicting operations. In the present example a transaction T1 executes write(x, a-10) before a transaction T2 executes b=read(x). Hence an order is T1 before T2.</p>
	<br/>
	<p>In the second example it is possible to find two pairs of conflicting operations <T1:a = read(y), T2:write(y,10)> and <T1:write(y,a+10), T2:write(y,10)>. In both cases and order of conflicting operations is the same: T1 before T2.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Conflicting operations</strong> in a sample concurrent execution of transactions
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Conflicting operations">
	      
T1                                 T2</pre> 
	    <pre class="prettyprint">write(x, a-10)</pre>
	    <pre class="prettyprint">                                   b=read(x)</pre>
	  </ul>
	</li>
	<li>The operations <strong class="green prettyprint28">write(x, a-10)</strong> and <strong class="green prettyprint">b=read(x)</strong> are <strong class="red">conflicting operations</strong> because both access the same data item <strong class="green prettyprint">x</strong> and one of them is <strong class="green prettyprint">write</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Conflicting operations">

a=read(y)</pre> 
	    <pre class="prettyprint">write(y,a+10)</pre> 
	    <pre class="prettyprint">                                   write(y,10)</pre> 
	   </ul>
	</li>
	<li>The operations <strong class="green prettyprint">write(y,a+10)</strong> and <strong class="green prettyprint">write(y,10)</strong> are <strong class="red">conflicting operations</strong> because both access the same data item <strong class="green prettyprint">y</strong> and both of them are <strong class="green prettyprint">write</strong>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 08 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>now, when we know how to detect conflicting operations and transaction orderings determined by conflicting operations we canb retrun to a concept of conflict serializability, and correctness of concurrent execution of database transactions.</p>
	<br/>
	<p>We said that concurrent execution of database transactions is conflict serializable (read: "correct") if there exists a possible serial execution of the same set of transactions such that in both executions the order of conflicting operations is the same.</p>
	<br/>
	<p>Let us find whether a sample concurrent execution of the transactions T1 and T2 is conflict serializable (correct).  To do so we have to find the conflicting operations executed by the transactions T1 and T2. We start from the first operation executed by a transaction T1:   a=read(x). Such operation does NOT conflict with     b=read(x) executed by T2 because bothe operations are read and it also does not conflict with d=read(y) because both operations act on different data items and both of them are read.</p>
	<br/>
	<p>Next, an operation  write(x, a-10) executed by T1 conflicts with b=read(x) executed by T2 and an order of conflicting operations is T1 before T2.</p>
	<br/>
	<p>Next, an operation  c=read(y) executed by T1 does not conflict with any operation executed by T2 due to a different data item used ( b=read(x)) and both operations being read operation.</p>
	<br/>
	<p>Next, an operation  write(y,c+10) executed by T1 conflicts only with an operation d=read(y) executed by T2. In this case an order of conflicting operations is again T1 before T2.</p>
	<br/>
	<p>If an order of conflicting operations is T1 before T2 then when the transactions are executed serially T1 and then T2 an order of conflicting operations is the same. I means that we found a serial order of transactions where an order of conflicting operations is the same as in a concurrent execution. It is an evidence that a concurrent execution is conflict serializable (correct).</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Concurrent execution of database transactions is <strong class="red">conflict serializable</strong> if there exists <strong class="blue">a possible serial execution of the same set of transactions</strong> such that in both executions <strong class="blue">the order of conflicting operations is the same</strong></li>
	<li>A sample <strong class="red">conflict serializable</strong> execution of database transactions
	   <ul class="build">
	     <pre class="prettyprint" data-lang="Conflict serializable execution of database transactions">

T1                                    T2</pre> 
	     <pre class="prettyprint">a=read(x)</pre> 
	     <pre class="prettyprint">write(x, a-10)</pre> 
	     <pre class="prettyprint">                                      b=read(x)</pre> 
	     <pre class="prettyprint">c=read(y)</pre> 
	     <pre class="prettyprint">write(y,c+10)</pre> 
	     <pre class="prettyprint">                                      d=read(y)</pre> 
	   </ul>
	</li>
	<li>Order of conflicting operations: <strong class="green prettyprint">T1 before T2</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 09 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>Now, we shall look at a concurrent execution of database transactions that corrupts a database. It is the same execution as presented at the very beginning of the previous presentation to demonstrate that uncontrolled processing of database transactions on shared date may lead to a corrupted database.</p>
	<br/>
	<p>We look at the conflicting operation and the orders of conflicting operations. A transaction T1 executes  a=read(x) and such operation conflicts with write(x,b+20)  executed by a transaction T2. An order of conflicting operations is T1 before T2.</p>
	<br/>
	<p>A transaction T2 executes b=read(x)  and such operation conflicts with write(x,a-10) executed by a transaction T1. In this case and order is T1 before T2.</p>
	<br/>
	<p>Finally an operation  write(x,a-10) executed by T1 conflicts with write(x,b+20) executed by T2. An order of conflicting operations is T1 before T2.</p>
	<br/>
	<p>We got two orders of conflicting operations T1 before T2 and T2 before T1. It is impossible to find a serial execution of T1 and T2 such that it would satsfy both orders of conflicting operations. It means that does not exists a serial order of execution where order of conflicting operations is the same as in a concurrent execution and because of that a concurrent execution is not conflict serializable. It is not correct.</p>
	<br/>
	<p>Order of conflicting operations: T1 before T2 and T2 before T1 means that it is impossible to serialize the concurrent execution of T1 and T2 It means that the concurrent execution of database transactions T1 and T2 is incorrect.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Correctness</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">not conflict serializable</strong> execution of database transactions
	   <ul class="build">
	     <pre class="prettyprint" data-lang="Not cconflict serializable execution of database transactions">

T1                          T2                    x: $100</pre> 
	     <pre class="prettyprint">a=read(x)                                         x: $100 a: $100</pre> 
	     <pre class="prettyprint">                            b=read(x)             x: $100 a: $100 b: $100</pre> 
	     <pre class="prettyprint">write(x,a-10)                                     x: $90  a: $100 b: $100</pre> 
	     <pre class="prettyprint">                            write(x,b+20)         x: $120 a: $100 b: $100</pre> 
	     <pre class="prettyprint">                            commit                x: $120 a: $100 b: $100</pre> 
	     <pre class="prettyprint">commit                                            x: $120 a: $100 b: $100</pre>
	   </ul>
	 </li>
        <li>Order of conflicting operations: <strong class="green prettyprint">T1 before T2</strong>  and <strong class="green prettyprint">T2 before T1</strong> means that it is  <strong class="red">impossible to serialize</strong> the concurrent execution of <strong class="green prettyprint">T1</strong> and <strong class="green prettyprint">T2</strong></li>
	<li>It means that the concurrent execution of database transactions <strong class="green prettyprint">T1</strong> and <strong class="green prettyprint">T2</strong> is <strong class="red">incorrect</strong></li>
	   </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 10 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
	<li><a href="#02">Correctness</a></li>	
	<li><a class="red" href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a href="#14">Order preserving conflict serializability</a></li>	
	<li><a href="#18">Recoverable executions</a></li>	
	<li><a href="#25">Cascadeless executions</a></li>	
	<li><a href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 11 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>It is possible to prove that every conflict serializable execution is view serializable.</p>
	<br/>
	<p>On the other hand a view serializable execution may not be conflict serializable. it means that a definition of correctness based on conflict serializability is more restrictive than a definition of correctness based on view serializability,</p>
	<br/>
	<p>A sample concurrent execution of three transactions T1, T2 and T3 visualized on the present slide is not conflict serializable but it is still view serializable.</p>
	<p>The concurrent execution is not conflict serializable because write(x, 10) executed by T1 conflicts with write(x, 20) executed by T2 enforcing an order T1 before T2. An operation write(y,10) executed by T2 conflicts with  a=read(y) executed later by T1 and enforcing an order T2 before T1. Does not exist a serial order of T1 and T2  where T1 is processed before T2 and T2 is processed before T1. Hence the sample execution is not conflict serializable.</p>
	<br/>
	<p>An execution below is view serializable because there exists equivalent serial execution where each transaction reads and writes the same data items, see a trace on the right hand side of a diagram given in the present slide and given in the next slide.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Conflict serializability versus view serializability</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Every <strong class="red">conflict serializable</strong>  execution is <strong class="red">view serializable</strong> </li>
	<li>A <strong class="red">view serializable</strong>  execution <strong class="red">may not be conflict serializable</strong></li>
	<li>An execution below is <strong class="red">view serializable</strong> because there exists equivalent <strong class="blue">serial execution</strong> where each transaction reads and writes the same data items, see next slide
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="View serializable execution of database transactions">

T1                      T2                      T3</pre>
	    <pre class="prettyprint">write(x, 10)                                                     x: 10</pre>
	    <pre class="prettyprint">                        write(x, 20)                             x: 20</pre>     
	    <pre class="prettyprint">                                                 write(x,30)     x: 30</pre>
	    <pre class="prettyprint">                        write(y,10)                              x: 30 y: 10</pre>
	    <pre class="prettyprint">a=read(y)                                                        x: 30 y: 10 a: 10</pre>
	  </ul>
	</li>
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

<!-- slide 12 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>If the transactions T1, T2 and T3 are executed serially in an order T2 before T1 and T1 before T3 then the final state of a database is the same as nin a concurrent execution and each transaction reads the same data items as in a concurrent execution, compare the traces listed on the right hand side of the transaction execution diagrams.</p>
	<br/>
	<p>Hence, the original execution is view serializable, i.e. it is is correct.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Conflict serializability versus view serializability</h2>
    </hgroup>
    <article>
      <ul class= "build">
        <li>Equivalent <strong class="red">serial execution</strong>
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Serial execution of database transactions">

T1                      T2                      T3</pre>
	    <pre class="prettyprint">                        write(x, 20)                            x: 20</pre>
	    <pre class="prettyprint">                        write(y, 10)                            x: 20 y: 10</pre>
	    <pre class="prettyprint">write(x,10)                                                     x: 10 y: 10</pre>
	    <pre class="prettyprint">a=read(y)                                                       x: 10 y: 10 a: 10</pre>
	    <pre class="prettyprint">  		                               write(x,30)      x: 30 y: 10 a: 10</pre>
	  </ul>
	</li>
	<li>Hence, the original execution is <strong class="red">view serializable</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 13 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>However, the original execution is not conflict serializable.</p>
	<br/>
	<p>This is because T1 processes a conflicting operation write(x, 10) before T2 processes write(x,20) and T2 processes a conflicting operation write(y, 10) before T1 processes a=read(y).</p>
	<br/>
	<p>Hence, the execution is not conflict serializable.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Conflict serializability versus view serializability</h2>
    </hgroup>
    <article>
      <ul class= "build">
        <li>However, the original execution is <strong class="red">not conflict serializable</strong>
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Not conflict serializable execution of database transactions">

T1                            T2                            T3</pre>
	    <pre class="prettyprint">write(x, 10)</pre>
	    <pre class="prettyprint">                              write(x, 20)</pre>
	    <pre class="prettyprint">                                                            write(x,30)</pre>
	    <pre class="prettyprint">                              write(y,10)</pre>
	    <pre class="prettyprint">a=read(y)</pre>
	  </ul>
	</li>
	<li>This is because <strong class="green prettyprint28">T1</strong> processes a conflicting operation <strong class="green prettyprint28">write(x, 10)</strong> before <strong class="green prettyprint28">T2</strong> processes <strong class="green prettyprint28">write(x,20)</strong> and <strong class="green prettyprint28">T2</strong> processes a conflicting operation <strong class="green prettyprint28">write(y, 10)</strong> before <strong class="green prettyprint28">T1</strong> processes <strong class="green prettyprint28">a=read(y)</strong></li>
	<li>Hence, the execution is <strong class="red">not conflict serializable</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 14 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
	<li><a href="#02">Correctness</a></li>	
	<li><a href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a class="red" href="#14">Order preserving conflict serializability</a></li>	
	<li><a href="#18">Recoverable executions</a></li>	
	<li><a href="#20">Cascadeless executions</a></li>	
	<li><a href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 15 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>A definition of conflict serializability says that a concurrent execution is conflict serializable if an order of conflicting operations in a concurrent execution is the same as an order of conflicting operations in one of the serial executions. Please note  "...one of..." ! It may happen that due to operating system scheduling of time sharing processing a serial order is different from an order how the transaction started their concurrent execution. Then, if observe an order in which the  transaction started then we may get a pretty confusing observation that the execution order was in fact different. If we assume that certain order of execution is needed to get the desired results than if real serial order is different then we may get undesirable results, still correct accordingly to conflict serialiizability, but not the correct results we wanted. To avoid such problem we strengthen a definition of conflict serializability to order-preserving conflict serializability.</p>
	<br/>
	<p>Concurrent execution of database transactions is order-preserving conflict serializable if it is:</p>
	<p>(1) conflict serializable and</p>
	<p>(2) all non-interleaved transactions have the same order in both original execution and some corresponding serial execution.</p>
	<br/>
	<p>Every order-preserving conflict serializable execution is conflict serializable.</p>
	<br/>
	<p>On the other hand, a conflict serializable execution may not be order-preserving conflict serializable.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Order preserving serializability</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Concurrent execution of database transactions is <strong class="red">order-preserving conflict serializable</strong> if it is
	  <ul class="build">
	    <li>conflict serializable and </li>
	    <li>all non-interleaved transactions have the same order in both original execution and some corresponding serial execution</li>
	  </ul>
	</li>
        <li>Every <strong class="red">order-preserving conflict serializable</strong> execution is <strong class="blue">conflict serializable</strong></li>
	<li>A <strong class="blue">conflict serializable execution</strong> may <strong class="red">not be order-preserving conflict serializable</strong></li>	      
      </ul>
     <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	 <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
 </slide>
<!-- slide 16 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>in the present slide we show a sample conflict serializable and order-preserving serializable execution.</p>
	<br/>
	<p>An order of conflicting operations is T3 (write(y,10)) before T1 (write(y,20)) and T1 (write(x, 10)) before T2 (a=read(x)). Hence it is an order T3 before T1 before T2. Conflict serialization graph is given below the concurrent execution.</p>
	<br/>
	<p>The transactions started in an order T3 -before T1 and T1 before T2.</p>
	<br/>
	<p>Order of transactions indicated by their start timestamps is the same as serialization order (T3 before T1 and T1 before T2). Hence the concurrent execution presented here is an order-preserving conflict serializable execution.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Order preserving serializability</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">conflict serializable</strong> and <strong class="red">order-preserving serializable</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Order-preserving execution of database transactions">

T1                            T2                            T3</pre>
	    <pre class="prettyprint">                                                            write(y,10)</pre>
	    <pre class="prettyprint">write(x, 10)</pre>
	    <pre class="prettyprint">                              a=read(x)</pre>
	    <pre class="prettyprint">write(y,20)</pre>
	  </ul>
	</li>
	<p style="text-align:center;"><img src="images/graph-12.png" width="400" height="100" alt="ORM" title="ORM"></p>
	<li>Order of transactions indicated by their start timestamps is the same as serialization order (<strong class="green prettyprint28">T3</strong> before <strong class="green prettyprint28">T1</strong> and <strong class="green prettyprint28">T1</strong> before <strong class="green prettyprint28">T2</strong>)</li>
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
 </slide>
<!-- slide 17 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>In the present slide we show a sample concurrent execution that is conflict serializable and that is not order-preserving conflict serializable.</p>
	<br/>
	<p>An order of conflict operations is the following T1 (write(x, 10)) before T2 (a=read(x)) and T3 (write(y,10)) before T1 (write(y,20)). It means that order determined by the conflicting operations is T3 before T1 and T1 before T2. Conflict serialization graph is given below the concurrent execution.</p>
	<br/>
	<p>The execution is not order-preserving serializable because order of transactions indicated by their start timestamps (T1 before T2 and T2 before T3) is different from serialization order (T3 before T1 and T1 before T2).</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Order preserving serializability</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">conflict serializable</strong> and <strong class="red">not order-preserving serializable</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Not order-preserving execution of database transactions">

T1                            T2                            T3</pre>
	    <pre class="prettyprint">write(x, 10)</pre>
	    <pre class="prettyprint">                              a=read(x)</pre>
	    <pre class="prettyprint">                                                            write(y,10)</pre>
	    <pre class="prettyprint">write(y,20)</pre>
	  </ul>
	</li>
	<p style="text-align:center;"><img src="images/graph-12.png" width="400" height="100" alt="ORM" title="ORM"></p>
	<li>The execution is <strong class="red">not order-preserving serializable</strong> because order of transactions indicated by their start timestamps (<strong class="green prettyprint28">T1</strong> before <strong class="green prettyprint28">T2</strong> and <strong class="green prettyprint28">T2</strong> before <strong class="green prettyprint28">T3</strong>) is different from serialization order (<strong class="green prettyprint28">T3</strong> before <strong class="green prettyprint28">T1</strong> and <strong class="green prettyprint28">T1</strong> before <strong class="green prettyprint28">T2</strong>)
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 18 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
	<li><a href="#02">Correctness</a></li>	
	<li><a href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a href="#14">Order preserving conflict serializability</a></li>	
	<li><a class="red" href="#18">Recoverable executions</a></li>	
	<li><a href="#20">Cascadeless executions</a></li>	
	<li><a href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 19 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>Transaction manager must provide the all-or-nothing property of transactions even in the presence of various types of failures. It means that if a transaction fails then all modifications performed by such transaction must be reversed. In the other words transaction manager must recover from a failure of a transaction with any impact the state of a database. A failure of a transaction must not corrupt a database.</p>
	<br/>
	<p>As an example where a failure of a transaction  corrupts a database is given in the present slide. A transaction T1 reads data items x and write a new value into data item x.</p>
	<br/>
	<p>Then a transaction T2 reads the same data items x and it writes a new value of data item x and it commits modification of x. When committed such modification cannot be changed. Now, assume that a transaction T1 fails. If T1 fails then all its modifications of a database must be reversed. If a transaction T1 updated data item x first then reversal of its operations bring the original value of data item x. An in such way a modification of x performed by a transaction T2 is lost.</p>
	<br/>
	<p>To avoid lost update due to a failure of a transaction T1 a concurrent execution must enforce a principle of recoverability. A principle of recoverability says that execution is recoverable if every transaction T that reads a data item written by another transaction T’ commits after T’ is committed.</p>
	<br/>
	<p>A principle of recoverability is violated by  the concurrent execution given on the present slide because a transaction T2 reads data item earlier written by a transaction T1 and a transaction T2 commits before a transaction T1 either commits itself or it fails.</p>
	<br/>
	<p>For the concurrent execution to be recoverable a transaction T2 must wait with commit until a transaction T1 commits itself. If T1 fails then T2 must be aborted by a scheduler because T2 read dirty data created by T1. Such situation contributes to cascaded aborts of database transactions. Cascading abort is a negative effect of the protocol because it reverses processing of the transactions that would correctly process themselves otherwise.</p>
	<br/>
	<p>An additional rule must be enforced to avoid cascading aborts.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Recoverable executions</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Transaction manager must provide the all-or-nothing property of transactions even in the presence of <strong class="red">various types of failures</strong></li>
        <li>Execution is <strong class="red">recoverable</strong> if every transaction <strong class="green prettyprint28">T</strong> that reads a data item written by another transaction <strong class="green prettyprint28">T’</strong> commits after <strong class="green prettyprint28">T’</strong> is committed</li>
	<li>A sample <strong class="red">not recoverable</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Not recoverable execution of database transactions">

T1                            T2                             x: $100</pre>
	    <pre class="prettyprint">a=read(x)                                                    x: $100 a: $100</pre>
	    <pre class="prettyprint">write(x,a-10)                                                x: $90  a: $100</pre>
	    <pre class="prettyprint">                              b=read(x)                      x: $90  a: $100 b: $90</pre>
	    <pre class="prettyprint">                              write(x,b+20)                  x: $110 a: $100 b: $90</pre>
	    <pre class="prettyprint">                              commit                         x: $110 a: $100 b: $90</pre>
	    <pre class="prettyprint">abort                                                        x: $100 a: $100 b: $90</pre>
	  </ul>
	</li>
      </ul>
     <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	 <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
 </slide>
 <!-- slide 20 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
	<li><a href="#02">Correctness</a></li>	
	<li><a href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a href="#14">Order preserving conflict serializability</a></li>	
	<li><a href="#20">Recoverable executions</a></li>	
	<li><a class="red" href="#20">Cascadeless executions</a></li>	
	<li><a href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 21 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>To avoid cascading abort a transaction must not read dirty data items, i.e. data items modified by uncommitted transactions. Such principle enforces a "cascadles concurrent execution".</p>
	<br/>
	<p>A concurrent execution is cascadeless if none of the transactions reads data item written by any other transaction that is not committed or aborted.</p>
	<br/>
	<p>A sample cascadeless execution is visualized on the present slide.</p>
	<br/>
	<p>Like before a transaction T1 reads and writes a data item x. Next, a transaction T2 attempts to read a data item x created by a transaction T1. According to cascadeless execution principle a transaction T2 must wait until a transaction T1 commits itself or aborts. If T1 is able to commit all its modifications then T2 is allowed to read and to update a data item x. Otherwise, if T1 fails then it is rolled back, the contents of a data item x returns to its original value  and then T2 is allowed to read and to update it.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Cascadeless executions</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>Execution is <strong class="red">cascadeless </strong>if none of the transactions reads data item written by any other transaction that is not committed or aborted</li>
	<li>A sample <strong class="red">cascadeless</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Cascadeless execution of database transactions">

T1                          T2                             x: $100</pre>
	    <pre class="prettyprint">a=read(x)                                                  x: $100 a: $100</pre>
	    <pre class="prettyprint">write(x,a-10)                                              x: $90  a: $100</pre>
	    <pre class="prettyprint">                            b=read(x) wait                 x: $90  a: $100</pre>
	    <pre class="prettyprint">abort                                                      x: $100 a: $100</pre>
	    <pre class="prettyprint">                            b=read(x)                      x: $100 a: $100 b: $100</pre>	    
	    <pre class="prettyprint">                            write(x,b+20)                  x: $120 a: $100 b: $100</pre>
	  </ul>
	</li>
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 22 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>The execution visualized in the present slide is not a cascadeless execution. A transaction T1 reads and modifies a data items x. Then a transaction T2 reads a new value of data item x and again modifies the new value of data item x. The execution is recoverable and a transaction T2 is not allowed to commit a modification of data item x.</p>
	<br/>
	<p>Now, a transaction T1 fails and it rolled back. A value written by a transaction T1 becomes a dirty data. A transaction T2 used a dirty data written by a transaction T1. If T1 is aborted then a transaction T2 must be aborted creating the first level of potential cascade of aborts. If a transaction T2 modified another data item and such data item has been read by other transactions then a forced abort of a transaction T2 triggers the forced aborts of the other transactions. And so on, and so on.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Cascadeless executions</h2>
    </hgroup>
    <article>
      <ul class= "build">
        <li>A sample <strong class="red">not cascadeless</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Not cascadeless execution of database transactions">

T1                            T2                           x: $100</pre>
	    <pre class="prettyprint">a=read(x)                                                  x: $100 a: $100</pre>
	    <pre class="prettyprint">write(x,a-10)                                              x: $90  a: $100</pre>
	    <pre class="prettyprint">                              b=read(x)                    x: $90  a: $100 b: $90</pre>
	    <pre class="prettyprint">                              write(x,b+20)                x: $110 a: $100 b: $90</pre>
	    <pre class="prettyprint">abort                                                      x: $100         b: $90</pre>
	    <pre class="prettyprint">                              forced abort                 x: $100</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 23 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Introduction to Transaction Processing</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>	
	<li><a href="#02">Correctness</a></li>	
	<li><a href="#10">Conflict serializability versus view serializability</a></li>	
	<li><a href="#14">Order preserving conflict serializability</a></li>	
	<li><a href="#20">Recoverable executions</a></li>	
	<li><a href="#23">Cascadeless executions</a></li>	
	<li><a class="red" href="#23">Strict executions</a></li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 24 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>What if a data item is read and its modified by a transaction T1, and then a transaction T2 overwrites a data item with a new value. Then such execution is still recoverable and it is still cascadeless. But, when a transaction T1 is rolled back then a new value of data item x is again overwritten by old value of data item x (before it has been changed by a transaction T1). It means that the principles of recoverability and cascadeless execution are not strong enough to eliminate the problem.</p>
	<br/>
	<p>We have to add one more principle of so called strict execution.</p>
	<br/>
	<p>We say that an execution is strict if any data item d is written by transaction T then any other transaction cannot either read or write data item d until T is committed or aborted.</p>
	<br/>
	<p>A sample strict execution is visualized in the present slide. A transaction T1 read and later on writes a new value of data item x. Then a transaction T2 attempts to overwrite a data item x with a new value. A strict execution protocol does not allow for such operation and a transaction T2 must wait.</p>
	<br/>
	<p>When a transaction T1 fails and it is rolled back and old value of a data item x is restored. Next, a transaction T2 is allowed to overwrite a data item x with a new value independent on the previous value of the same data item.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Strict executions</h2>
    </hgroup>
    <article>
      <ul class= "build">
        <li>Execution is <strong class="red">strict</strong> if any data item <strong class="green prettyprint28">d</strong> is written by transaction <strong class="green prettyprint28">T</strong> then any other transaction cannot either read or write data item <strong class="green prettyprint28">d</strong> until <strong class="green prettyprint28">T</strong> is committed or aborted</li>
        <li>A sample <strong class="red">strict</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Strict execution of database transactions">

T1                          T2                             x: $100</pre>
	    <pre class="prettyprint">a=read(x)                                                  x: $100 a: $100</pre>
	    <pre class="prettyprint">write(x, a+10)                                             x: $110 a: $100</pre>
	    <pre class="prettyprint">                            write(x,20) wait               x: $110 a: $100</pre>
	    <pre class="prettyprint">abort                                                      x: $100</pre>
	    <pre class="prettyprint">                            write(x,20)                    x: $20</pre>
	    <pre class="prettyprint">                            commit                         x: $20</pre>		   
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  25 ================================================================================= -->
 <slide>
 <aside class="note">
      <section>
    <p>This slide presents a sample concurrent execution that is not scrict.</p>
	<br/>
	<p>A transaction T1 reads a data item x and writes a new value into a data item x.</p>
	<br/>
	<p>Next, a transaction T2 is allowed to write a new value into a data item x.</p>
	<br/>
	<p>If a transaction T1 fails then its rollback overwrites a value written by a transaction T2. An operation T2: write(x,20) is lost from processing of a transaction t2.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Strict executions</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">not strict</strong> execution
	  <ul class= "build">
	    <pre class="prettyprint" data-lang="Not strict execution of database transactions">

T1                          T2                             x: $100</pre>
	    <pre class="prettyprint">a=read(x)                                                  x: $100 a: $100</pre>
	    <pre class="prettyprint">write(x, a+10)                                             x: $110 a: $100</pre>
	    <pre class="prettyprint">                            write(x,20)                    x: $20  a: $100</pre>
	    <pre class="prettyprint">                            commit                         x: $20</pre>
	    <pre class="prettyprint">abort                                                      x  $100</pre>
	  </ul>
	</li>
	<li>Rollback of <strong class="green prettyprint28">T1</strong> destroys committed <strong class="green prettyprint28">T2 :write(x,20)</strong></li>
      </ul>
      <footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
	  <a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide  26 ================================================================================= -->
<slide>
<aside class="note">
      <section>
    <p>This slide summarizes different classes of concurrent executions and relationships between such classes.</p>
	<br/>
	<p>Assume that entire area of the current slide represents all concurrent executions. 
</p>
	<br/>
	<p>Then a grey blob named "View serializable executions" represents all concurrent executions that satisfy view serializability correctness criterion. In the other words all executions that are correct according to a view serializability definition of correctness.</p>
	<br/>
	<p>A light blue blob entirely included in a grey block and named "Conflict serializable executions" represents all concurrent execution that satisfy conflict serializability correctness criterion. In the other words, all concurrent executions that are correct according to conflict serializability definition of correctness.</p>
	<p>Note that if a light blue blob is entirely included in a grey blob then every conflict serializable execution is also view serializable execution. It also means that some of view serializable executions are not correct from conflict serializability  criterion of correctness point of view.</p>
	<br/>
	<p>A darker blue blob named "Order-preserving Conflict serializable executions" represents all concurrent executions that satisfy order-preserving conflict serializability correct ness criterion. Note, that all order-preserving conflict serializable executions are conflct serializable executions. However, there exist conflict serializable executions that are not order preserving.</p>
	<br/>
	<p>A light pink blob named "Recoverable executions" represents all concurrent executions that must enforce recoverability correctness criterion and such that each execution is conflict serializable.  Note, that some of recoverable executions are not order preserving executions. Light pink blob spans over dark blue blob representing  order-preserving  conflict serializable executions and over a light blue blob representing only conflict serializable execution.</p>
	<br/>
	<p>A dark pink blob named "Cascadeless executions" is entirely included in a light pink blob representing "Recoverable executions". It means that every cascadeless execution is a recoverable execution. However, the opposite is not true. Some of the recoverable executions ate not cascadeless.</p>
	<br/>
	<p>Very dark pink blob named "Strict executions" represents all strict executions. Like before, every strict execution is a cascadeless execution and the opposite is not true. All cascadeless and strict executions must be conflict serializable.</p>
	<br/>
	 </section>
    </aside>
    <hgroup>
      <h2 class="blue">Summary</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>
	  <ul class="build">
	    <p style="text-align:center;"><img src="images/executions.png" width="600" height="500"alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
 </slide>
<!-- slide 27 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>T. Connoly, C. Begg, Database Systems, A Practical Approach to Design, Implementation, and Management, Chapter 22.1 Transaction Support, Chapter 22.2 Concurrency Control, Pearson Education Ltd, 2015</li>
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>
<!--
<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/nauYCWLV66CvqWzOHKZrkS?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
-->

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>

