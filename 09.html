<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mah√© <lukem@google.com>

URL: <a href="https://protect-au.mimecast.com/s/G2BnCK1DrrTLWxjQUvJSY-?domain=code.google.com">https://code.google.com/p/io-2012-slides</a>
-->
<!DOCTYPE html>
<html>
<head>
  <title>09DatabaseTriggers</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen"> 

<!-- slide 01 ================================================================================= -->
  <slide class="title-slide segue nobackground">
    <aside class="gdbar">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBAU3014N Database Systems</aside>
    <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
    <hgroup class="auto-fadein">
      <h1 class="black" data-config-title>Database Triggers</h1>
      <h2 class="black" data-config-subtitle><!-- populated from slide_config.json --></h2>
      <p class="black" data-config-presenter><!-- populated from slide_config.json --></p>
    </hgroup>
  </slide>
<!-- slide 02 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a class="red" href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a href="#6">Active database system</a></li>		
	<li><a href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a href="#19">Statement database triggers</a></li>	
	<li><a href="#22">Row database triggers</a></li>	
	<li><a href="#35">Problems with database triggers</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 03 ================================================================================= -->
  <slide>
     <aside class="note">
      <section>
	<p>Stored procedures and stored functions contribute well to re-usability. It is possible to identify a piece of code identical for a number of applications and implement it as a single stored procedure or function. And later on grant the application programmers the right to process a procedure or function stored in a data dictionary. However, we still need to provide an application programmer with information about a name, parameters and functionalities of a stored procedure or function. In many situation an invocation of a stored procedure or function is triggered by an event like for example insertion of a row, update of a table, modification of a consistency constraint in a table and the others. For example, an attempt to insert a row may trigger automatic conversion of string values to uppercase format, or update on a table may trigger automatic recreation of a given report. In all such cases processing of a database is triggered by a well defined event and application programmer does not need to manually perform any actions. To automatically handle the standard responses to well defined event use can use a functionality of a database trigger.</p>
	<br/>
	<p>Database trigger is a piece of code stored in a data dictionary and automatically processed whenever a pre-defined event happens and pre-defined condition is satisfied.</p>
	<br/>
	<p>For example, we would like to automatically increase job level for all employees whose salary is above 100000. It means that whenever an update of a column "salary" happens the system must automatically verify if a new salary is greater than 100000 and if it is so it must invoke a stored procedure "IncreaseJobLevel". A fragment of a pseudo code (and not Oracle's database trigger)  is the following.</p>
	<p>ON UPDATE OF EMPLOYEE.salary</p>
	<p>IF :NEW.salary > 100000 THEN</p>
	<p>IncreaseJobLevel(:NEW.enumber, :NEW.salary);</p>
	<p>END IF;</p>
	<br/>
	<p>In another sample application of database triggers, we would like to implement a data security rule saying that a salary cannot be updated over a weekend. If a day extracted from the current date/time is either Saturday or Sunday a trigger fails togerther with a triggering application. A fragment of pseudocode is given below.</p>
	<p>ON UPDATE OF EMPLOYEE.salary</p>
	<p>IF TO_CHAR(SYSDATE,'Day') IN ('Saturday', 'Sunday') THEN</p>
	<p>RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be updated over a weekend !');</p>
	<p>END IF;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Database trigger ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li><strong class="red">Database trigger</strong> is a piece of code stored in a data dictionary and automatically processed whenever a <strong class="red">pre-defined event</strong> happens and <strong class="red">pre-defined condition</strong> is satisfied</li>
	<li>For example, we would like to automatically increase job level for all employees whose salary is above 100000
         <ul class="build">
	   <pre class="prettyprint" data-lang="Database trigger">
	     
ON UPDATE OF EMPLOYEE.salary
  IF :NEW.salary > 100000 THEN
    IncreaseJobLevel(:NEW.enumber, :NEW.salary);
  END IF;</pre> 
	 </ul> 
	</li>
	<li>For example, we would like to implement a data security rule saying that a salary cannot be updated over a weekend
         <ul class="build">
	   <pre class="prettyprint" data-lang="Database trigger">
	     
ON UPDATE OF EMPLOYEE.salary
  IF TO_CHAR(SYSDATE,'Day') IN ('Saturday', 'Sunday') THEN
    RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be updated over a weekend !');
  END IF;</pre>
	 </ul> 
	</li>	  
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 04 ================================================================================= -->
  <slide>
   <aside class="note">
      <section>
	<p>In a yet another example, we would like to automatically enforce a consistency constraint saying that a department cannot have more than 100 employees. We assume that the total number of employees may increase only due to processing of INSERT statement on EMPLOYEE table. For a sake of simplicity we ignore a fact that an employee can be transferred from one department to another and operation can be implemented with UPDATE statement. So, in this case we consider an attempt to process iNSERT statement on EMPLOYEE table as a triggering effect.</p>
	<br/>
	<p>A pseudo code starts from identification of a triggering event:</p>
	<br/>
	<p>ON INSERT INTO EMPLOYEE</p>
	<br/>
	<p>Then we skip any conditions on processing of a trigger and we find the total number of employees in a department whose name is included in a row to be inserted.</p>
	<p>SELECT COUNT(*)</p>
	<p>INTO total_employees</p>
	<p>FROM EMPLOYEE</p>
	<p>WHERE dname = :NEW.dname;</p>
	<br/>
	<p>If the total number of employee is already equal to 100 then we fail a trigger and and an application that issued INSERT statement on a relational table EMPLOYEE.</p>
	
	<p>IF total_employees = 100 THEN</p>
	<p>RAISE_APPLICATION_ERROR(-20002, 'Too many employees in ' || :NEW.dname);</p>
	<p>END IF;</p>
	<br/>
	<p>In the example above we assume that a trigger fires and it is processed before processing of INSERT statement. Sometimes it is more convenient to fire a trigger that verifies a consistency constraint after modification of a relational table and before COMMIT statement.</p>
	<p>It is why in the real world implementations of database trigger two temporal options are available for invocations of triggers: BEFORE and AFTER.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Database trigger ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>For example, we would like to enforce a consistency constraint saying that a department cannot have more than 100 employees
         <ul class="build">
	   <pre class="prettyprint" data-lang="Database trigger">
	     
ON INSERT INTO EMPLOYEE
  SELECT COUNT(*)
  INTO total_employees
  FROM EMPLOYEE
  WHERE dname = :NEW.dname;             
  IF total_employees = 100 THEN
    RAISE_APPLICATION_ERROR(-20002, 'Too many employees in ' || :NEW.dname);
  END IF;</pre> 
	 </ul> 
	</li>
	<li>In the example above we assume that a  trigger <strong class="red">fires</strong> and it is processed <strong class="red">before</strong> <strong class="blue prettyprint">INSERT</strong> statement</li>
	<li>Sometimes it is more convenient to <strong class="red">fire</strong> a trigger that verifies a consistency constraint <strong class="red">after</strong> modification of a relational table and <strong class="red">before</strong> <strong class="blue prettyprint">COMMIT</strong> statement</li>
	<li>This is why we have two temporal options for triggers: <strong class="blue prettyprint">BEFORE</strong> and <strong class="blue prettyprint">AFTER</strong></li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 05 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A mechanism of database triggers can be used in many different circumstances.</p>
	<br/>
	<p>First, to automatically verify the consistency constraints imposed on the contents of a database. In all such cases there is no need to inform application programmers about necessity to verify consistency constraints. Verification is performed automatically by the triggers.</p>
	<br/>
	<p>In another example we use triggers to enforce the sophisticated database access controls.For example, modification of certain areas in a database can be only performed in a give moment time  and by the users that satisfy appropriate constraints, for example a user must have 5 year of work experience.</p>
	<br/>
	<p>Triggers can be used to implement transparent event logging. For example, we can log selected SQL statements processed on a given subset of a database like all updates of a column salary performed on EMPLOYEE table. Such logs can be later on used for the future performance tuning of a database system.</p>
	<br/>
	<p>Next, triggers can be use to automatically generate the values of derived attributes in relational tables. Derived attribute are the attributes whose values can be computed (derived) from the current contents of a database. For example, the total number of orders submitted by each customer. Sometimes derived attributes are used to speed up processing of database applications  and to avoid processing the same computations again and again. A dark side of derived attributes are redundancies in a database and necessity to keep the values of derived attributes consistent with the current contents of a database. Database triggers can be used to automatically re-compute the values of derived attributes after the modifications on a database.</p>
	<br/>
	<p>If triggers can be use to keep derived data consistent with the present state of a database then it is also possible to use triggers to maintain replicated data in a distributed database. It means that modification of of data in one database automatically triggers modification of replicated data in another database.</p>
	<br/>
	<p>Finally, database triggers can be used to update relational views. A relational view is an virtual relational table defined through SELECT statement. A virtual table consists of rows returned through processing of SELECT statement. A relational view is in materialized in a database and each time it is used in SELECT statement, its name is replaced with its definition through SELECT statement. A relational view can also be an argument of data manipulation statement. In such a case an update on a relational view must be translated into the updates on base tables of relational view, i.e. table used in SELECT statement defining a relational view. Unfortunately, the updates ion the base tables can be done in many different ways to achieve the same update of a relational view. It is simply that function that defines a relational view through SELECT statement does not have unique inverse function. It is why commercial database systems impose very strict constraints on updatablity of relational views.  To avoid such problem a trigger can be created to to determine which inverse function should be used to modify the base tables due to a modification of a relational view. A database trigger fires re3lational view event and its body performs modifications of base tables.</p>
	<br/>
	<p>A class of so called Active Database Systems provide the general functionalities for implementation of database triggers.=</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Database trigger ? What is it ?</h2>
    </hgroup>
    <article>
      <ul class="build">
        <li>What do we need database triggers for ?
	<ul class="build">
	  <li>To verify the consistency constraints</li>
	  <li>To enforce the sophisticated database access controls</li>
	  <li>To implement transparent event logging</li>
	  <li>To generate the values of derived attributes</li>
	  <li>To maintain replicated data in a distributed database</li>
	  <li>To update the relational views</li>
	</ul>
	</li>
	<li><strong class="red">Active Database Systems</strong> provide functionalities for implementation of database triggers</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 06 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a class="red" href="#6">Active database system</a></li>		
	<li><a href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a href="#19">Statement database triggers</a></li>	
	<li><a href="#22">Row database triggers</a></li>	
	<li><a href="#35">Problems with database triggers</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 07 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>What is an Active Database System ?</p>
	<br/>
	<p>Active database system is a database system which is able to detect the events that have happened in a certain period of time and in the response to these events it is able to execute the actions when the pre-defined conditions are met.</p>
	<br/>
	<p>A logic of active database system is implemented as a collection of Event-Condition-Action (ECA) rules. Active database systems are able to detect complex events that consist of sequences of elementary events. Commercial systems restrict event to the single action events like, insert, update, delete, etc.</p>
	<br/>
	<p>In SQL ECA rule can be created with CREATE TRIGGER statement and it can be deleted with DROP TRIGGER statement. Syntax of ECA rule is the following:</p>
	<p>(EVENT, CONDITION, ACTION)</p>
	<br/>
	<p>Semantics of ECA rule is the following:</p>
	<p>Whenever an EVENT happens and a CONDITION is satisfied then a database system automatically performs an ACTION</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Active database system</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Active database system</strong> is a database system which is able to detect the <strong class="blue">events</strong> that have happened in a certain period of time and in the response to these <strong class="blue">events</strong> it is able to execute the <strong class="blue">actions</strong> when
the <strong class="blue">pre-defined conditions</strong> are met</li>
	<li>A logic of active database system is implemented as a collection of <strong class="red">E</strong>vent-<strong class="red">C</strong>ondition-<strong class="red">A</strong>ction (<strong class="red">ECA</strong>)rules</li>
	<li>In SQL <strong class="red">ECA</strong> rule can be created with <strong class="blue prettyprint">CREATE TRIGGER</strong> statement and it can be deleted with <strong class="blue prettyprint">DROP TRIGGER</strong> statement</li>
	<li>Syntax of <strong class="red">ECA rule</strong>:
	<ul class="build">
	  <li>(<strong class="blue prettyprint">EVENT</strong>, <strong class="blue prettyprint">CONDITION</strong>, <strong class="blue prettyprint">ACTION</strong>)</li>
	</ul>
	<li>Semantics of <strong class="red">ECA rule</strong>:
	<ul class="build">
	   <li>Whenever an <strong class="blue prettyprint">EVENT</strong> happens and a <strong class="blue prettyprint">CONDITION</strong> is satisfied then a database system performs an <strong class="blue prettyprint">ACTION</strong></li> 
	  </ul>
	</li>	  
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 08 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A sample event of update on a column "salary" in EMPLOYEE table can be determined as:</p>
	<p>ON UPDATE OF EMPLOYEE.salary</p>
	<br/>
	<p>A sample condition that test a new value of attribute salary included in INSERT statement can be expressed as:</p>
	<p>IF :NEW.salary > 100000</p>
	<p>Note, that :NEW is a variable that contains a new row inserted into a database or a row after updates perfromed on a row.</p>
	<br/>
	<p>A sample action implemented as stored PL/SQL procedure can be expressed as:</p>
	<p>IncreaseJobLevel(:NEW.enumber, :NEW.salary);</p>
	<br/>
	<p>In SQL CREATE OR REPLACE TRIGGER statement implements ECA rule.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Active database system</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">event</strong>
	<ul class="build">
	  <pre class="prettyprint" data-lang="Trigger">ON UPDATE OF EMPLOYEE.salary</pre> 
	  </ul>
	  </li>
	  <li>A sample <strong class="red">condition</strong>
	<ul class="build">
	  <pre class="prettyprint" data-lang="Trigger">IF :NEW.salary > 100000</pre> 
	  </ul>
	  </li>
	  <li>A sample <strong class="red">action</strong>
	<ul class="build">
	  <pre class="prettyprint" data-lang="Trigger">IncreaseJobLevel(:NEW.enumber, :NEW.salary);</pre> 
	  </ul>
	  </li>
	  <li><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement implements <strong class="red">ECA</strong> rule</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 09 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a href="#6">Active database system</a></li>		
	<li><a class="red" href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a href="#19">Statement database triggers</a></li>	
	<li><a href="#22">Row database triggers</a></li>	
	<li><a href="#35">Problems with database triggers</a></li>			
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 10 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>CREATE OR REPLACE TRIGGER statement consists of "temporal option", "event", optional "indicator of row trigger", "condition", "trigger's body". Assume that we would like to create a trigger that fires before any update on a column "budget" in a relational table DEPARTMENT and whenever an update is related to Math department the trigger supposed to check if a new budget is in a range 1..7000. If a new value of budget is not in a range 1..7000 the tigger must fail together with an application that fired the trigger.</p>
	<br/>
	<p>CREATE OR REPLACE TRIGGER statement starts from the keywords "CREATE OR REPLACE TRIGGER" and a name of  a trigger. A name of a trigger is "CheckBudget".</p>
	<p>CREATE OR REPLACE TRIGGER CheckBudget</p>
	<br/>
	<p>A temporal option determines when a trigger fires. In our case a trigger must fire before an update on a value in a column "budget". It is why a temporal option is:</p>
	<p>BEFORE</p>
	<br/>
	<p>As it has been mentioned earlier a trigger fires before an update  on a value in a column "budget"</p>
	<p>UPDATE OF budget ON DEPARTMENT</p>
	<br/>
	<p>An indicator of row trigger is a keyword:</p>
	<p>FOR EACH ROW </p>
	<p>If an indicator of row trigger is missing then a trigger is a statement trigger. A statement trigger fires one time either before or after SQL statement determined in a temporal option. On the other hand, a row trigger fires each time a row is affected by SQL statement determined in a temporal option. The details of all differences between statement and row triggers will be discussed in the future.</p>
	<br/>
	<p>A body of a trigger is processed when validation of a condition returns true. In our case, a trigger is processed only when a budget of Math department is affected by UPDATE statement. It means that value of attribute "name" must be equal to 'Math' in pseudorecord NEW that represent the currently updated row.</p>
	<p>WHEN NEW.name = 'Math'-- NEW </p>
	<br/>
	<p>Whenever a trigger is a row trigger then the pseudorecords OLD and NEW represent a row before it is processed by a triggering SQL statement and a row after it is processed by a triggering statement. If a triggering statement is INSERT then pseudorecord OLD has no value. If a triggering statement is DELETE then pseudorecord NEW has no value. If a triggering statement is UPDATE then OLD represent a row before update and NEW represents a row after UPDATE.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Trigger name">CREATE OR REPLACE TRIGGER CheckBudget</pre>
	  </ul>
	</li>
	<li>Temporal option
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Temporal option specification">

BEFORE</pre>
	  </ul>
	</li>
	<li>Event
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Event specification">

UPDATE OF budget ON DEPARTMENT</pre>
	  </ul>
	</li>
	<li>Type of trigger, either <strong class="red">statement</strong> or <strong class="blue">row</strong> trigger
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Row trigger">

FOR EACH ROW                  -- FOR EACH ROW means that it is a row trigger</pre>
	  </ul>
	</li>
	<li>Condition
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Trigger condition">

WHEN NEW.name = 'Math'        -- NEW is a so called pseudorecord</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 11 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A body of a trigger starts from a keyword:</p>
	<p>BEGIN</p>
	<br/>
	<p>Pseudorecords :OLD and :NEW represents a row before modification or deletion and a row after modification or insertion. A row trigger fires for each row affected by a triggering event. Then if a triggering event is INSERT then a pseudorecord :NEW contains a row to be inserted into a relational table. It allows to perform the operations on such row before it is inserted into a relational table If a triggering event is DELETE then a pseudorecord :OLD contains a row to be deleted from a relational table. If a triggering event is UPDATE then a pseudorecord :OLD contain a row before update and :NE contains a record after UPDATE. Please note that pseudorecords have the names NEW and OLD in WHEN clause and :NEW and :OLD in a body of a trigger.</p>
	<br/>
	<p>Next, a trigger checks if a value in a column budget is not in range between 1 and 7000 after update.</p>
	<br/>
	<p>IF NOT ( :NEW.budget BETWEEN 1 AND 7000 ) THEN</p>
	<br/>
	<p>If the value is not in the range then a call to a procedure RAISE_APPLICATION_ERROR fails a trigger and a database transaction that fired a trigger. As a consequence the trigger enforces a logical consistency constraint restrictin a value in a column budget for Math department to a range 1..7000</p>
	<br/>
	<p>RAISE_APPLICATION_ERROR(-200001, 'Budget of department ' || :NEW.name ||</p>
	<p> ' cannot be equal to ' || :NEW.budget );</p>
	<br/>
	<p>The first argument is a code of a message. A value is negative to get a dash between a prefix ORA and  a number of an error message. All new error message must have code less than -200000.</p>
	<br/>
	<p>The second argument is a message displayed following a code ORA-200001</p>
	<br/>
	<p>END IF;</p>
	<br/>
	<p>A body of a trigger ends with a keyword:</p>
	<br/>
	<p>END;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Beginning of trigger body
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Start of trigger body">

BEGIN</pre>
	  </ul>
	</li>
	<li>Pseudorecords <strong class="blue prettyprint">:OLD</strong> and <strong class="blue prettyprint">:NEW</strong> represent a row before modification or deletion and a row after modification or insertion
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Application of correlation variables in a row trigger">
	      
IF NOT ( :NEW.budget BETWEEN 1 AND 7000 ) THEN</pre>
	  </ul>
	</li>
	<li>Abnormal termination of a trigger together with a transaction that fired a trigger
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Abnormal termination of a trigger">
	      
RAISE_APPLICATION_ERROR(-200001, 'Budget of department ' || :NEW.name ||
                                 ' cannot be equal to ' || :NEW.budget );</pre>
          </ul>
        </li>
	<li>End of trigger body
	  <ul class="build">
	    <pre class="prettyprint" data-lang="End of trigger body">
	      
  END IF;
END;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 12 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Below is a complete CREATE OR REPLACE TRIGGER statement.</p>
	<br/>
	<p>CREATE OR REPLACE TRIGGER CheckBudget</p>
	<p>BEFORE UPDATE OF budget ON DEPARTMENT</p>
	<p>FOR EACH ROW</p>
	<p>WHEN NEW.name = 'Math'</p>
	<p>BEGIN</p>
	<p>IF NOT ( :NEW.budget BETWEEN 1 AND 7000 ) THEN</p>
	<p>RAISE_APPLICATION_ERROR(-200001, 'Budget of department ' || :NEW.name || ' cannot be equal to ' || :NEW.budget );</p>
	<p>END IF;</p>
	<p>END;</p>
	<br/>
	<p>Again note a name of pseudo record NEW in WHEN clause and the same pseudorecord :NEW in IF statement and in an argument of a call of RAISE_APPLICATION_ERROR. </p>
	<br/>
	<p>Again note that. row trigger fires for each row affected by a triggering event. It is why access to pseudorecords :OLD and :NEW is possible in a row trigger. Access to pseudorecords :NEW and :OLD is not possible in a statement trigger.</p>
	<br/>
	</section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A complete <strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample row trigger">
	      
CREATE OR REPLACE TRIGGER CheckBudget
BEFORE UPDATE OF budget ON DEPARTMENT
  FOR EACH ROW                
  WHEN NEW.name = 'Math'
  BEGIN
    IF NOT ( :NEW.budget BETWEEN 1 AND 7000 ) THEN
      RAISE_APPLICATION_ERROR(-200001, 'Budget of department ' || :NEW.name ||
	                               ' cannot be equal to ' || :NEW.budget );
    END IF;
  END;</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 13 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The following temporal options are available for both statement triggers and row triggers:</p>
	<br/>
	<p>BEFORE, AFTER, INSTEAD OF</p>
	<br/>
	<p>When BEFORE temporal option is used a trigger fires before a triggering event.</p>
	<br/>
	<p>When AFTER temporal option is used a trigger fires after a triggering event.</p>
	<br/>
	<p>When INSTEAD OF temporal option is used a trigger fires instead of a triggering event, it is typically used to correctly implement view update operation i.e. a correct modification of base relational tables through an update pefrormed on a relational view.</p>
	<br/>
	<p>Now, we look at few sample applications of temporal options. </p>
	<p>First, we consider an update operation on a column budget and verification of a constraint on budget before a value of budget is changed. In such a case we should fire a trigger before UPDATE operation on a column budget in a relational table DEPARTMENT. Implementation of a temporal option is the following.</p>
	<br/>
	<p>BEFORE UPDATE OF budget ON DEPARTMENT;</p>
	<br/>
	<p>Next, we consider a situation where a consistency constraint must be verified after deletion or update of any row in DEPARTMENT table. To implement verification of a consistency constraint in a body of a trigger we should fire a trigger after any DELETE or UPDATE operation performed on DEPARTMENT table. Impleemnattionn of a temporal option is the following.</p>
	<br/>
	<p>AFTER DELETE OR UPDATE ON DEPARTMENT;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
    <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The following <strong class="red">temporal options</strong> are available
	  <ul class="build">
	    <li><strong class="blue prettyprint">BEFORE</strong> - a trigger fires before a triggering event</li>
	    <li><strong class="blue prettyprint">AFTER</strong> - a trigger fires after a triggering event</li>
	    <li><strong class="blue prettyprint">INSTEAD OF</strong> - a trigger fires instead of a triggering event, it is typically used to correctly implement <strong class="red">view update</strong> operation i.e. a correct modification of <strong class="blue">base relational tables</strong> through an update performed on a <strong class="blue">relational view</strong></li>
	  </ul>
	</li>
	<li>Sample applications of <strong class="red">temporal options</strong></li>
	<li>Fire a trigger before <strong class="blue prettyprint">UPDATE</strong> operation on a column <strong class="blue prettyprint">budget</strong> in a relational table <strong class="blue prettyprint">DEPARTMENT</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample temporal option">

BEFORE UPDATE OF budget ON DEPARTMENT</pre>
	  </ul>
	</li>
	<li>Fire a trigger after any <strong class="blue prettyprint">DELETE</strong> or <strong class="blue prettyprint">UPDATE</strong> operation performed on <strong class="blue prettyprint">DEPARTMENT</strong> table
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample temporal option">

AFTER DELETE OR UPDATE ON DEPARTMENT</pre>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 14 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Assume that we created a relational view EMPVIEW as projection of a base table EMPLOYEE on the columns enum and lname.</p>
	<br/>
	<p>CREATE VIEW EMPVIEW AS</p>
	<p>( SELECT enum, lname</p>
	<p>FROM EMPLOYEE);</p>
	<br/>
	<p>Next, we con sider an INSERT statement applied to a relational view EMPVIEW:</p>
	<br/>
	<p>INSERT INTO EMPVIEW( 007, 'Bond');</p>
	<br/>
	<p>An insertion applied to a relational view EMPVIEW must be translated into INSERT statement into a base table EMPLOYEE because relational view occupies no persistent storage and it is represented by SELECT statement stored in data dictionary. If a relational table EMPLOYEE consists of four columns enum, fnane, lname and dob then translation of INSERT statement cannot provide the values fro the columns fname and dob. In such a case the default values must be used.  When INSERT statement fires a trigger then the new values must be for fname and dob are set in a body of a trigger and then a complete row can be inserted into a relational table EMPLOYEE.</p>
	<br/>
	<p>Hence, to fire a trigger instead of INSERT operation on a relational view EMPVIEW the following temporal option can be used.</p>
	<br/>
	<p>INSTEAD OF INSERT ON EMPVIEW</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
    <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	 <li>Fire a trigger instead of <strong class="blue prettyprint">INSERT</strong> operation on a relational view <strong class="blue prettyprint">EMPVIEW</strong>
	   <ul class="build">
	     <pre class="prettyprint" data-lang="A sample temporal option">

INSTEAD OF INSERT ON EMPVIEW</pre>
	 </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 15 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In a general case a database trigger can be fired by any sequence of events. In commercial database systems database triggers can be usually fired only by range of single (atomic) events. For example, the events like Data Manipulation events, Data Definition events and Database events.</p>
	<br/>
	<p>Data manipulation events include INSERT or UPDATE or DELETE or MERGE statements.</p>
	<br/>
	<p>Data Definition events include any CREATE or ALTER or DROP statements, like for example CREATE VIEW, ALTER TABLE, DROP INDEX, etc.</p>
	<br/>
	<p>Database events include events such as a database server error, startup/shutdown of a database server, logon/logoff of a user, etc.</p>
	<br/>
	<p>We show below the sample applications of DML events.</p>
	<br/>
	<p>To fire a trigger before update on one or more columns attribute1, attribute2, ... in a relational table table we set up the following event:</p>
	<p>BEFORE UPDATE OF attribute, attribute,... ON table;</p>
	<br/>
	<p>To fire a trigger after insertion of a row or a group of rows into a relational table table we set up the following event:</p>
	<p>AFTER INSERT ON table;</p>
	<br/>
	<p>To fire a trigger before deletion of a row or a group of row  in a relational table table we set up the following event:</p>
	<p>BEFORE DELETE ON table;</p>
	<br/>
	<p>To fire a trigger either after deletion of a row or a group of rows or after insertion of a row or a group of rows or after update of a row or a group of rows we set up the following event:</p>
	<p>AFTER DELETE OR INSERT OR UPDATE ON table;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The following events can fire a trigger
	  <ul class="build">
            <li><strong class="red">Data Manipulation event</strong> - any <strong class="blue prettyprint">INSERT</strong> or <strong class="blue prettyprint">UPDATE</strong> or <strong class="blue prettyprint">DELETE</strong> statement</li>
	    <li><strong class="red">Data Definition event </strong> - any <strong class="blue prettyprint">CREATE</strong> or <strong class="blue prettyprint">ALTER</strong> or <strong class="blue prettyprint">DROP</strong> statement</li>
	    <li><strong class="red">Database events</strong> - the events such as a database server error, startup/shutdown of a database server, logon/logoff of a user, etc</li>
	  </ul>
	</li>
	<li>Sample applications of <strong class="red">DML events</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample DML event">

BEFORE UPDATE OF attribute, attribute,... ON table</pre> 
	    <pre class="prettyprint" data-lang="A sample DML event">

AFTER INSERT ON table</pre> 
	    <pre class="prettyprint" data-lang="A sample DML event">

BEFORE DELETE ON table</pre> 
	    <pre class="prettyprint" data-lang="A sample DML event">

AFTER DELETE OR INSERT OR UPDATE ON table</pre> 
	 </ul>
	</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 16 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Here are the sample set ups required for Data Definition events.</p>
	<br/>
	<p>To fire a trigger after application of ALTER statement on any database object like relational table, relational view, etc we set up the following event:</p>
	<p>AFTER ALTER database object;</p>
	<br/>
	<p>To fire a trigger before application of CREATE statement to create any database object like relational table, relational view, etc we set up  the following event:</p>
	<p>BEFORE CREATE database object;</p>
	<br/>
	<p>To fire a trigger after application of DROP statement to drop any database object like relational table, relational view, etc we set up the following event:</p>
	<p>AFTER DROP database object;</p>
	<br/>
	<p>To fire a trigger after application of GRANT statement to any database object like relational table or relational view we set up the following event:</p>
	<p>AFTER GRANT database object;</p>
	<br/>
	<p>ANALYZE statement can be used to provide information about the statistical properties of database objects stored in persistent storage, like for example, total number data blocks, average number of rows per data block, total number of rows chained over many data blocks, total number of empty blocks etc. To fire a trigger before application of ANALYZE statement to a database object we set up the following event:</p>
	<p>BEFORE ANALYZE database object;</p>
	<br/>
	<p>To fire a trigger after application of GRANT statement with a system privilege we set up the following event:</p>
	<p>AFTER GRANT system privilege;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Sample applications of <strong class="red">DDL events</strong>
	   <ul class="build">
	     <pre class="prettyprint" data-lang="A sample DDL event">

AFTER ALTER database object</pre> 
	     <pre class="prettyprint" data-lang="A sample DDL event">

BEFORE CREATE database object</pre> 
	     <pre class="prettyprint" data-lang="A sample DDL event">

AFTER DROP database object</pre> 
	     <pre class="prettyprint" data-lang="A sample DDL event">

AFTER GRANT database object</pre> 
	     <pre class="prettyprint" data-lang="A sample DDL event">

BEFORE ANALYZE database object</pre> 
	     <pre class="prettyprint" data-lang="A sample DDL event">

AFTER GRANT system privilege</pre> 
	    </ul>
	 </li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 17 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Here are the sample set ups required for Data Definition events.</p>
	<br/>
	<p>To fire a trigger after server failure we set up the following event:</p>
	<p>AFTER SERVERERROR ON SCHEMA</p>
	<br/>
	<p>To fire a trigger before a user is logged to the system we set up the following event:</p>
	<p>BEFORE LOGON</p>
	<br/>
	<p>To fire a trigger before a user logs off the system we set up the following event:</p>
	<p>BEFORE LOGOFF</p>
	<br/>
	<p>To fire a trigger just after a startup of database server is completed we set up the following event:</p>
	<p>AFTER STARTUP</p>
	<br/>
	<p>To fire a trigger just before a shutdown of database server we set up the following event:</p>
	<br/>
	<p>BEFORE SHUTDOWN</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Sample applications of <strong class="red">Database events</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample database event">

AFTER SERVERERROR ON SCHEMA</pre> 
	    <pre class="prettyprint" data-lang="A sample database event">

BEFORE LOGON</pre> 
	    <pre class="prettyprint" data-lang="A sample database event">

BEFORE LOGOFF</pre> 
	    <pre class="prettyprint" data-lang="A sample database event">

AFTER STARTUP</pre> 
	    <pre class="prettyprint" data-lang="A sample database event">

BEFORE SHUTDOWN</pre> 
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 18 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A condition component of CREATE OR REPLACE TRIGGER statement determines whether a trigger that has been fired processes its body or not.</p>
	<p>Processing of a trigger's body depends on evaluation of a condition. Typically a trigger's condition consists of atomic conditions on pseudorecords NEW and OLD in row triggers.</p>
	<br/>
	<p>Syntax of a condition component of a trigger is the following.</p>
	<p>WHEN (condition)</p>
	<br/>
	<p>implementation of a condition where a trigger processes its body only when value in a column "status" changes due to UPDATE from 'BUSY' to 'AVAILABLE' is expressed in the following way. Again, note the missing : in front of NEW and OLD due to WHEN condition being a part of SQL statement and not PL/SQL code).</p>
	<p>WHEN (OLD.status = 'BUSY' AND NEW.status = 'AVAILABLE');</p>
	<br/>
	<p>A condition where a trigger processes its body only when a new value in a column "amount" is greater than 1000 is expressed in the following way.</p>
	<p>WHEN (NEW.amount > 1000 );</p>
	<br/>
	<p>A condition where a trigger processes its body only when an old value in a column "credits" is either 6 or 12 is expressed in the following way.</p>
	<p>WHEN (OLD.credits IN (6, 12));</p>
	<br/>
	<p>OLD and NEW are so called pseudorecords such that for:</p>
	<p>- INSERT triggering operation OLD contains no values and NEW contains the new values</p>
	<p>- UPDATE triggering operation OLD contains the old values and NEW contains the new values</p>
	<p>- DELETE triggering operation OLD contains the old values and NEW contains no values</p>
	<p>Finally, remember that pseudorecord can only be used is row triggers and in statement triggers.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Condition</strong> determines whether a trigger processes its body after it has been fired</li>
	<li>Sample applications of <strong class="red">condition</strong>
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A sample condition">
WHEN (condition)</pre> 
	    <pre class="prettyprint" data-lang="A sample condition">
WHEN (OLD.status = 'BUSY' AND NEW.status = 'AVAILABLE');</pre> 
	    <pre class="prettyprint" data-lang="A sample condition">

WHEN (NEW.amount > 1000 );</pre> 
	    <pre class="prettyprint" data-lang="A sample condition">

WHEN (OLD.credits IN (6, 12));</pre> 
	  </ul>
	</li>
	<li><strong class="blue prettyprint">OLD</strong> and <strong class="blue prettyprint">NEW</strong> are so called <strong class="red">pseudorecords</strong> such that for
	  <ul class="build">
	    <li><strong class="blue prettyprint">INSERT</strong> triggering operation <strong class="blue prettyprint">OLD</strong> contains no values and <strong class="blue prettyprint">NEW</strong> contains the new values</li>
	    <li><strong class="blue prettyprint">UPDATE</strong> triggering operation <strong class="blue prettyprint">OLD</strong> contains the old values and <strong class="blue prettyprint">NEW</strong> contains the new values</li>
	    <li><strong class="blue prettyprint">DELETE</strong> triggering operation <strong class="blue prettyprint">OLD</strong> contains the old values and <strong class="blue prettyprint">NEW</strong> contains no values</li>
	  </ul>
	<li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 19 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a href="#6">Active database system</a></li>		
	<li><a href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a class="red" href="#19">Statement database triggers</a></li>	
	<li><a href="#22">Row database triggers</a></li>	
	<li><a href="#35">Problems with database triggers</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 20 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the next few slides we look more thoroughly at the differences between STATEMENT and ROW triggers.</p>
	<p>We start from statement triggers.</p>
	<br/>
	<p>A statement trigger fires once either before or after a triggering event no matter how many rows are affected by a triggering event. For example, if a triggering event is processing of UPDATE statement and the statement modifies 100 rows then still a statement trigger fires one time before or after processing UPDATE statement.</p>
	<br/>
	<p>Assume that we would like to implement a simple log of delete and update statements processed on a relational table DEPARTMENT. A log supposed to be stored in a relational table DEPTAUDIT. A single entry in a log consists of a statement code (either 'DELETE' or 'UPDATE') and date and time when a statement was processed.</p>
	<br/>
	<p>We use CREATE OR REPLACE procedure statement to create a trigger "ModifyDepartment".</p>
	<br/>
	<p>CREATE OR REPLACE TRIGGER ModifyDepartment</p>
	<br/>
	<p>An log entry can be written into a log table after processing of DELETE or UPDATE statement on a table DEPARTMENT is completed. Hence a temporal option is AFTER and event is DELETE OR UPDATE ON DEPARTMENT.</p>
	<br/>
	<p>AFTER DELETE OR UPDATE ON DEPARTMENT</p>
	<br/>
	<p>A body of a trigger starts from a keyword BEGIN  and we do not use FOR EACH ROW clause  because a trigger is a statement trigger and not a row trigger.</p>
	<br/>
	<p>BEGIN   -- Statement triggers have no FOR EACH ROW clause!</p>
	<br/>
	<p>Next, in a body of a trigger we recognize a triggering statement and depending on a triggering statement we put a row with a code 'DELETE' or 'UPDATE' into  a log table DEPAUDIT. A row function SYSDATE provide the current date and time</p>
	<br/>
	<p>IF DELETING THEN</p>
	<p>INSERT INTO DEPTAUDIT VALUES('DELETE', SYSDATE);</p>
	<p>ELSIF UPDATING THEN</p>
	<p>INSERT INTO DEPTAUDIT VALUES('UPDATE', SYSDATE);</p>
	<p>END IF;</p>
	<br/>
	<p>A keyword END concludes a body of a trigger.</p>
	<p>END;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Statement database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">statement trigger</strong>  fires once either before or after a triggering event</li>
	<li>A sample <strong class="red">statement</strong> trigger
	   <ul class="build">
	     <pre class="prettyprint" data-lang="Trigger name">

CREATE OR REPLACE TRIGGER ModifyDepartment</pre> 
	     <pre class="prettyprint" data-lang="Temporal option and event specification">

  AFTER DELETE OR UPDATE ON DEPARTMENT</pre> 
	     <pre class="prettyprint" data-lang="Start of statement trigger's body">

  BEGIN       -- Statement triggers have no FOR EACH ROW clause!</pre> 
	     <pre class="prettyprint" data-lang="Trigger condition">

   IF DELETING THEN</pre> 
	     <pre class="prettyprint" data-lang="Trigger's body">      INSERT INTO DEPTAUDIT VALUES('DELETE', SYSDATE);</pre> 
	     <pre class="prettyprint" data-lang="Trigger's body">   ELSIF UPDATING THEN</pre> 
	     <pre class="prettyprint" data-lang="Trigger's body">      INSERT INTO DEPTAUDIT VALUES('UPDATE', SYSDATE);</pre> 
	     <pre class="prettyprint" data-lang="End of trigger's body">

   END IF;</pre> 
	     <pre class="prettyprint" data-lang="End of trigger's body">  END;</pre> 
	   </ul>
	</li>

      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 21 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A trigger is processed in the following way.  Assume that the following UPDATE statement has been processed and not COMMITed yet.</p>
	<p>UPDATE DEPARTMENT</p>
	<p>SET budget = budget + 1000</p>
	<p>WHERE budget < 5000;</p>
	<br/>
	<p>A feedback from processing of UPDATE indicates tat 3 rows have been updated.</p>
	<br/>
	<p>3 row updated</p>
	<br/>
	<p>The following fragment of a body of a trigger ModifyDepartment is processed immediately after processing of UPDATE statement:</p>
	<br/>
	<p>BEGIN </p>
	<p>IF DELETING THEN</p>
	<p>...</p>
	<p>ELSIF UPDATING THEN</p>
	<p>INSERT INTO DEPTAUDIT VALUES('UPDATE', SYSDATE);</p>
	<p>END IF;</p>
	<p>END;</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Statement database trigger</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>Assume that the following <strong class="blue prettyprint">UPDATE</strong> statement has been processed and not <strong class="blue prettyprint">COMMIT</strong>ed yet
	  <ul class="build">
	    <pre class="prettyprint" data-lang="UPDATE statement">
	      
UPDATE DEPARTMENT
SET budget = budget + 1000
WHERE budget < 5000;</pre> 
	       <pre class="prettyprint" data-lang="Feedback message">

3 row updated</pre>
	  </ul>
	</li>
	<li>The following body of a trigger <strong class="blue prettyprint">ModifyDepartment</strong> has been processed immediately <strong class="red">after</strong> processing of <strong class="blue prettyprint">UPDATE</strong> statement
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A body of statement trigger">

BEGIN 
  IF DELETING THEN
    INSERT INTO DEPTAUDIT VALUES('DELETE', SYSDATE);
  ELSIF UPDATING THEN
    INSERT INTO DEPTAUDIT VALUES('UPDATE', SYSDATE);
  END IF;
END;</pre>
	 </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 22 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
        <li><a href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a href="#6">Active database system</a></li>		
	<li><a href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a href="#19">Statement database triggers</a></li>	
	<li><a class="red" href="#22">Row database triggers</a></li>	
	<li><a href="#35">Problems with database triggers</a></li>				
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>
<!-- slide 23 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now, we look at row triggers.</p>
	<br/>
	<p>A row trigger fires either after or before a triggering event affects a single row in a relational table. It is the main difference between statement triggers and row triggers. When a temporal option BEFORE is used a trigger fires once before a triggering event affects a row in a relational table. When a temporal option AFTER is used a trigger fires once after a triggering event affects a row in a relational table..</p>
	<br/>
	<p>For example, if a triggering event is processing of UPDATE statement and the statement modifies 100 rows then a row trigger fires 100 times either before or after a single row is processed by UPDATE statement (a triggering event).</p>
	<br/>
	<p>For example, if a temporal option is BEFORE and event is iNSERT ON DEPARTMENT then a trigger fires before each insertion into a relational table DEPARTMENT (it is possible to perform many insertions in one INSERT statement when a multirow INSERT statement is processed)</p>
	<br/>
	<p>For example, if a temporal option is AFTER and event is UPDATE ON EMPLOYEE then a trigger fires after a row is updated in a relational table EMPLOYEE.</p>
	<br/>
	<p>If a triggering event updates n rows then a trigger fires n times.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A <strong class="red">row trigger</strong> fires either after or before a triggering event affects a row in a relational table
	  <ul class="build">
	    <li>When a <strong class="red">temporal option</strong> <strong class="blue prettyprint">BEFORE</strong> is used a trigger fires <strong class="red">once before</strong> a triggering event affects a row in a relational table</li>
	    <li>When a <strong class="red">temporal option</strong> <strong class="blue prettyprint">AFTER</strong> is used a trigger fires <strong class="red">once after</strong> a triggering event affects a row in a relational table</li>
	  </ul>
	<li> For example, if a <strong class="red">temporal option</strong> and <strong class="red">event</strong> are
	  <ul class="build">
	    <pre class="prettyprint" data-lang="A temporal option and event">BEFORE INSERT ON DEPARTMENT</pre>
	  </ul>
	</li>
	<li>then a trigger fires before each insertion into a relational table (it is possible to have many insertions when a multirow <strong class="blue prettyprint">INSERT </strong> statement is processed)</li>
	<li> For example, if a <strong class="red">temporal option</strong> and <strong class="red">event</strong> are
	  <ul class="build">	
	    <pre class="prettyprint" data-lang="A temporal option and event">AFTER UPDATE ON EMPLOYEE</pre>
	  </ul>
	</li>
	<li>then a trigger fires after a row is updated in a relational table, if a triggering event updates <strong class="red">n</strong> rows then a trigger fires <strong class="red">n</strong> times</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 24 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>For example, if a temporal option IS AFTER and triggering event is DELETE ON PROJECT</p>
	<br/>
	<p>Then a trigger fires after each row is deleted from a relational table, if a triggering event deletes n rows then a trigger fires n times.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li> For example, if a <strong class="red">temporal option</strong> and <strong class="red">event</strong> are
	  <ul class="build">	
	    <pre class="prettyprint" data-lang="A temporal option and event">

AFTER DELETE ON PROJECT</pre> 
	</ul>
	</li>
	<li>Then a trigger fires after a row is deleted from a relational table, if a triggering event deletes <strong class="red">n</strong> rows then a trigger fires <strong class="red">n</strong> times</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 25 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Assume that we would like to implement a simple log of updates processed on a relational table DEPARTMENT and such that only modifications of rows that have a value 'Boston' in a column "city" are traced. A log supposed to be stored in a relational table DEPTTRACE. A single entry in a log consists of a statement code ('UPDATE'), date and time when a statement was processed, new values in the columns "name", "budget", and "city and old values in the same columns. A trigger must be implemented as row trigger because we would like to trace modifications performed on each and not entire table like in a statement trigger.</p>
	<br/>
	<p>We use CREATE OR REPLACE procedure statement to create a trigger "UpdateDepartment".</p>
	<br/>
	<p>CREATE OR REPLACE TRIGGER UpdateDepartment</p>
	<br/>
	<p>An log entry must be written into a log table after processing of UPDATE statement on each row in a table DEPARTMENT such that after modification a value in a column "city" is equal to 'Boston'. Hence a temporal option is AFTER and event is UPDATE ON DEPARTMENT.</p>
	<br/>
	<p>AFTER UPDATE ON DEPARTMENT</p>
	<br/>
	<p>A trigger must be a row trigger because we would like to record information about modifications of individual rows in a table DEPARTMENT. A clause FOR EACH ROW makes a trigger a row trigger.</p>
	<br/>
	<p>FOR EACH ROW  -- Row trigger must have FOR EACH ROW clause !</p>
	<br/>
	<p>We would like to trace the updates to the rows such that after modification on a row a value in a column "city" is equal to 'Boston'. To implement such condition we use WHEN clause with a condition NEW.city = 'Boston'</p>
	<br/>
	<p>WHEN (NEW.city = 'Boston')-- Only for row triggers!</p>
	<br/>
	<p>A body of a row trigger contains only INSERT statement that stores in a log table DEPTTRACE an operation code ('UPDATE'), current date and time, new values in the columns "name", "budget", "city" and old values in the same columns.</p>
	<br/>
	<p>BEGIN</p>
	<p>INSERT INTO DEPTTRACE VALUES</p>
	<p>('UPDATE', SYSDATE, :NEW.name, :NEW.budget, :NEW.city,</p>
	<p> :OLD.name, :OLD.budget, :OLD.city );</p>
	<p>END;</p>
	<br/>
	<p>The next few slides show a trace of a sample processing of a trigger UpdateDepartment.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample <strong class="red">row</strong> trigger
	  <ul class="build">
	    <pre class="prettyprint" data-lang="Trigger name">

CREATE OR REPLACE TRIGGER UpdateDepartment</pre> 
	    <pre class="prettyprint" data-lang="Temporal option and event">

  AFTER UPDATE ON DEPARTMENT</pre> 
	    <pre class="prettyprint" data-lang="Row trigger">

  FOR EACH ROW              -- Row trigger must have FOR EACH ROW clause !</pre> 
	    <pre class="prettyprint" data-lang="Trigger condition">

  WHEN (NEW.city = 'Boston')-- Only for row triggers!</pre> 
	    <pre class="prettyprint" data-lang="Start of trigger's body">

  BEGIN</pre> 
	    <pre class="prettyprint" data-lang="Trigger's body">    INSERT INTO DEPTTRACE VALUES</pre> 
	    <pre class="prettyprint" data-lang="Trigger's body">           ('UPDATE', SYSDATE, :NEW.name, :NEW.budget, :NEW.city,</pre> 
	    <pre class="prettyprint" data-lang="Trigger's body">                               :OLD.name, :OLD.budget, :OLD.city );</pre> 
	    <pre class="prettyprint" data-lang="End of trigger's body">

  END;</pre> 
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 26 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>We trace processing of the following update statement.</p>
	<br/>
	<p>UPDATE DEPARTMENT</p>
	<p>SET budget = budget +1000</p>
	<p>WHERE budget <= 5000;</p>
	<p>A trace starts from processing of the first row by UPDATE statement. A value in a column "budget" is 1300. Hence the row must be updated. A value in a column budget changes to 2300 and a trigger UpdateDepartment fires. WHEN condition is satisfied because a value in a column "city" is 'Boston" and a body of the trigger is processed. A row with 'UPDATE' indicator, the current data and time and the old and new values in the columns is recorded ina relational table DEPTTRACE.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>A sample processing of a row database trigger
	  <ul class="build">
	    <p style="text-align:center;"><img src="images/RowTrigger19.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
	<li>A trigger fires after <strong class="blue prettyprint">UPDATE</strong> of a row <strong class="blue prettyprint">[Math 2300 Boston]</strong></li>
	<li><strong class="blue prettyprint">WHEN </strong> condition is statisfied and a trigger processes its body</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 27 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Processing of UPDATE statement moves to the next row. A value in a column budget is 9999 and a condition in WHERE clause is not satisfied. The row is not updated and the trigger does not fire.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul>
	<li>A sample processing of a row database trigger
	  <ul>
	    <p style="text-align:center;"><img src="images/RowTrigger20.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
      <ul class="build">
	<li>A row <strong class="blue prettyprint">[Comp 9999 Boston]</strong> does not satisfy a condition in <strong class="blue prettyprint">WHERE</strong> clause and it is not <strong class="blue prettyprint">UPDATE</strong>ed</li>
	<li>A trigger does not fire</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 28 ================================================================================= -->

<slide>
 <aside class="note">
      <section>
	<p>Processing of UPDATE moves to the next row. A value in a column "budget" is 4000 and a condition in WHERE evaluates to TRUE. It means that the row must be updated. A value in a column "budget" changes to 5000 and the trigger is fired.</p>
	<br/>
	<p>A condition in WHEN clause fails because a value in a column "city" is not 'Boston' and trigger's body is not processed.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul>
	<li>A sample processing of a row database trigger
	  <ul>
	    <p style="text-align:center;"><img src="images/RowTrigger21.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
      <ul class="build">
	<li>A trigger fires after <strong class="blue prettyprint">UPDATE</strong> of a row <strong class="blue prettyprint">[Phys 5000 New York]</strong></li>
	<li><strong class="blue prettyprint">WHEN </strong> condition is not statisfied and a trigger does not process its body</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 29 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Processing of UPDATE statement moves to the next row. A value in a column budget is 8000 and a condition in WHERE clause is not satisfied. The row is not updated and the trigger does not fire.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul>
	<li>A sample processing of a row database trigger
	  <ul>
	    <p style="text-align:center;"><img src="images/RowTrigger22.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
      <ul class="build">
	<li>A row <strong class="blue prettyprint">[Math 8000 Atlanta]</strong> does not satisfy a condition in <strong class="blue prettyprint">WHERE</strong> clause and it is not <strong class="blue prettyprint">UPDATE</strong>ed</li>
	<li>A trigger does not fire</li>	
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 30 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Processing of UPDATE moves to the next row. A value in a column "budget" is 4500 and a condition in WHERE evaluates to TRUE. It means that the row must be updated. A value in a column "budget changes to 5500 and the trigger is fired.</p>
	<br/>
	<p>A condition in WHEN clause validates to TRUE because a value in a column "city" is 'Boston'. A body of the trigger is processed. A row with 'UPDATE' indicator, the current data and time and the old and new values in the columns is recorded in a relational table DEPTTRACE.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul>
	<li>A sample processing of a row database trigger
	  <ul>
	    <p style="text-align:center;"><img src="images/RowTrigger23.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
      <ul class="build">
	<li>A trigger fires after <strong class="blue prettyprint">UPDATE</strong> of a row <strong class="blue prettyprint">[Biol 5500 Boston]</strong></li>
	<li><strong class="blue prettyprint">WHEN </strong> condition is statisfied and a trigger processes its body</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 31 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A sample processing of a row database trigger is completed.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul>
	<li>A sample processing of a row database trigger is completed
	  <ul>
	    <p style="text-align:center;"><img src="images/RowTrigger24.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 32 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>Now, assume that SELECT statement that accesses a relational table DEPARTMENT is added to a body of the trigger. For example we can count the total number of distinct values in a column "budget" in a table DEPARTMENT. 
</p>
	<br/>
	<p>SELECT COUNT(DISTINCT budget)</p>
	<p>INTO cdbudget</p>
	<p>FROM DEPARTMENT;</p>
	<br/>
	<p>It creates a situation where processing of a trigger's body attempts to access a relational table affected by a triggering event (UPDATE). If UPDATE statement affects the values in a column "budget" then it is possible that for each processed row the total number of distinct values is different. For example all values in a column "budget" are changed to zero. Then, the total number of distinct values in a column "budget" changes from row to row. Then, a question what result is returned by SELECT statement that counts the total number of distinct value in a column "budget" is impossible to answer. It means that it is impossible to apply SELECT statement to a relational table affected by UPDATE statement while updates are processed row by row.</p>
	<br/>
	<p>From transaction processing point of view we speak about so called "statement level consistency". Statement level consistency means that a database cannot change its state while SQL statement is processed. In our case a relational table DEPARTMENT cannot be change while SELECT statement on such table is processed. It is why it is impossible to access the contents of a relational table while its rows are modified by a data manipulation statement.</p>
	<br/>
	<p>It is the reason why processing of SELECT statement in a body of a trigger while a relational table used by SELECT statement must fail.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
	<li>Assume that while processing a rows trigger it attempts to access a relational table affected by a triggering event</li>
	<li>For example, a triggers attempts to count the total number of rows in <strong class="blue prettyprint">UPDATE</strong>ed realtional table												
	  <ul class="build">
	    <p style="text-align:center;"><img src="images/RowTrigger25.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
	<li>What is a correct of summation over a column <strong class="blue prettyprint">budget</strong> ?</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 33 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>In the previous slide we found that it is impossible to provide a correct result of counting over a column "budget" while an UPDATE statement changes the values in the column. It is why an outcome from SELECT statement is a "mutating table error" when processing a row trigger. An error message says that a table DEPARTMENT is "mutating" (changing) during processing of SELECT statement and because of that access to a relational table DEPARTMENt inside trigger's body is impossible.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article class="smaller">
      <ul class="build">
	<li>It is impossible to provide a correct result of summation over a column <strong class="blue prettyprint">budget</strong> while an <strong class="blue prettyprint">UPDATE</strong> statement changes the values in the column</li>
	 <li>An outcome is a <strong class="red">mutating table</strong> error when processing a row trigger
	  <ul class="build">
	    <p style="text-align:center;"><img src="images/RowTrigger26.png" width="550" alt="ORM" title="ORM"></p>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 34 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>The solutions to the "mutating table " problem are the following.</p>
	<br/>
	<p>(1) If a trigger fires on INSERT and only one row is inserted then we can use a temporal option BEFORE. In such a case a relational table is not changed yet and it can be accessed from a trigger's body. Please note that column can be applied only when a row trigger fires BEFORE INSERT ON.</p>
	<br/>
	<p>(2) The second solution is to rewrite a trigger as a statement trigger. For example, if we have a row trigger that verifies a consistency constraint in each inserted/updated row by testing only the values in :NEW pseudorecord then transformation of a row trigger into a statement trigger is quite simple. We implement a statement that fires after insert/update and later on counts the total number of rows that violate a consistency constraint expressed on a single row. If a number returned from counting is not zero then it means that at least one row violated a consistency constraint and insert/update must be rolled back. If a row trigger validates a consistency constraint using both :OLD and :NEW pseudorecords then its implementation as statement trigger is not so simple. It is because a statement trigger provides us with the contents of relational table either before processing of insert/update or after processing of insert/update. We do not know either news values or old values. For example, implementation of a consistency constraint saying that increment of a value in a column cannot greater than a given percentage of the original value as a statement trigger is complicated because we need access to both old an new values. In theory it is possible to create a copy of an old state of a relational table and compare such copy with a state of the same table AFTER INSERT/UPDATE. It is not very efficient solution.</p>
	<br/>
	<p>(3) It is possible to automatically get access to the old state of a relational table in a situation when a trigger is defined as an autonomous transaction. It means that a body of a trigger processes as a separate transaction and not as an extension of a transaction that fired a trigger. Then, a transaction that implements a body of a trigger can see old state of a relational table. It cannot see the new state because a transaction that fired a trigger is not committed yet. Running a trigger as an autonomous transaction solves a problem of replacing a row trigger with a statement trigger in a situation when access to the values in a mutating table is needed before the modifications.</p>
	<br/>
	<p>(4) Yet another solution is to record the modification in a temporary table (commonly called as a transaction table)and to fire a trigger that verifies a consistency constraints  and reapplies the modifications as a statement trigger operating on a transaction table and the original state of a relational table.</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Row database triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>The solution to a <strong class="red">mutating table</strong> error problem
	  <ul class="build">
	    <li>If a trigger fires on <strong class="blue prettyprint">INSERT </strong>then use <strong class="blue prettyprint">BEFORE INSERT </strong> temporal option</li>
	    <li>Rewrite a trigger as a statement trigger</li>
	    <li>Run a trigger as an <strong class="red">autonomous transaction </strong></li>
	    <li>Record the modifications in a temporary table and fire a row trigger that reapplies the modifications as a statement trigger</li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 35 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">Database Triggers</h2>
      <h3 class="red">Outline</h3>
    </hgroup>
    <article>
      <ul>
       <li><a href="#2">Database trigger ?  What is it ?</a></li>	
	<li><a href="#6">Active database system</a></li>		
	<li><a href="#9"><strong class="blue prettyprint">CREATE OR REPLACE TRIGGER</strong> statement</a></li>	
	<li><a href="#19">Statement database triggers</a></li>	
	 <li><a href="#22">Row database triggers</a></li>	
	<li><a class="red" href="#35">Problems with database triggers</a></li>			
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 36 ================================================================================= -->
<slide>
 <aside class="note">
      <section>
	<p>A technology of database triggers is a very powerful mechanism that can simplify solutions to many different problems. Unfortunately as aways such very powerful technologies have their equally powerful "dark sides".</p>
	<br/>
	<p>The first problem we may encounter is an infinite chain of trigger invocations. Assume gthat a traigger A while processng its body fires a trigger B and a trigger B while processing its body fires a trigger A. Commercial database systems are able to deal with such problem and automatically detect a cycle in the invocations of the triggers. Then both triggers fail together with an application that fired one of the triggers.</p>
	<br/>
	<p>Another problem is an indeterministic trigger invocations. It may happen that due to a database transaction serialization mechanisms the same chain of trigger invocations will be processed (serialized) in many different way by a transaction scheduler, e.g. if two triggers A and B fire in more or less the same moment in time then sometimes A will be processed before B and sometimes B will be processed before A.</p>
	<br/>
	<p>Another problem is related to lack of external control of the functionality of the triggers. A long chain of trigger invocations may contribute to very serious data security risks, e.g. it is possible to "hide" malicious code at the end of long chains of trigger invocations.</p>
	<br/>
	<p>Finally, the triggers do nave a well tested design methodology. The ad hoc uncontrolled and not well planned additions of new triggers lead to a situation where after addition or modification of a trigger there is no certainty that the chains of trigger invocations do not corrupt a database</p>
	<br/>
      </section>
    </aside>  
    <hgroup>
      <h2 class="blue">Other problems with triggers</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li><strong class="red">Infinite chains of trigger invocations</strong>
	  <ul class="build">
	    <li>What to do when a trigger <strong class="blue prettyprint">A</strong> while processing its body fires a trigger <strong class="blue prettyprint">B</strong> and a trigger <strong class="blue prettyprint">B</strong> while processing its body fires a trigger <strong class="blue prettyprint">A</strong> ?</li>
	  </ul>
	<li><strong class="red">Indeterministic trigger invocations</strong>
	  <ul class="build">
	    <li>It may happen that due to a database transaction serialization mechanisms the same chain of trigger invocations will be processed (serialized) in many different way by a transaction scheduler, e.g. if two triggers <strong class="blue prettyprint">A</strong> and <strong class="blue prettyprint">B</strong> fire in more or less the same moment in time then sometimes <strong class="blue prettyprint">A</strong> will be processed before <strong class="blue prettyprint">B</strong> and sometimes <strong class="blue prettyprint">B </strong> will be processed before <strong class="blue prettyprint">A</strong></li>
	  </ul>
	<li><strong class="red">Lack of external control</strong>
	  <ul class="build">
	    <li>Long chains of trigger invocations contribute to very serious data security risks, e.g. it is possible to "hide" malicious code at the end of long chains of trigger invocations</li>
	  </ul>
	<li><strong class="red">Lack of design methodology</strong>
	  <ul class="build">
	    <li>The ad hoc uncontrolled and not well planned additions of new triggers lead to a situation where after addition or modification of a trigger there is no certainty that the chains of trigger invocations do not corrupt a databse</li>
	  </ul>
	</li>
      </ul>
<footer class="source"><strong class="blue">In HTML view press 'p' to see the lecture notes</strong><br/>
<a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
</slide>
<!-- slide 37 ================================================================================= -->
  <slide>
    <hgroup>
      <h2 class="blue">References</h2>
    </hgroup>
    <article>
      <ul class="build">
	<li>T. Connoly, C. Begg, Database Systems, A Practical Approach to Design, Implementation, and Management, Chapter 8.3 Triggers, Pearson Education Ltd, 2015</li>
	<li><a href="https://protect-au.mimecast.com/s/0b0XCL7E99TL9MJ0UPUvle?domain=docs.oracle.com">Database SQL Language Reference, <strong class="blue prettyprint">CREATE TRIGGER</strong></a></li>
	<li><a href="https://protect-au.mimecast.com/s/HQrNCMwG88tj3VQpcWK3Gf?domain=docs.oracle.com">Database PL/SQL Language Reference, 9 PL/SQL Triggers</a></li>	
      </ul>
<footer class="source"><a href="#2">TOP</a>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
2023</footer>
    </article>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + 'https://protect-au.mimecast.com/s/1impCNLJkkCo352YUrAbfR?domain=google-analytics.com';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>

